[{"id":0,"href":"/docs/translations/","title":"Translations","section":"Docs","content":" \u0026ldquo;Happiness is only real when shared. - Christopher McCandless\n "},{"id":1,"href":"/docs/translations/dod/01_%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1/","title":"01 面向数据设计","section":"Dod","content":"面向数据设计 #  面向数据设计，已经以各种形式存在了几十年，但直到 2009 年 9 月，才在 Noel Llopis 的同名文章 1 首次这样出现。一直以来，关于它算不算是种编程范式，争议不断。有人认为它可以与面向对象、过程式、函数式编程等其他范式混用。某种意义上的确如此，面向数据设计确实能同其他范式共同发挥作用，但也不否认，它是种更广义的编程方式。Lisp 程序员知道，函数式编程可以与面向对象共存，C 程序员很清楚面向对象能与过程式编程共存。这里，我们先将这些争议搁置，直接断言：面向数据设计是新的重要工具；它能够与其他工具共存。2\n2009 年正合适。革命性的硬件业已成熟；潜力巨大的计算机被无视硬件的编程范式束缚；开发者编码的方式能让许多引擎程序员落泪。但时代变了。现在许多移动端和桌面端解决方案，似乎不太需要面向数据设计，并不是机器擅长处理低效实现，而是游戏设计要求不高，也不复杂。但现在手游的开发趋势似乎正向 AAA 级迈进，又一次，产生了对复杂情况管理的需求，以期最大程度发挥硬件。\n如今，我们被多核设备围绕着，口袋里这个也不例外。学习如何较少依赖串行开发软件就变得尤为重要。面向数据的程序员能获得诸多好处，包括但不限于：摆脱对象信息传递、获得即时响应等。编程时，坚实依赖对数据流的认识，为将来进入 GPGPU 和其他计算方法做好准备。由此，落地诸多游戏构想。面向数据设计的需求只会增长。抽象和串行思维将制约你的竞争对手，而那些接受面向数据方法的人会茁壮成长。\n一切围绕数据 #  数据即一切。数据是创造用户体验时需要变换的；是打开文档时加载的；是屏幕上的图形；手柄按钮的脉冲；是扬声器震动空气产生的波；是角色升级的路线；也是对手向玩家开枪的诱因。数据是炸药引信的时长；是撞到尖刺掉宝的数量；是游戏结束时绚丽场景中每个粒子即时的位置和速度：经由源码，编译到汇编指令，再解码为机器指令，操纵磁盘读取内容，再一步步最终呈现到眼前。\n不存在没有数据的应用。没有图像，Photoshop 无从谈起。没有画笔、图层、笔压，它什么也不是。没有字符、字体、分页符，Microsoft Word 也没有意义。没有事件，FL Studio 毫无价值。没有源码，Visual Studio 只能算作花瓶。过去所有的程序，都是基于输入数据，输出数据。数据的形式有时极其复杂，有时简单到无需文档，但所有应用程序都接收、产出数据。如果没有可识别的数据，顶多只算是玩具、Demo。\n指令也是数据。指令会占用内存，使用带宽，并且可以被变换，加载，保存，构建。对于开发者，自然不会认为指令是数据3，但在旧的、保护性较差的硬件上，它们的区别很小。尽管大多数当代硬件，会保护为可执行文件预留的内存，避免其被损害、被修改，但这一相对较新的发明仍未成熟。改进的哈佛架构对内存中的数据和指令同等依赖4。因此，指令仍是数据，它们也是要变换的对象。我们接受指令并将其转化为行动。指令的数量、大小、频率都很重要。我们控制、筛选、使用哪些指令来解决问题的行为，即是优化。知道了数据是什么，便能决定如何处理数据。了解指令，便有了理论支撑，能决定哪些指令是必要的，哪些是冗余的，哪些可以用低成本方案替代。\n现在，我们有了面向数据的开发方法的论证基础，但还遗漏了一个主要因素。所有这些数据和及其变换，从字符串，到图像，再到指令，都必须在某样东西上运行。这个东西有时相当抽象，如，未知硬件上运行的虚拟机；有时又很具体，比如已知 CPU、GPU、内存容量、带宽的自己的电脑。所有情况下，数据又不仅仅是数据，而是存在于某个硬件上的数据，而且必须经由同一硬件变换。本质上讲，面向数据设计是变换结构良好的数据，设计软件的方法，其中结构良好的标准是由数据的目标硬件，对其执行变换的模式与类型共同决定。有时，数据并不是很明确，硬件可能也捉摸不透。但大多数情况下，良好的硬件评判能力几乎对每一个软件项目都有所帮助。\n如果应用程序的最终结果是数据，且所有的输入都可以表示为数据，并且了解所有的数据变换都没有凭空发生，那就可以基于此原则建立一个软件开发的方法论：理解数据，了解机器对特定数量、频率、统计量的数据执行变换时都发生了什么。在此基础上，就可以草拟一个关于如何使方法论面向数据的声明。\n数据不是问题域 #  原则一：数据不是问题域。\n对于有些人，面向数据设计似乎处于大多数其他编程范式的对立面，因为它不太容易让问题域进到软件源码中。它不鼓励将对象概念映射到用户的语境(Context)。因为数据刻意地，自始至终没有意义。重视抽象的范式会假装计算机和它的数据不存在，将字节、CPU管道、其他硬件特征等概念抽象出去，取而代之的是：引入问题模型。他们常把有观点的模型引入代码，或者把世界模型作为问题的语境。就是说，要么围绕预期解决方案的属性，要么围绕问题域的描述来构建代码。\n赋予数据意义就能创造信息。意义并非数据固有。只有一个数字 4，几乎没意义，但如果说 4 英里，或 4 个鸡蛋，就有了意义。假设有 3 个数字，作为一个三元组意义不大，但如果将它们命名为 $x , y , z$，就可以赋予其位置的意义。有一份游戏中的位置列表，在没有语境的情况下也没什么意义。面向对象设计可能会把位置作为对象的一部分，通过类的名称和相邻的数据（也已经命名），就可以推断出数据的含义。如果没有已命名的语境数据与之关联，位置可以被赋予其他意义。虽然某种程度上，把数字放在语境当中是好的，但同时也阻碍了把位置作为三个数字的集合来思考，然而这一点对程序员思考如何解决的真正问题时，至关重要。\n举例来讲，当把数据放在对象的深层，到后来又忘了它的存在。想想诸多已发售或尚在制作中的游戏，本可以使用一个 2D 或 3D 网格(grid)系统处理数据布局。不知为何，开发人员将地图上的每一个引用都实例化了。这还不是个例，在已经发售的游戏中，这种以对象为中心的方法摧残硬件的案例并不少见：相较于由真正的网格驱动，有数百个对象直接放置在世界空间的网格坐标上。可能程序员看到一个网格，看到所需的元素数量，就会对是否要为它分配一块内存而犹豫不决。一个简单的 $256 \\times 256$ 的 tileMap 需要 $65,536$ 个 tile 。面向对象程序员可能会觉得 6 万多个对象相当耗费。对他们来说，只在必要的时才为 tile 分配对象可能更有意义，甚至到了在编辑器中真的有 $65000$ 个人工创建的 tile 的地步。但正由于它们是人工放置的，必要性就被确定了，于是就变成了不得不处理的确切问题。\n缺乏对底层的认识，不仅会导致用糟糕的方式处理渲染、放置元素，同时在解释元素的位置时，也引入更高的复杂度。在无网格的形式上访问元素往往会有一些障碍，比如保有相邻元素的链接（需要保持更新）；或需要执行整个元素列表（开销很大）；或引用一个辅助的增强网格对象（或空间映射系统）管理那些被游戏设计限制移动的对象（原本可以自由移动的）。这种无网格设计带来的虚假的自由，流露出对数据的理解不足，并且已经给一些游戏造成了显著的性能损失。同样也是对程序员心智的极大浪费。\n除了当用不用网格系统，很多游戏还将每个对象都实例化，而不是用一个变量保存物品数量。对于某些游戏，这算种优化，因为创建、销毁对象也会产生相当大的开销。但这种趋势实在令人担忧，这种存储方式将游戏的数据结构埋藏至深处。\n许多游戏都试图把关于玩家的所有信息都保存在玩家类里。如果玩家在游戏中死亡，则须作为一个已死亡的对象继续存在，否则将无法访问成就数据。将数据是什么、存在哪里、与谁共享生命周期的联系到一起，带来单体类以及种种难以理清的关系。而这些关系被也随后被证明是最大的 bug 来源。在这里我不会提及任何游戏名称，不只是一个游戏，也不只是一个工作室，这是种不良技术设计的流行病。似乎那些使用现成的面向对象引擎的人比那些自己开发的人更易感，而且绝不局限于某个范式。\n面向数据设计并不会把现实问题的模型引入到代码里。资深的面向对象开发者常将其看作是面向数据方法的缺陷，因为面向对象设计的成功范例来自于：把人类的概念带到机器上，然后在这个中间地带，可以写出一个人类和计算机都能理解的解决方案。面向数据方法则把问题域留在设计文档中，因而放弃了些人类的可读性，将约束和期望的因素带入到变换中。但也正是这一类操作，可以防止机器在数据层面上处理人类的概念。\n现在考虑，在提倡无谓抽象的编程范式中，问题域如何成为软件的一部分。对于对象而言，我们把它包含的类及其相关的函数联系起来，将意义与数据联系起来。在高层次的抽象中，我们通过高层次的概念将操作与数据分离，而这一类概念可能并不适用于底层，从而使函数变得更难实现。\n类包含数据，就赋予了这些数据语境，但有时也会限制数据的复用，影响对操作的理解。针对语境添加函数可以访问更多的数据，但很快就会导致类中包含许多不同的数据。这些数据本身并不相关，但却得在同一个类里。因为某个操作需要语境，而这个语境由于某些原因需要更多数据，如，其他相关的操作。听起来很熟悉，引用 Joe Armstrong 的话说：\u0026quot;我认为缺乏复用性出现在面向对象的语言里，而不是函数式语言里。面向对象的语言的问题是它们随时携带着所有隐含的语境。你想要一根香蕉，但你得到的是一只拿着香蕉的大猩猩和整个丛林。\u0026quot;5显然这是被面向对象语言的语境引用问题困扰产生的吐槽。\n使用接口（或依赖注入）消除语境间的联系倒也情有可原，但实际的联系不止如此。对象中的语境往往用于联接不同类型，不同级别的数据。比如一根香蕉，有多种不同用途，可以作为一种水果，也可以代表一种颜色，抑或是以字母 B 开头的单词。需要仔细考量香蕉作为实例带来的问题，香蕉同时也可以是\u0026quot;种类\u0026quot;的实例。如果从进口商品的法律角度去看，或者要获取它的营养价值的信息，显然，相对于香蕉的库存数量，是截然不同的呈现。好在还是从香蕉说起。如果谈论的是大猩猩，那么我们也会止步于：大猩猩个体的信息；动物园或丛林中的大猩猩；以及大猩猩的种类。上述示例是给同一个名字的东西的三个不同层次的抽象。至少对于香蕉，每个个体并没有多少重要的数据。现实世界中也经常能看到这种语境的联系，但在对话中我们能够很好地处理了这种复杂度。一旦开始强行规定这些语境，就使得不同语境之间产生了联系。那么原本赋予的意义就会变得脆弱不堪。\n混合在一起的抽象层都很难解开，因为对每个语境进行操作的函数都会从各种类中拖入随机的数据块。也就意味着，为了保证正常访问，就不能随意删除数据。这足以阻止大多数程序员尝试大规模的软件项目。同时还有另一个问题，那就是隐藏对数据的操作，会引入不必要的复杂度。当看到链表、树、数组、map、表单、行，很容易就推测出其交互、变换方式。但如果你想对家庭、办公室、道路、上班族、咖啡馆、公园做同样的事情，往往会先陷入对问题域概念的思考中。反而因此错失了探明更好的数据表达和算法的这一类细节的机会。\n很少有计算机科学的算法不能在原始数据类型上重复使用。但是当引入新类，有自己的内部数据布局，没有明确遵循现有数据结构的模式，那么就不能完全利用这些算法，甚至可能看不到它们会如何应用。把数据结构放在你的对象设计中，从它们的本质来看可能是有意义的，但从数据操作的角度来看，往往没有什么意义。\n当从面向数据设计角度考虑数据时，数据只是一种存在，为了获取所需格式的输出，可以用任何必要的方式解释它。我们只关心我们做了什么变换，以及数据的最终去向。实践中，抛弃数据的含义，就减少了事实与其语境相互纠缠的几率，因此也降低了仅仅为了一两个操作而混合无关数据的可能性。\n数据与统计 #  原则二：数据指类型、频率、数量、布局、概率。\n这个原则是指，数据不仅仅是结构。对于面向数据设计，一个常见的误解是，以为只跟缓存命中 (cache miss) 有关。即便只是为了保证缓存命中率，也只是通过结构化数据，将冷、热数据分离开。这是种有效的编程技巧，但面向数据设计要考量的，是数据的所有方面。要写一本关于如何避免缓存未命中的书，需要的不仅仅是些关于如何组织结构的技巧，还需要了解当计算机在运行程序时，里面究竟发生了什么。在书里讲这些也不太现实，因为这只适用于一代的硬件和一代的编程语言。尽管获益最大的是 C++，而收效最大的硬件是任何存在不平衡的瓶颈的硬件，但面向数据设计并不只植根于一种语言和某些不寻常的硬件。数据的模式很重要，但是数值和数据的变换方式同样重要，甚至更重要。通过猎豹的照片来了解它能跑多快终究是纸上谈兵。要在野外环境里去看，去了解慢的真正代价。\n面向数据设计模式以数据为中心。以实时的、真实的、同时也是信息的数据为支点。而面向对象的设计则以问题的定义为中心。对象不是真实的东西，而是要被解决的问题的语境的抽象表示。对象通过操作所需的数据以表示它们，不考虑硬件或现实世界的数据模式与数量。这就是为什么面向对象设计能够快速建立起应用程序的原型，允许把早期的设计文档或问题定义直接放进代码，从而快速尝试解决方案。\n面向数据设计采取了另一套策略，相较于假设用户对硬件一无所知，这里选择假设用户对问题的真正性质知之甚少，并将数据模式贬为二等市民。任何一个写过大型软件的人都会意识到，一个项目的技术结构和设计经常会发生很大的变化，以至于在后来的实施过程中，几乎没有任何部分能维持初稿的设计。面向数据设计避免了资源浪费，它从不认为设计需要存在于文档之外的任何地方。通过一系列上层代码来控制事件序列，解决当前问题，并指定模式来赋予数据临时的意义，从而推进工作。\n面向数据设计从已有或预期的数据中获取线索。相较于为所有可能性，或保证扩展性做规划，不如说它倾向于使用最可能的输入来决策算法。与其说计划需要支持扩展性，不如说计划要简单、可替换，并能够落实。扩展性能以后再添加，通过单元测试这张安全网，确保它简单，且仍能正常工作。好在已经有一种不需要过多考虑，就能够保证扩展性的技术了：就是利用经过多年实践开发的数据库技术。\n引入关系模型后，数据库技术发生了巨大的转变。在Out of the Tar Pit [^bmospmark] 一文中提到了通过函数式方法变换关系模型数据结构，使得函数式关系编程6又向前迈进了一步。这份文献，正是一部教你如何调整数据结构匹配需求的秘籍。\n数据是可变的 #  面向数据设计只适用于当下。它无法解决过去的问题，也不是什么新颖的方案，更不是解决潜在问题的通用方案。拘泥于过去会干扰灵活性，一味的着眼未来则又可能一场空，毕竟程序员也不是什么算命先生。以作者之浅见，很少有面向未来的系统。实际应用中，伴随着设计发生变化，面向对象设计的弱点才开始显现。\n在面向对象设计的介绍中常提到：面向对象设计能很好地处理底层实现细节的变化。但实际上，仅限于那些显著的、可预期的。它无法很好地处理诸如用户需求、输入格式、数量、频率、信息传输通道等这一类更实际的变化。在 On the Criteria To Be Used in Decomposing Systems into Modules7 中提到，当时许多人会像管线一样利用模块化，在方案的各个阶段使用可执行单元。每个阶段都可以看作解决局部问题的方案。在早期的文档中，模块化通过隐藏数据得以实现。当时这还算是一种改进，但在后来的 Software Pioneers: Contributions to Software Engineering 8 一书中，作者重新审视了这个问题，并提醒我们，虽然这样在开发初期根据业务状况做方案选择时更快，但同时也会增加维护和迭代成本。受到这种固有惯性的影响，面向对象的设计方法始终会有问题域与实现之间的耦合。如前所述，当问题域被引入到实现中，可以立即看到实现是否有效处理、解决了当下问题，因而可以快速做出决策。但面向对象设计的问题在于，在更高层次上的变化是不可避免的。\n设计会因许多原因改变，偶尔也会包括实际上没有改变的时候。对设计的误解，或者是曲解，会直接改变设计，进而改变实现。面向数据代码的设计从数据层面理解其变化的意义，反过来指导设计。不同于 OOP 在封装内部操作状态，面向数据还允许在数据源发生变化时，修改代码。通常而言，对比对象的复用和突变，数据块及其变换的耦合和解耦更易实现，因而 DOD 能更好地处理变化。\n数据，与其特征和用法产生了关联。把数据及其功能与对象混为一谈时，对象即为数据的画皮。数据的特征与对象关联，意味着很难从其他视角考虑数据。因而数据的用例和真实的设计，都与对象暗含的用法和特征产生联系。若数据的布局与用法相关联，而用法又与数据的特征相关联，就很难仅仅根据特征拆解数据。不同特征用到不同的数据子集时，因其(特征)相互交叠，便会化为重重阻碍。同时交叠的数据又会形成一个越来越大的值集，作为独立的单元在系统中到处传递。这种情况，常见的做法是将一个类重构为多个类，或将数据的所有权交给不同的类。这就是将数据与一种特征联系起来。强行赋予数据以目的。而对于静态对象，则是多个预定义的目的合集，甚至还会引入原本不存在的联系。有些目的可能不再是设计所需。然而，需求的关联总比不需求的更明显，看得见的、看不见的，随着时间的推移，关联只会越来越多。\n倘若通过数据的关联性来决定其操作，如给一个类添加新方法：在数据改变或被拆分时，就很难再移除对数据的操作了；而当一个操作需要数据关联在一起，那不太方便再拆分数据了。但如果把数据与对其的操作分开，将数据的各个特征、用途，从操作与数据变换中提取出来，就不难发现：原本面向对象代码重构时会遇到的困难，变得微不足道。但也是有代价的，需要维护一份操作与其所需数据的标记（用于间接查找和访问），同时面临二者可能的不同步的风险。综上，代码保持面向对象的风格：其中对象负责保持内部一致性，效率和可变性的优先级也不是那么高。有些时候，面向对象的设计是要远优于面向数据。例如系统或硬件驱动层：Vulkan 和 OpenGL 是面向对象的，只不过对象的粒度很大，并在它自己的体系里与保持理念一致；又或者像 FILE 类型的面向对象方法：文件系统中的打开、关闭、读取、写入等操作。\n许多刚接触面向数据设计范式的人，常会有一个误解：可以通过抽象，设计一个静态库（或一组模板）作为通用的面向数据的方案，就能够解决本书中提出的所有问题。领域驱动设计 (DDD) 一样，面向数据设计是针对产品和工作流的。这里学习的是如何做面向数据设计，而不是如何将其添加到项目中。这里遵循的基本原则是：尽管数据的类型可以是通用的，但在其使用层面却不是。数值千变万化，但常常隐含我们可以利用的模式。数据能够通用的想法，从根本上就是错的，面向数据设计则要去纠正它。应用于数据的变换，在某种意义上可以通用，但实际执行的操作及其次序，才是实质上的解决方案。源码是将数据从一种形式变换为另一种形式的秘方。不会有一个模板库去理解和利用数据中的模式，这应当是一个成功的面向数据设计的任务。诚然，我们可以建立算法来匹配数据中的模式（比如压缩），但提及面向数据设计时，这个模式是更高层次的，特定域(domain-specific)的，而非单纯的频率映射。\n程序运行时，常会使用一些专业技巧优化性能。这样或许会降低代码可读性，但也常常因不是面向对象，或因为是硬编码的原因不被采纳。硬编码一个变换，可能要比把它包装进通用容器，再套一层算法来假装它不是硬编码来得好。如果熟悉现有模板库，直接用现成，可读性会更好；当然如果恰巧用到的是通用功能，潜在错误也会减少。但如果该功能没能很好地映射到现有的通用解决方案中，此时通过函数模板再对其扩展，无疑增加了理解代码的难度。取巧地将背后技术已被替换这一事实隐藏，会产生误导。这时候，硬编码一个实质上的新算法可能会更好，当然前提是做好充分测试。如果限定在具体数据上，只用简单真实的数据（而不是什么通用数据，通用类型）测试，测试也更好写。\n数据的形态 #  现如今的游戏有大量不同格式的数据：针对不同平台的纹理；根据骨架、播放类型优化过的动画；音频、光照、脚本；还有由多个不同属性的 buffer 组合成的网格。只有很小一部分有固定用途，如顶点数据中的位置、UV 和法线。游戏开发中的数据很难框定，并且越来越难。许多以前无法实现的想法，现在逐渐流行。这也是为什么，需要在编辑器和工具链上花费大量时间，以便将设计师和美术们自由创作的产出，以某种形式放进引擎里。如果没有工具链、编辑器、查看器、调整工具，就不可能以同等时长产出游戏。面向对象是处理所有这些不同格式数据的方法之一。它能提供集中的视图，显示每种类型数据的归属，并根据可对其执行的操作归类。它还很容易快速添加、使用数据，但实现、封装这些不同的对象需要时间。有时对象归类的方式，无法再添加新功能时，可能还需要大量重构。例如，在许多过去的引擎中，纹理总是每像素 1、2、4 字节。随着引入浮点纹理，这些代码就都需要做些重构了。以前，顶点着色器中无法访问纹理。所以当基于纹理的蒙皮出现时，许多程序员不得不重构引擎渲染模块，使其能够更新顶点着色器的纹理，因为更新 transform 用以渲染蒙皮的网格时，可能会用到。PlayStation2 面世时，或某个引擎首次使用到着色器时，\u0026ldquo;材质\u0026rdquo; 这一概念，就发生了变化。从小型 3D 场景看向更开阔的世界的过程中，细节层次(LoD)不断变大。于是工程师们开始考虑，\u0026quot;渲染\u0026quot; 到底意味着什么。新的硬件越来越注重对齐，因此实现不得不变得难以插入操作。许多引擎中的网格数据是为渲染优化过的，但是如果必须对网格投射射线，以确定子弹命中的位置，或用 IK，或用物理，一个实体就需要有多重呈现。从这点来看，面向对象的方法就像是拼凑起来的，只有较少的对象用以代表实物，更多的则只是容器，程序员就得从更大的构建块的角度思考。实际上，这些块只会阻碍思考，在脑海中就只剩了独立的块，而其中内在的联系很快就被抛诸脑后了。从 2D 精灵到 3D 网格，始终遵循硬件厂商的格式，自定数据流和运算单元被转化为渲染的三角形。音频波形，到 bank 文件，到包络控制的音频粒子和多层音频的回放。Tile-map，到传送门、房间，再到流式的有多级 Lod 的世界，最后到混合网格调色板(hybrid mesh palette)、数据、特殊的混合资源。从翻书到欧拉角序列，到四元数和球形内插动画，到动画树和行为映射/树。不变的只有变化本身。\n如果读者从事过游戏行业，可能已经有接触这些数据类型。许多引擎确实做了会抽象这些相对基本类型。新的数据类型被大量使用时，就会作为核心类型集成到引擎里。通常，该类型被推广之前，会当作特殊情况处理，算是在可用性和性能之间的权衡。谁都不想在游戏开发中，为尚未充分理解的元素敞开大门。那些不愿或不能投入时间了解新功能最佳实践的人，也可能会吃到闭门羹。面向对象开发中的对象，并不会呈现数据本身，转而向了解更高级的工具的用户提供各种功能。\n除了代表数字资产的对象外，还有用于内部游戏逻辑的对象。每个游戏，都有一些对象仅仅为了推动游戏玩法而存在。可收集的卡牌游戏有很多纹理，但也有大量的规则、卡牌统计、玩家卡组、比赛记录，以及表示当前游戏状态的对象。这些都是为一个游戏完全定制的。游戏可能会有续作，但除非是换皮，不然游戏逻辑变化可能会相当大，因此需要不同的数据，意味着需要实现新的方法，原有的对象，实际上已经不再是前作中的那一个了。\n游戏数据很复杂。第一次数据布局几乎都是受最初设计的启发。一旦开发启动，布局就需要跟上游戏开发的变化。面向对象技术能够快速实现任何给定设计，在分别实现每个单一设计时非常快，但难以胜任从一种干净或优雅的数据模式迁移到下一个。当然也有一些小窍门，比如使用基于版本的资产管理程序，或结合更新系统并变换脚本的框架，但通常情况下，游戏开发者会同时改变工具链和引擎，完全重新导出所有资产，然后一次性提交到下一个版本。如果必须同时更新多个网站；或者资产量巨大；又或者试图为同时用于多个项目的引擎提供支持，而只有其中一个项目想要更新；那这个过程或许会相当痛苦。Django 框架是面向对象方法的一个例子，它能比较优雅地处理设计的迁移。但原因是，这些对象呈现的是数据模型的视图，而非数据本身。\n尝试建立出一个通用的游戏资产解决方案，到目前为止还没有一个成功案例。可能是因为所有的游戏都有很多微妙的不同，如果真的提供了一个通用的解决方案，那就不是游戏解决方案，只是一种新的语言。试图提供一个游戏可以使用的所有可能的对象类型，是不会找到解决方案的。但如果我们回到对游戏本身的思考，把它当作只是在一些数据上运行一组计算，那就有一个解决方案。截止到 2018 年 ，能得到的最接近的尝试是 FBX 格式，当然，它还一定程度上依赖当前的标准着色器语言。目前的解决方案似乎还有不太容易去除的包袱。由于需要通用，许多细节在以非对抗方式呈现数据的抽象过程中丢失了。\n框架(framework) #  无论是从底层性能的角度，还是从上层的游戏性与交互角度，游戏开发者们对于开发的理解都声名狼藉。或许由于高性能代码与内容层代码之间的差距越来越大了。面向对象技术能很好地覆盖上层需求，生产内容的程序员们对此十分满意。而性能专家们则致力于利用硬件做更多的事情，以至于内容创作者们常常会觉得在优化过程中没他们的份。可在游戏开发中，并不存在什么 \u0026ldquo;中间环节\u0026rdquo;，这可能也是为什么不采用大型计算机 9 的架构和性能技术。其次，游戏开发者通常不需要开发预期维护十几年的系统和应用10，因而不太可能在代码封装和保护上费心，甚至不会劳神维护文档。20 世纪 90 年代末，游戏开发行业首次蓬勃发展，较大的工作室开始涌现。但那时学术界和企业的软件工程实践却备受质疑，哪里有他们的身影，哪里就出现性能骤降，来自这些行业的雇员，几乎都没能留下印记。随着游戏机变得更像标准的微机，而标准微机在设计上更接近以前的大型机，那些标准专业软件工程实践的用处开始逐渐显现。现在，游戏的规模已经发展到与硬件相匹配，但行业已经不再关注那些非游戏开发实践的方向。作为一个行业，我们应该关注前人走过的路，而最接近的学术和专业开发技术似乎是以模拟和海量数据分析为基础的。我们要面临行业特有的挑战，比如在足够多的 AI 环境中遇到的高频高异构转化需求的问题，以及网络环境中的用户距离问题，又比如 MMO 中有基于位置的事件时，面临的带宽 $n^2$ 问题，因为每个人都在试图给其他人发消息。\n随着游戏世代更迭，开发者创作游戏的时间也在增加，这就是为什么项目管理和软件工程实践在大型游戏公司里已经标准化。曾几何时，游戏开发者被视做顶尖程序员，根据需求开发新的技术；但随着不太冒险的硬件出现（最知名的是第八代 x86 架构处理器），重心从巧妙的编码实践转变成为标准化的过程。也即是说，为了确保发布日期与营销日期吻合，游戏开发进度可以调整。高调的游戏开发中，总会有随机因素存在。总会有新的原因，几乎可以保证无法准确预测项目（或某个阶段）的时长。即便不通过面向数据设计来提升游戏的运行效率，也可以靠它让游戏开发的时间表变得规律。\n在游戏中引入新功能，困难之一在于数据布局。若要在现有框架内改变数据布局，就需要重新设计或扩展对象。即便没有新的数据，一个功能也可能从以前的独立系统变得突然需要密切交换信息。这种耦合往往会导致整个系统的混乱，进一步引发时间耦合和额外的边界情况。而这些情况或许只有百万分之一的复现几率。听起来好像问题也不大，但如果期望游戏能卖出几百万甚至几千万份，百万分之一的话，就是几个到几十个玩家。然后他们录下游戏的 bug 集锦传到网上，表示这游戏是垃圾，开发者都不好好干活：这么明显的 bug 都没有修复。这还不是最差的，如果这个问题是个规避内购的方法，而发现的人知道复现方式，随后这些步骤在网上大肆传播，或许足以在一个 MMO 游戏里产生一股破坏游戏内经济系统的资源流11。现在怎么办？若是买断制的游戏，如果已经卖出了几百万几千万份，大可不必在意。但若是现如今的免费游戏，五百万玩家可能只算个好开局，而差评会遏制增长。绕过内购会直接扼杀收入，经济崩坏则直接断送前程。\n早在 20 世纪 70 年代，大型计算机的开发人员们就有这样的担忧。由于他们的程序经常在与真实货币交易有关的数据上工作，因而软件必须以高标准构建。他们需要编写操作数据的业务逻辑，但必须确保数据是通过一套可证明的谨慎操作来更新的，进而保证其完整性，这一点非常重要。数据库技术的发展正是源于对处理和存储需求：对数据进行复杂分析，存储，更新，并保证其无论何时都有效。因此使用 ACID 测试来确保数据库的原子性 (atomicity)、一致性 (consistency)、隔离性 (isolation)、耐久性 (durability)。原子性测试确保所有事务只有\u0026quot;完成\u0026quot;或\u0026quot;不做\u0026quot;两种状态。如果一个数据库一次金融交易只更新一个账户，那可以说是非常差劲了。如果交易不是原子性的，就可能引发错误。一致性是为了确保在交易中应当发生的结果状态都会发生，也就是说，所有应触发的触发器都会被触发，即便是递归的也会，没有限制。若某个账户触发了欺诈检测需要被封禁，这一点就显得尤为重要。如果其中一个触发器失灵，数据库的使用者 (公司) 可能要因未能及时阻止账户而担责。隔离性是指确保所有发生的交易不会干扰任何其他交易行为。也就是说，如果两个交易出现要在相同的数据上工作，就必须排队，而非试图同时操作。尽管通常不会出什么问题，但它确实会引起并发问题。最后，耐久性。这是四要素中第二重要的，确保一个事务一旦完成，就要一直保持下去。在数据库术语中，耐久性意味着交易将确保以某种方式存储，即使服务器崩溃或停电时仍然存在。这一点对于联网的计算机来说是非常重要的，当服务器崩溃或连接中断时，需要知道哪些交易确实已经发生。\n现代在线游戏也不得不担心类似的非常重要的数据。对于非免费的可下载内容，消费者关心的是一致性。对于付费的可下载内容，用户会关心每一笔交易。为了提供数据库 ACID 测试需求的大部分功能，游戏开发者们开始回过头来研究数据库如何应对严格的要求，找到大量关于分阶段提交、幂等函数、并发等参考，从文献中学习如何为数据库设计表。\n结论和启示 #  前面已经谈到了面向数据设计是一种思考，布局数据，并决定架构的方式。面向数据设计时的许多决定由两个原则来驱动。在本章结束之前，让我们用一些可以直接应用的 tips 开始旅程吧。\n考虑一下称谓如何影响数据。考虑临近数据对数据本身可能的影响，会把它困在灵活性受限的模型中。第一个原则：数据不是问题域，要考虑以下问题：\n  是什么将数据联系起来，是概念还是隐藏的涵义\n  数据的布局是由单一角度的单一阐释定义的吗？\n  考虑如何重新解释这些数据，并按思路细分数据。\n  什么让数据独特而重要？\n  目标平台不是未知设备。了解数据，了解目标硬件。或者说，了解每个数据流的优先级，对每个使用者的重要程度。理解改进的成本和潜在收益。访问模式也很重要，如果在突发情况下访问数据，然后在整个应用周期内不再碰它们，就会影响到缓存命中。第二个原则：数据指类型、频率、数量、布局、概率，接下来考虑以下条目：\n 目标平台的最小内存单位是什么？ 12 读取数据后，又实际使用了多少？ 数据访问的频率是？1次/帧、或是1000次/帧？ 如何访问这些数据的？是随机的，还是突发的？ 数据一直在被修改，还是只读？需要修改所有数据吗？ 数据对谁重要，它的哪些方面重要？ 找出解决方案在带宽和延迟方面的质量限制。 有什么信息不在数据中？其中隐含的是什么？    Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP) http://www.gamesfromwithin.com/data-oriented-design\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 不过仍有一些限制，但并不与任何范式相互排斥，可能除了像 Prolog 这种逻辑编程语言。完全陈述性的 what, not how 的方法，看起来先天放弃考虑数据本身，以及它如何与机器互动。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 除非是 Lisp 程序员\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：有一种改进中，提供了指令存储器和 CPU 间的通路，来自指令存储器的字被当作只读数据。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 摘自 Peter Seibel 的 Coders at Work [@pseibel]。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：此处取函数式编程和关系模型的组合。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n D. L. Parnas: On the Criteria To Be Used in Decomposing Systems into Modules\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Manfred Broy, Ernst Denert: Software Pioneers: Contributions to Software Engineering\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：原文为 Big-Iron companies, 代指 60 到 70 年代开发大型计算机的公司\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 暴雪娱乐公司的人可能有话要说。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 在线漫画网站 The-Trenches 上有一则关于产品上线后发现问题并尝试修复它的漫画。http://www.trenchescomic.com/comic/post/apocalypse\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 2018年，大多数机器上，内存的最小单位是 64 字节对齐的块，称为缓存行 ( Cache Line)。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":2,"href":"/docs/translations/dod/02_%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"02 关系型数据库","section":"Dod","content":"关系型数据库 #  为了能更好地布局数据，我们可以将现有的结构变换为线性的。将面向数据的方法应用于现有的代码和数据布局时，问题通常来自于，会隐藏，封装数据的编程范式中固有的状态复杂度。这些范式隐藏了内部状态，所以通常不会触及到，但当需要修改数据布局时，就会遇到阻碍。并不是因为它们不够抽象，无法做到在不影响用户代码正确性的前提下改变底层结构，而是因为数据结构被连接起来并赋予意义。这类耦合会很难消除。\n在这一章中，我们将介绍关系模型、关系数据库技术、标准化的一些相关内容。它们是将高度复杂的数据结构和关系，变换为干净的、线性可存储数据条目集合的很好的例子。\n当然做面向数据设计也不需要把数据变换到数据库风格，但很多时候，在简单的数组上工作会方便许多。本章将通过示例，告诉读者如何从有复杂连接的对象网络迁移到更简单的数组推理关系模型。\n复杂状态 #  大多数软件中的数据，总有一些复杂或相互联系的特质。而在游戏开发中，为了保障玩家的沉浸感，需要在游戏内处理多种不同资源，在不同阶段实现听觉、视觉、甚至是触觉反馈。对于许多在面向对象设计中成长的程序员，把可用的结构类型减少到只有简单的数组似乎有些难以想象。从使用对象、类、模板、封装数据的方法，到一个只能访问线性容器的世界，是非常困难的。\nEdgar F. Codd 在 A Relational Model of Data for Large Shared Data Bank1 中提出了关系模型，用于处理同数据交互的代理的，当下以及未来的需求。一个为插入、更新、删除和查询操作构建数据的解决方案。他认为这一建议在保证能良好利用数据的同时，不再那么依赖对数据布局的深刻理解；同时还能降低引入内部不一致的概率。\n关系模型能够提供一个框架。在 Further Normalization of the Data Base Relational Model2中，Edgar F. Codd又提出了我们至今仍在用的标准化基本术语，能系统地将最为复杂的、相互关联的状态信息，减少到只有唯一独立元组的线性列表中。\n寻找计算框架 #  数据库能以结构化的方式存储高度复杂的数据，并提供一种语言来变换数据和生成报表。SQL 语言由 IBM 的 Donald D. Chamberlin 和 Raymond F. Boyce 于 20 世纪 70 年代发明，它在能够存储可计算的数据的同时，也可以按照关系模型的形式维护数据。可游戏里没有简单的可计算数据，有的只是类和对象。都是些枪、剑、汽车、宝石、日常活动、纹理、声音、成就。看起来，数据库技术在使用面向对象时不会有什么帮助。\n游戏中的数据关系可能非常复杂，乍一看似乎并不能整齐地放入数据库的行中。CD 收藏则很适合放进数据库，专辑可以整齐地排列在一个表中。但是，对于许多游戏对象来说却不适用。对于没有经验的人来说，很难用正确格式的表列来描述一个关卡文件。在正确的列项描述赛车游戏里的汽车可能也不简单。要为每个车轮设置一列吗？要为每个碰撞基元设置一列？还是只为碰撞网格设置一列？\n好吧，整齐划一的数据库思维或许并不适用于游戏。但其实，只是因为数据还未标准化。这里我们会逐步执行这些标准化步骤，用以说明如何从网络模型或层级模型变换为需要的形式。我们会从一个关卡文件开始，随后读者会发现这些有几十年历史的技术，是如何拓展视野，帮助我们了解游戏数据到底在做什么的。\n用不了多久，我们就会发现，数据库技术已经考虑过所有需要的操作了，只不过存储数据的方式将其掩藏了起来。任何数据结构都是在性能、可读性、可维护性、面向未来、可扩展性、可复用性之间做权衡。例如，常见的最灵活的数据库是文件系统。它有一个两列的表。一列是作为主键的文件路径，另一列是作为数据的字符串。这种简单的数据库简直就是完美的面向未来的系统。文件中可以存储任何东西。表越复杂，就越不具备未来性，也越不容易维护，但性能和可读性就越高。例如，文件没有自己的文档，但只需要数据库的模式(Schema)，就足以理解一个设计得足够好的数据库。这也是为什么，游戏甚至看起来都没有数据库。它们复杂到了，为了性能，已经忘了自己只是种数据变换。这种可变尺度的复杂度也影响了可扩展性，这就是为什么有人转向 NoSQL 数据库，以及文档存储这类数据归档。这些系统更像是一个文件系统，文件按名字访问，而且对结构的限制较少。同时也有利于横向扩展，如果不需要在不同机器上的多个表中保持数据一致，增加硬件就会更容易些。或许有一天，内存与最近的物理 CPU 紧密相连时，或内存芯片本身处理能力更强时，又或者桌面设备中运行 100 个 SoC 比一片 CPU 更高效时，从上层迁移到文档存储可能对应用程序会更好。但至少现在，对于本地硬件上的任务，还看不出这种处理模式究竟能带来什么好处。\n这里我们不打算深入研究如何利用大型数据基元最底层的细节，如网格、纹理、声音等。现在，只把这些原始资产（声音、纹理、顶点缓冲区等）看作是如同整数、浮点数、字符串和布尔值一样基元。这样做是因为关系模型要求在处理数据时要有原子性。什么是原子性，什么不是，至今仍在争论，还没有一个绝对的答案。但是对于开发供人消费的软件，颗粒度可以植根于从人类感知的角度考虑数据。现有的 API 根据使用方式，会以不同的方式呈现字符串。例如，人类可读的字符串（通常是 UTF8）和用于调试的 ASCII 字符串之间的区别。如果能意识到所有这些东西都是资源，把它们拆分成小块，就会失去原本具有辨识度的特征。那么把声音、纹理、网格添加到这上面就顺理成章了。例如，半个句子比整个句子的作用要小得多。而且由于拆分破坏了完整性，一个句子的片断显然不能在保持其意义的前提下，连同另一个不同句子的随机片断重复使用。即使是字幕也是沿着有意义的边界做分割的。正是这种对有意义的边界的需求，给出了我们对于面向人类的软件开发中，原子性的定义。为此，在处理数据、进行标准化处理时，尽量停留在名词的层面，即可命名的片段。一整首歌可以是一个原子，时钟的一次滴答声也可以是一个原子，一整页的文字是一个原子，玩家的账号也是一个原子。\n标准化数据 #   [图 2.1]: 图示初始化代码\n 现在要处理一个游戏的关卡文件。这个游戏中，玩家要寻找钥匙开锁，然后进入出口所在的房间。关卡文件被一连串代码调用，用来创建和配置不同的对象集。这些对象一起组成了一个可玩的关卡，并且彼此之间也存在一些关联。首先，我们假设它包含了一些房间（有或没有陷阱），有门（可以上锁）通向其他房间。还包含一些道具（可拾取物），有些可以用来开门，有些影响玩家的状态（如治疗药水和护甲）。所有房间和道具都有好看的的纹理网格。其中一个房间包含出口标记，还有一个房间是玩家的出生点。\n初始化的代码中 (代码[2.1])，加载了一些资源，创建了一些拾取原型，建立了一些房间，在房间内添加了一些实例，然后将这些都联系起来。这里，可以看到一个处理相互引用的事物的标准方案。在把房间连接起来之前先创建房间，这是先决条件。在 C++ 中创建实体时，我们会假设它们被绑定在内存中，而唯一有效方式是通过指针引用。但在分配之前，还无法知道它们在内存中的位置。而且填充数据前，也无法分配它们，因为分配和初始化是通过 new 的机制绑定在一起的。所以很难在对象存在之前描述它们之间的关系，因而需要将内容创建这一步拆分为初始化、连接两个阶段。\n// create rooms, pickups, and other things. Mesh msh_room = LoadMesh(\u0026#34;roommesh\u0026#34;); Mesh msh_roomstart = LoadMesh(\u0026#34;roommeshstart\u0026#34;); Mesh msh_roomtrapped = LoadMesh(\u0026#34;roommeshtrapped\u0026#34;); Mesh msh_key = LoadMesh(\u0026#34;keymesh\u0026#34;); Mesh msh_pot = LoadMesh(\u0026#34;potionmesh\u0026#34;); Mesh msh_arm = LoadMesh(\u0026#34;armourmesh\u0026#34;); // ... Texture tex_room = LoadTexture (\u0026#34;roomtexture\u0026#34;); Texture tex_roomstart = LoadTexture (\u0026#34;roomtexturestart\u0026#34;); Texture tex_roomtrapped = LoadTexture(\u0026#34;roomtexturetrapped\u0026#34;); Texture tex_key = LoadTexture(\u0026#34;keytexture\u0026#34;); Texture tex_pot = LoadTexture(\u0026#34;potiontexture\u0026#34;); Texture tex_arm = LoadTexture(\u0026#34;armourtexture\u0026#34;); Anim anim_keybob = LoadAnim(\u0026#34;keybobanim\u0026#34;); // ... PickupID k1 = CreatePickup(TYPE_KEY, msh_key, tex_key , TintColourCopper, anim_keybob); PickupID k2 = CreatePickup(TYPE_KEY, msh_key, tex_key , TintColourSilver, anim_keybob); PickupID k3 = CreatePickup(TYPE_KEY, msh_key, tex_key , TintColourGold, anim_keybob); PickupID p1 = CreatePickup(TYPE_POTION, msh_pot, tex_pot , TintColourGreen); PickupID p2 = CreatePickup(TYPE_POTION, msh_pot, tex_pot , TintColourPurple); PickupID a1 = CreatePickup(TYPE_ARMOUR, msh_arm, tex_arm); // ... Room r1 = CreateRoom(WorldPos(0, 0), msh_roomstart, tex_roomstart); Room r2 = CreateRoom(WorldPos(-20,0), msh_roomtrapped , tex_roomtrapped, HPDamage(10)); Room r3 = CreateRoom(WorldPos(-10, 20), msh_room, tex_room); Room r4 = CreateRoom(WorldPos(-30, 20), msh_room, tex_room); Room r5 = CreateRoom(WorldPos(20, 10), msh_roomtrapped , tex_roomtrapped, HPDamage(25)); // ... AddDoor(r1, r2); AddDoor(r1, r3, k1); SetRoomAsSpecial (r1, E_STARTINGROOM, WorldPos(1 ,1)); // AddPickup(r2, k1, WorldPos(-18,2)); AddDoor(r2, r1); AddDoor(r2, r4, k2); // ... AddPickup(r3, k2, WorldPos(-8,12)); AddPickup(r3, p1, WorldPos(-7,13)); AddPickup(r3, a1, WorldPos(-8,14)); AddDoor(r3, r1); AddDoor(r3, r2); AddDoor(r3, r5, k3); // ... AddDoor(r4, r2); AddPickup(r4, k3, WorldPos(-28, 14)); AddPickup(r4, p2, WorldPos(-27, 13)); // ... SetRoomAsSpecial (r5, E_EXITROOM);  [代码 2.1]: 初始化代码\n 要将这段初始化代码变成可用的数据库格式，或者说关系模型，我们要对其进行标准化处理。无论是何种类型的关系模型，引入新的元素都需要能放在表里。第一步，我们把所有的数据放到一个非常混乱的，但尽量完整的表。本例中，我们从创建对象的代码中获取数据的形式，然后将其放进表格。资源加载部分则可以直接转化为表格，如表 [2.1] 示。\n Meshes\n   MeshID MeshName     msh_rm \u0026quot;roommesh\u0026quot;   msh_rmstart \u0026quot;roommeshstart\u0026quot;   msh_rmtrap \u0026quot;roommeshtrapped\u0026quot;   msh_key \u0026quot;keymesh\u0026quot;   msh_pot \u0026quot;potionmesh\u0026quot;   msh_arm \u0026quot;armourmesh\u0026quot;      Textures\n   TextureID TextureName     tex_rm \u0026quot;roomtexture\u0026quot;   tex_rmstart \u0026quot;roomtexturestart\u0026quot;   tex_rmtrapped \u0026quot;roomtexturetrapped\u0026quot;   tex_key \u0026quot;keytexture\u0026quot;   tex_pot \u0026quot;potiontexture\u0026quot;   tex_arm \u0026quot;armourtexture\u0026quot;      Animations\n   AnimID AnimName     anim_keybob \u0026quot;keybobanim\u0026quot;      [表 2.1]: 根据资源名称创建的表格\n 有了这些数据，就可以创建 Pickups 了。我们把对 CreatePickup 的调用变换为表格(表 [2.2])。注意，有一个 pickup 没有指定色调，这里我们用 NULL 表示该行没有这项内容。动画部分同理。如果只有钥匙(key)有动画，那所有非钥匙的行都用 NULL。\n    PickupID MeshID TextureID PickupType ColourTint Anim     k1 msh_key tex_key KEY Copper anim_keybob   k2 msh_key tex_key KEY Silver anim_keybob   k3 msh_key tex_key KEY Gold anim_keybob   p1 msh_pot tex_pot POTION Green NULL   p2 msh_pot tex_pot POTION Purple NULL   a1 msh_arm tex_arm ARMOUR NULL NULL      [表 2.2]: 根据 CreatePickup 的调用创建表格\n 资源加载完成，并且 pickup的原型创建成功后，就可以为房间创建表了。要在实例没有的属性位置用 NULL，以确保有值可用。我们把对 CreateRoom、AddDoor 、SetRoomAsSpecial 和 AddPickup 的调用变换为 Rooms 表中的列。参见表 [2.3]，了解如何建立一个表示所有设置函数调用的表格。\n    RoomID MeshID TextureID WorldPos Pickups \u0026hellip;     r1 msh_rmstart tex_rmstart 0, 0 NULL \u0026hellip;   r2 msh_rmtrap tex_rmtrap -20,10 k1 \u0026hellip;   r3 msh_rm tex_rm -10,20 k2,p1,a1 \u0026hellip;   r4 msh_rm tex_rm -30,20 k3,p2 \u0026hellip;   r5 msh_rmtrap tex_rmtrap 20,10 NULL \u0026hellip;         \u0026hellip; Trap DoorsTo Locked IsStart IsEnd     \u0026hellip; NULL r2,r3 r3 with k1 true WorldPos(1,1) false   \u0026hellip; 10HP r1,r4 r4 with k2 false false   \u0026hellip; NULL r1,r2,r5 r5 with k3 false false   \u0026hellip; NULL r2 NULL false false   \u0026hellip; 25HP NULL NULL false true      [表 2.3]: 根据 CreateRoom 和其他调用创建的表格\n 根据 Setup 代码生成第一批表后，能看到表中出现了很多 NULL。如果实例没有某个元素，就都用 NULL 替换。还有有一些单元格包含多项数据。表中有多个门的房间就很难处理。如何知道它有哪些门呢？门是否锁住了？道具亦然。标准化的第一步，是将每个单元格中的元素数量减少到 1，并把为空的地方增加到 1。\n标准化 #  SQL 最初应用时，明确定义的标准化阶段只有三个。而现在已经增长到了六个。如果要尽可能利用数据库技术，最好了每一个阶段，至少要知道为什么。这些范式能让增进对数据依赖的理解，若加以利用，可以帮助重排数据布局。对于游戏结构，BCNF (Boyce-Codd normal form，稍后会做解释) 应该已经足以应付大部分情况。此外，读者可能还希望针对热/冷访问模式标准化数据，不过这个主题并不属于常规的数据库标准化文献。如果读者除本书涉及的内容之外仍旧感兴趣，可以阅读 William Kent 写的 A Simple Guide to Five Normal Forms in Relational Database Theory3 ，那句著名的 The key, the whole key, and nothing but the key. 就出自这里。\n如果一个表格属于第一范式，那每个单元格都包含一个且只有一个原子值。也就是说，值中没有数组，也没有 NULL。第一范式还要求每一行都是独立的。不过在展开讨论之前，我们先来了解一下什么是主键。\n主键(Primary key) #  所有的表都由行和列组成。数据库中，每一行都必须是唯一的。这个约束非常重要。在接下来了解数据标准化过程里，我们很快就知道，为什么行重复毫无意义。从编程的角度，我们先把表看作集合，那一整行就是集合的值。集合是无序的，数据库中的表也是无序的，很接近真实情况。数据库管理系统(DBMS)会依赖于隐式的行 ID：行与行之间总会有点区别。不过最好不要依赖这一点，只有在数据库的用途与设计相匹配时，才能更有效地工作。表都需要一个键。键常用于排序物理介质中的表，进而优化查询。因此，键得是唯一且小的。可以把键想象成 map 或字典中的 key。由于具备唯一性，每个表都会有一个隐式的键。表在同时用到所有列时，也能精确识别到每一行。因此，也可以使用整个行来作为主键的定义，或用于精确查询。如果该行是唯一的，那么主键也是唯一的。但一般而言，需要尽量避免使用整行作为主键。虽然有时也别无他选，之后我们会看到这样的例子。\n例如，在 Mesh 表中， meshID 和文件名的组合肯定是唯一的。但它是人为确保的：我们已经假定 meshID 是唯一的。即便是同一个 Mesh，从同一个文件加载，仍可能会有不同的meshID。纹理表中的 textureID 和文件名也是如此。从表 [2.2] 看出，我们可以根据类型、网格、纹理、色调、动画来唯一地确定每个可拾取物的原型。\n再来看 Rooms 表。可以看出，只用房间表中的 RoomID 以外的所有列的组合，就已经能唯一地定义房间了。从另一个角度想，如果某行有相同的数值组合，那实际上就是在描述同一个房间。因此，可以认为 RoomID 是作为其余数据的别名。我们已经把 RoomID 加到表里了，但它是怎么来的？首先，它来自于初始化代码。代码里有一个 RoomID，但创建阶段还用不到。后面用它来确定门通向哪里。换个角度，如果房间跟任何东西都没有逻辑关系，就不需要 RoomID 了，毕竟也用不到。\n主键必须是唯一的。以 RoomID 为例，它能唯一地描述一个房间，因此能作为主键。而且由于其本身不包含数据，只是作为句柄，因此也可以将它理解为一个别名。某些情况下，主键也是信息，我们以后也会遇到。\n顺便提一下，数据库中的一行也是键这一点，值得花时间去理解。如果数据库表是一个集合，插入一条记录，实际上只需要将特定的数据组合记录下来。一个数据库表就好像是巨大值域中的稀疏集合。在某些情况下，可能值的集合范围没多大，就可以很方便地用位集表示。举例来说，有一个表格，其中列出了 MMO 中当前在线的玩家。如果是服务器分区的 MMO，每个服务器上唯一的玩家数量可能有几千人的限制。这种情况下，将当前在线玩家存储为一个位集会更方便。如果在线玩家只有 10,000 个，并且无论何时，同时在线的玩家都只有 1000 个，那么位集的表示方法将占用 1.25kb 内存。而如果将玩家存储为用 short 的 ID，需要至少 2kb 的数据。而如果是 32bit，要保证在多个服务器上都是唯一的，就需要 4kb。这种情况的另一个好处是数据查询的效率。快速访问表中的 ID 需要先对其进行排序,其最佳情况是 $O(logn)$。而位集则是 $O(1)$。\n回到资源表，有个细节需要提及：即使有两个不同的 MeshID 指向同一个文件，大多数程序员也会凭直觉理解，一个 MeshID 基本不会指向两个不同的 Mesh 文件。基于这种不对称性，可以推断，看起来更有可能是唯一的那一列，就是可以作为主键的那一列。在这里我们选择 MeshID，因为其更易操作，而且基本不会有多个含义和用途。但是，我们也完全可以用文件名替代它。\n如果把 TextureID、PickupID、RoomID作为这些表的主键，就可以考虑使用第一范式了。我们用 t1,m2,r3 等来作为类型安全的 ID 值。实际上也可以直接使用整型数。这里主要是为了保证可读性，同时表明，每种类型都有该类型唯一的 ID，也与其他类型有相同 ID。例如，房间有整数 ID，值为 0 (译注：r0)，但纹理也有（译注：t0）。拥有跨类型唯一 ID 的好处是方便调试，比如只用高位的几 bit。如果不是每个类型都拥有上百万个实体，那就有足够的位来处理上千个不同的类。\n第一范式 (1st Normal Form) #  第一范式可以理解为，消除元素的稀疏性。首先需要确保表中没有空指针，且元素中没有数组。可以通过将重复内容及可选项转移到其他表中来实现。任何有 NULL 的地方，表示该列为可选项。 我们先来处理 Pickups 表，它有可选元素： ColorTint 和Animation。现在创建两个新表：PickupTint 和 PickupAnim，这里直接与 Pickups 使用相同的主键。表 [2.4] 变换后的结果，可以看出，现在这里已经没有 NULL 了。\n Pickups\n   PickupID MeshID TextureID PickupType     k1 msh_key tex_key KEY   k2 msh_key tex_key KEY   k3 msh_key tex_key KEY   p1 msh_mpot tex_pot POTION   p2 msh_mpot tex_pot POTION   a1 msh_marm tex_arm ARMOUR      PickupTints\n   PickupID ColourTint     k1 Copper   k2 Silver   k3 Gold   p1 Green   p2 Purple      PickupAnims\n   PickupID Anim     k1 anim_keybob   k2 anim_keybob   k3 anim_keybob      [表 2.4]: 1NF的 Pickups\n 可能你已经发现了两点不同：其一，标准化创建了更多的表，但每个表的列更少；其二，重要的事物才有行。前者令人担忧，它表示会占用更多内存。而后者就有意思了：在面向对象方法中，允许对象有可选属性；也就意味着在使用前需要判断其是否为空。但如果像现在这样存储数据，我们就知道所有的属性都不为空。不需要检查空值，代码可以更简洁。基于此，在尝试推理整个系统时，要考虑的状态也更少。\n再来看 Rooms 表。这个表中有不少包含多个原子值的元素。由于不符合第一范式的规则，我们要先把它们从表里删去。首先删除对 Pickups 的引用，因为它的元素数量不定。然后是 Trap，尽管一个房间最多只有一个陷阱，但也可能没有。最后是 Doors，虽然每个房间都有门，但往往不止一个。这里重申一下规则，在每一个行与列的交汇处都有且只有一个条目。表 [2.5] 展示了如何只保留与 RoomID 有一对一关系的列。\n    RoomID MeshID TextureID WorldPos IsStart IsExit     r1 msh_rmstart tex_rmstart 0,0 true false   r2 msh_rmtrap tex_rmtrap -20,0 false false   r3 msh_rm tex_rm -10,20 false false   r4 msh_rm tex_rm -30,20 false false   r5 msh_rmtrap tex_rmtrap 20,10 false true      [表 2.5]: 1NF 的 Rooms\n 现在我们为 Pickups、Doors、Traps 制作新的表格。在表 [2.6] 中，可以看到为了满足第一范式而做出的诸多选择。我们把类似数组的元素拆分为独立的行。注意，这里用了多行来指定同一房间里的多个 Pickups。还有，门现在需要两个表了。第一个表用于确定门的位置和通向。第二个表看着类似，但只包括了被锁住的那些。实际情况是：需要通过 LockedDoors 表中的主键识别哪些门是锁的。再来看 Doors 表，显然这两列都不能作为主键：两列值都有重复。但这里数值组合是唯一的，因而主键是由两列组成的。在 LockedDoors 表中，FromRoom 和 ToRoom 均可用于查询 Doors 表中的内容。这种被称为外键(Foreign Key)，表示这些列能够直接映射到另一个表的主键。在这里，主键是由两列组成的，所以 LockedDoors 表有一个大外键，并且在外表(Foreign Table)中有关于该条目的额外细节。\n PickupInstances\n   RoomID PickupID     r2 k1   r3 k2   r3 a1   r3 p1   r4 k3   r4 p2      Doors\n   FromRoom ToRoom     r1 r2   r1 r3   r2 r1   r2 r4   r3 r1   r3 r2   r3 r5   r4 r2      LockedDoors\n   FromRoom ToRoom LockedWith     r1 r3 k1   r2 r4 k2   r3 r5 k3      Traps\n   RoomID Trapped     r2 10hp   r5 25hp      [表 2.6]: 应用1NF 的 Rooms 补充表格\n 随关卡文件变得复杂，空条目和数组的量也会随之增加。因而像这样布局数据，在大型项目中的空间占用反而会比较少。同时还能够在避免重新评估原始对象的前提下，添加新的功能。比如要添加怪物，通常情况下，不仅要为怪物添加一个新对象，还要把它们添加到房间对象中。而在新的格式下，要做的就只是添加一个新的表格，如表 [2.7] 所示。\n于是，在没有触及任何关卡原始数据的情况下，我们就已经知道怪物的信息及其刷新点了。\n Monsters\n   MonsterID Attack HitPoints StartRoom     M1 2 5 r3   M2 2 5 r4      [表 2.7]: 添加怪物\n 第二范式 (2nd Normal Form) #  第二范式用于分离那些只依赖部分主键的列。或许会有需要复合主键的表，但其行中的某些属性，只依赖于该复合主键的一部分。例如，表 [2.8] 中由品质和类型定义的武器，可以看到主键必须是复合的，该表中没有元素唯一的列。\n Weapons\n   WeaponType WeaponQuality WeaponDamage WeaponDamageType     Sword Rusty 2d4 Slashing   Sword Average 2d6 Slashing   Sword Masterwork 2d8 Slashing   Lance Average 2d6 Piercing   Lance Masterwork 3d6 Piercing   Hammer Rusty 2d4 Crushing   Hammer Average 2d4+4 Crushing      [表 2.8]: 1NF 的武器\n 不难看出，该表的主键应该是WeaponType 与 WeaponQuality 的复合键。根据当前武器查询伤害和伤害类型，非常正常的操作。再仔细看，伤害类型并不依赖于 WeaponQuality，而只依赖于 WeaponType。这就是上文中，取决于部分键的意思。尽管每个武器的定义都符合第一范式，但其伤害类型对主键的依赖性太小，因而其不满足第二范式。我们在表 [2.9] 中将该表分离出来，删除了只依赖 WeaponType 的那一列。如果发现有一种武器的伤害类型还会依赖于其品质，那就把这个表再复原回去。比如武器：严重损坏的晨星4，不再造成穿刺伤害，现在造成打击伤害。\n Weapons\n   WeaponType WeaponQuality WeaponDamage     Sword Rusty 2d4   Sword Average 2d6   Sword Masterwork 2d8   Lance Average 2d6   Lance Masterwork 3d6   Hammer Rusty 2d4   Hammer Average 2d4+4      WeaponDamageTypes\n   WeaponType WeaponDamageType     Sword Slashing   Lance Piercing   Hammer Crushing      [表 2.9]: 2NF 的武器\n 考虑第二范式的关卡数据的时，可以留心一些转移回第一范式的捷径。首先，不一定要使用 PickupID，可以通过 PickupType和 TintColour 来引用可拾取物。不过实际操作时会比较麻烦，而且因为护甲没有色调，反而会引入空项。表 [2.10] 就是这种情况，其中因为引入了 PickupID, 使得其与房间之间的关系变得尤为复杂。如果没有 PickupID，要把可拾取物放进房间，就需要有两个表。一张是有色调的可拾取物，另一张是没有的。虽然没那么蠢，但这种特殊条件下，好像也没那么纯粹。但是这种情况迟早会有，也算是正确选择了。\n Weapons\n   MeshID TextureID PickupType ColourTint     mkey tkey KEY Copper   mkey tkey KEY Silver   mkey tkey KEY Gold   mpot tpot POTION Green   mpot tpot POTION Purple   marm tarm ARMOUR NULL      使用 1NF 标准化：\n 1NF 的 Pickups\n   PickupType MeshID TextureID     KEY mkey tkey   POTION mpot tpot   ARMOUR marm tarm      1NF 的 TintedPickups\n   PickupType ColourTint     KEY Copper   KEY Silver   KEY Gold   POTION Green   POTION Purple       [表 2.10]: 0NF 和 1NF 的 Pickups\n 再回来看原先的 Pickup 表。已知 PickupID 是 PickupType 和 ColourTint 组合的别名，就可以应用之前变换到 1NF 时的方法。即，将 MeshID 和TextureID 移到他们自己的表中，用对 PickupType 的依赖替换掉原先 PickupType 与 ColourTint 的复合键。\n表 [2.11] 中，资源现在依赖于其完整的复合键了。\n Pickups\n   PickupID PickupType     k1 KEY   k2 KEY   k3 KEY   p1 POTION   p2 POTION   a1 ARMOUR      PickupTints\n   PickupID ColourTint     k1 Copper   k2 Silver   k3 Gold   p1 Green   p2 Purple      PickupAssets\n   PickupType MeshID TextureID     KEY msh_key tex_key   POTION msh_pot tex_pot   ARMOUR msh_arm tex_arm      PickupAnims\n   PickupType AnimID     KEY key_bob      [表 2.11]:2NF 的 Pickups\n 现在还无法对房间表做同样的标准化处理。表中的 RoomID 可能是整个行的别名，也可能只是 WorldPos 的别名。但两种情况下，MeshID、 TextureID、 IsStart 的值之间都有关联。关键是，它还依赖外表中的条目。这样看来，MeshID 和 TextureID 都直接依赖于表中的 RoomID。\n第三范式 (3rd Normal Form) #  在进一步标准化之前，得先清除传递式的依赖。这里指的是表中的任何一列都只跟主键有依赖。这里快速过一下当前表格，可以发现，所有资源引用都依赖于 MeshID 和 TextureID。每个有 MeshID 的东西都有相应的 TextureID。所以，可以从所有表中剥离其中一个，生成一个新表用作查询。这里随机用了TextureID作为主键，并将网格和纹理信息填进表里(表 [2.12])。\n WeaponDamageTypes\n   TextureID TextureName MeshName     tex_room \u0026ldquo;roomtexture\u0026rdquo; \u0026ldquo;roommesh\u0026rdquo;   tex_roomstart \u0026ldquo;roomtexturestart\u0026rdquo; \u0026ldquo;roommeshstart\u0026rdquo;   tex_roomtrap \u0026ldquo;roomtexturetrapped\u0026rdquo; \u0026ldquo;roommeshtrapped\u0026rdquo;   tex_key \u0026ldquo;keytexture\u0026rdquo; \u0026ldquo;keymesh\u0026rdquo;   tex_pot \u0026ldquo;potiontexture\u0026rdquo; \u0026ldquo;potionmesh\u0026rdquo;   tex_arm \u0026ldquo;armourtexture\u0026rdquo; \u0026ldquo;armourmesh\u0026rdquo;      [表 2.12]: 3NF 的资源\n Boyce-Codd范式(Boyce-Codd Normal Form) #  一个房间用到的资源跟是否有陷阱，或是否是起始点有关。这种属于功能上的依赖，而非直接依赖。所以我们引入一个新列来描述这些内容，同时需要有中间数据用于间接查询，并促成房间和资源间的解耦。房间里可以有陷阱，也能作为起始房间，而与房间产生关联的资源取决于这两个属性，而非房间本身。这就是为什么 Boyce-Codd 范式(或 BCNF)，能作为功能依赖的标准化阶段。\n Rooms\n   RoomID WorldPos IsStart IsExit     r1 0,0 true false   r2 -20,10 false false   r3 -10,20 false false   r4 -30,20 false false   r5 20,10 false true      Rooms\n   IsStart HasTrap TextureID     true false tex_rmstart   false false tex_rm   false true tex_rmtrap      [表 2.13]: BCNF 后的 Rooms 表\n 域键和领域知识 #  域键范式(Domain Key Normal Form)一般作为最后的标准化步骤。但如果想开发高效的数据结构，最好尽早准备并研习这部分。领域知识(Domain Knowledge)这个术语可能对程序员而言更熟悉些，它更直接，能够应用于键和表之外。领域知识是指数据依赖于其他数据，但只是给定其所在领域的信息。简单如对某个事物的通俗认知，如知道某个摄氏或华氏度是热的；或某个国际单位(SI)是否与人造概念有关，比如 100 (米/秒)很快。\n领域知识能够帮助发现问题：比如将人类的价值判断放入断言。试想一个捕捉物理系统爆炸5的断言。加速度的有效范围是什么？将其乘以 10，在事情失控之前，就有了一个检查。\n一些应用会使用模糊的倒计时，替代传统的易误判的单位。如几分钟后或喝杯咖啡的时间。但领域知识不仅仅能够呈现人对数据的解释。例如，声速、光速、特定道路网上的限速和平均速度、心理声学特性、水的沸点，以及人对特定视觉输入的反应时间。这些事实在某种意义上有其用处。但只在程序员将其转化为程序性的，或作为特定实例的属性专门添加进来时，才可用。\n再来看关卡数据，可以根据基本名来推断完整的文件名。纹理和网格名称使用相同格式。所以避免存储完整的文件名，便是一个领域知识的范式。\n AssetLookupTable\n   AssetID StubbedName     ast_room \u0026ldquo;room%s\u0026rdquo;   ast_roomstart \u0026ldquo;room%sstart\u0026rdquo;   ast_roomtrap \u0026ldquo;room%strapped\u0026rdquo;   ast_key \u0026ldquo;key%s\u0026rdquo;   ast_pot \u0026ldquo;potion%s\u0026rdquo;   ast_arm \u0026ldquo;armour%s\u0026rdquo;      [表 2.14]: BCNF 后的资源表\n 领域知识能让我们剔除一些不必要的数据。编译器的工作是分析代码输出（抽象语法树），为自己提供数据，在此基础上推断并使用其领域知识，了解哪些操作可以被省略、重排、变换，以产生更快或更低占用的汇编。而我们人的工作，是为编译器不知道的信息做同样的处理，例如，战斗中的人能够听到另一个房间里的硬币掉落的几率是多少？\n领域知识催生了 JPEG 和 MP3 等格式。思考哪些是可能的，哪些能被感知，哪些会被用户行为影响，都能减少应用程序的工作量，并降低其复杂度。当玩家在有物理的游戏中跳跃时，也不必因为反作用力把世界向下移动几分之一纳米吧。\n反思 #  对数据进行标准化处理时，我们看到的是一种按依赖关系分割数据的趋势。许多第三方引擎和 API 里，都能看到与这些标准化的影子。参与这些引擎设计和迭代的人，不可能拿着数据去应用数据库标准化技术。但有时对象和及其组成之间，可能分离的很明显，不需要标准的技术就能实现一些积极的结构变化。\n一些游戏中，实体对象不单单是可以是任何东西的对象，而是游戏中实体类型的特定子集。例如，游戏中，可能有一个玩家角色的类，有不同类型的敌人角色的类，还有车辆类。玩家可能拥有不同于其他实体的属性，例如，无 AI 控制，玩家可控，可回复生命，有弹药等。这种面向对象的方法，在对象的类和实例之间划了一条线。虽然对用户来说不可见，但它会干扰开发者。同时也具备侵入性，类之间接触时，需要适应彼此。而如果几个类在不同的层次结构中，还必须通过抽象层传递信息。弥合这些差距所需的代码量或许不多，但终归只会让系统变得更加复杂。\n实践中，常常是：实现对多个类执行操作的模板花费的时间，远多于将类向着离散化方向重构。就如同要考虑，是否有针对所有大于零的对象执行操作的可能，基本上属于浪费时间。而重构组件需要花费努力，通常与创建有效的模板操作不相上下。\n如果没有类来定义边界，基于表的方法，将对数据的操作放到了同一水平线上。通过标准化关卡数据，我们已经知道，数据需要随同设计一起改变，并且尽量不要使状态变得不一致。我们常常在毫无必要的时候，把事情变得复杂，而能带我们走得更远的，只有实践和经验。\n操作 #  在面向对象的情况下，可以直接通过调用方法对其执行操作。那在基于表的方法中，我们要如何打开门锁呢？总归是要有插入、删除、更新。在Edgar F. Codd 的文章中明确规定了这些行为。也即是操作关系模型的全部。\n真正的数据库中，要找到需加载的网格，或检查某扇门是否上锁，通常需要表与表之间相互连接。数据库也会通过改变操作的顺序来优化连接，使预期开销尽可能小。但我们能做得更好。因为查看和请求表内数据的方式完全控制在我们手中。要检查一扇门是否上锁，这里不需要连接表，可以直接查到上锁的门的表。另外，虽然数据有跟数据库一样的布局，但不代表就必须得用查询语言访问。\n涉及到改变状态的操作时，最好尽量模仿 DBMS 中常见的那种操作，意外的操作会引入复杂度。例如，假设分别有一份打开的门的表，和关闭的门的表。在表之间相互移动门显然是种浪费。所以可以考虑将其改为单表，所有关闭的门在一端，打开的门在另一端。将两个表合并成一个，并给数组设置截止点，隐式地定义 isClosed 属性。比如在代码[2.2] 中，该表在某种程度上是有序的。这种内存优化也有其代价。在表中引入顺序，使得难以并行操作整个表。所以，这些改变就要多加留意，警惕其引入的复杂度，并整理好文档。\ntypedef std::pair \u0026lt;int ,int\u0026gt; Door; typedef std::vector\u0026lt;Door\u0026gt; DoorVector; DoorVector gDoors; int gDoors_firstClosedDoor = 0; AddClosedDoor ( Door d ) { gDoors.push_back(); } AddOpenDoor (Door d) { gDoors.insert(gDoors.begin() + gDoors_firstClosedDoor, d); gDoors_firstClosedDoor += 1; }  [代码 2.2]: setup 代码\n 开一扇门锁可以被当做是一次删除操作。一扇门被锁住，是因为在 LockedDoors 表中有一个条目，对应玩家可能需要交互的门。如果门和玩家持有的钥匙匹配，那开锁就是一次\u0026quot;删除\u0026quot;。\n玩家的背包则是一个只有 PickupIDs 的表。这就是之前提到的“主键也是数据”。如果玩家进入一个房间，并拾取一个道具，那么将删除与该房间相对应的条目，而背包里会更新刚才的PickupID。\n数据库里有一个概念，触发器：对一个表的操作会引发一系列额外操作。捡起一把钥匙时，我们希望在放入背包时有一个触发器，将新的PickupID 与 LockedDoors 表连接起来。找到匹配的行，并删除它，门就解锁了。\n总结 #  可以看出，数据库能胜任存储任何高度复杂的数据结构；即便是高度相关、设计快速变化的游戏数据，也不在话下。\n游戏中有很多状态，而关系模型能提供一个强大的结构，可以保存静态、动态的信息。在这种结构下，实践中，相似的问题就有相似的方案，而相似的方案就会有相似的处理。使用时，数据布局更易推断，因而算法和技术也更易复用。\n如果想找一种方法，能将相关联的复杂对象，变换为更简单扁平的内存布局。那可能很难比按照标准化形式来变换做得更好。\n以数据库的形式存储数据还有一些比较有用的\u0026quot;福利\u0026quot;。它允许旧的可执行文件在新数据上运行，新的可执行文件也更容易在旧数据上运行。试想，如团队中有人分别使用新旧版本一起工作时，就会很有用。可以看到，有时添加新功能只需添加一个新表，或者在现有表中新加一列。此时，如果是用的数据库式的存储，这次修改就是非侵入性的；但如果要在类中添加一个新成员，恐怕就会是一次重大改变。\n流处理 #  现在我们知道，游戏数据和运行时，都能用类似数据库的方式来实现。并且显然，游戏数据可以实现为流。如果长期存储是数据库，运行时的数据格式与磁盘上的一样，那么，我们能从中得到什么好处？数据库可以看作行或列的集合，也可以看作表的集合。此处的集合，指的是属性所有可能的排列组合。\n对于大多数应用，用比特集来表示一个表会很浪费，大小很快就会超出任何硬件所能承受的范围。但从处理角度，这一点还是值得注意的。处理一个集合，将其转化为另一个，可以看作是遍历该集合并输出新集合。但集合有意思的点就在于，它是无序的。无序的表很容易并行处理。任何时候，只要有机会利用这种明显的并行性，就都能获得巨大好处；而由于面向对象方法的数据布局原因，我们通常无法接近这一点。\n从另一个角度看，多年来，显卡供应商也一直朝着这个方向努力。我们现在也要以这种方式思考游戏逻辑。只要尽可能利用流处理或集合处理，并尽量减少随机存取，就能快速处理大量数据。这种情况下，流处理意味着，在处理数据时不写入进程外部的变量。意味着避免使用类似全局累加器这些，同时避免访问未被设置为进程输入的全局内存。这样就能够确保进程、变换能够并行。\n想象为显卡准备图元渲染的场景：首先设置了一些常量，如变换矩阵、纹理绑定、光照值、着色器。运行着色器时，每个顶点和像素的可能都有自己的便签式存储(scratchpad)应对局部变量，但它们绝不会写入全局变量，也不会引用全局的便签式存储。通用 GPU 代码中的共享内存概念，如 CUDA 和 OpenCL 中使用的管理型缓存。没有哪一种 GPGPU 技术提供对全局内存的访问。因而它们能保持明确的领域分离，并持续保证，任意内核都能在其沙盒共享内存之外运行时，不会产生副作用。强制使用这种没有副作用的方法，就能确保这明显的并行性，因为操作顺序已经确定是不相关的。如果允许着色器写入全局，就会有锁，或者它会变成一个固有的串行操作。两种情况对于显卡这种的核心数目巨大的设备，都不是好事。所以一直以来，这都是从设计层面考量的，主动的限制。如果让共享内存参与进来，就会在整个过程中引入潜在的锁，因此需要明确地只在写计算着色器时使用。\n经过一些列调整，没有了全局数据 6，我们可以清晰地看到一条高度并行化处理的路线。现在也更容易思考、检查、调试、扩展、乃至中断以适应新设计。只要能保证无序，就可以自由执行那些易出问题的测试。\n为什么数据库技术很重要? #  正如本章开头提到，关系模型目前非常适用于非稀疏数据布局的开发，一旦设计好了表，就可以操作，不太需要复杂的状态管理。然而，变化才是常态。现在还常用的，忽然可能就老办法，对于大型系统，关系模型也已不再提供所有需要的功能。\n随着处理更大工作量的 NoSQL 方案出现，以及大公司在分布式计算方向的投入，处理巨大的数据集在技术方面已经取得了进展。在保持数据库的实时、分布式、一致性（在容许范围内）方面，也有了进展。现在的数据库经常包括 NULL 条目，甚至于 NULL 条目远远多于数值，这些高度稀疏的数据库，需要一个不同的解决方案。许多大型计算和进程，现在都通过一种叫 map-reduce 的技术运行。分布式工作负载已经变得足够普遍，以至于人们不得不提醒，做些加法运算不一定需要用到集群。\n过去十年，已经很清楚的是，大多数证明有用的高级数据处理技术，都是类似于这种组合：函数式的高级算法应用于硬件感知的数据操作层。随着 PC 中的硬件变得越来越像互联网，这些技术将开始在个人硬件上占据主导地位，无论是个人电脑、手机、还是下一代的什么。面向数据设计的灵感来自于这样一种认知，即硬件已经发展到这种程度：过去用来对抗 CPU 与硬盘之间延迟的技术，现在也适用于内存。将来，如果能利用大量孤立的不可靠的计算单元来提高处理能力，那么我们在这个时代开发的服务器上的分布计算技术，可能会适用于下一个时代的桌面系统。\n  A Relational Model of Data for Large Shared Data Banks, E. F. Codd, https://doi.org/10.1145/362384.362685\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Further Normalization of the Data Base Relational Model, E. F. Codd, 1917\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n kwilliam A Simple Guide to Five Normal Forms in Relational Database Theory, ↩Kent, William, 1983\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：晨星即钉头锤，或因其外观而得名。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：原文 blow-up，但不确定此处是否有专门的术语。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：globals/global scratchpads\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":3,"href":"/docs/translations/dod/03_%E5%AD%98%E5%9C%A8%E6%80%A7%E5%A4%84%E7%90%86/","title":"03 存在性处理","section":"Dod","content":"存在性处理 #  如果苹果已经售罄，还要砍价吗？\n存在性处理旨在消除：\u0026ldquo;是否要处理数据\u0026rdquo; 这一类冗余查询。大多数软件中，为了确保对象在工作开始前有效，会先检查其是否为空。那如果能始终保证指针不为空呢？如果可以确保其始终有效，并且一定会处理呢？\n本章中，我们会展示一种可以用于面向数据的，运行时多态技术。当然，它不是唯一的面向数据设计友好型的运行时多态。但却是作者找到的第一个解决方案，并且很适合其他游戏开发技术，如：组件和计算着色器。\n复杂度 #  学习软件工程时，我们可能会看到，其中有提到过循环复杂度 (或条件复杂度)。这是一个用数字表示，用于分析大型软件项目程序复杂度的指标。循环复杂度只涉及到流程控制。在这里，该公式表示为为 $(1 + 被分析系统中存在的条件数)$。因此对于任何系统，都从 $1$ 开始。对于每个 if, while, for, do-while 都 $+1$。另外 switch 语句中除 default 外，每个 case 也要 $+1$。\n现在，仔细考虑虚函数调用的原理，即在函数指针表中查找，并进入类方法的分支。显然，虚函数调用实际同 switch 语句一样复杂。虚函数调用中，想要统计流程控制的数目会比较困难。要知道复杂度度，就必须知道满足的方法数目。因此必须计算对父类虚函数的 override 数目。如果方法是纯虚函数，那复杂度可以 $-1$。然而，有时看不到全部的运行时代码，如动态加载库，潜在的代码分支数目就会增加一个未知量。允许接入第三方库的系统，有必要接受这种不可见或模糊的复杂度，但需要一定程度的信任，这表示任意环节都没法彻底测试。\n这种复杂度通常称为控制流复杂度。软件中还有一种固有的复杂度，就是状态复杂度。在 Out of the Tar Pit1 一文中有结论：最能提升软件复杂度的是状态。这篇论文提出了一个方案，以图最大限度减少所谓的意外状态，即：不直接解决问题，但在软件完成工作需要的状态。该方案还尝试废弃掉那些仅仅为了支持某种编程风格而引入的状态。\n必要的控制是：实现设计时，一个功能必须在某些条件满足时才发生。例如：按下跳跃键时跳跃；存档数据变脏或计时器结束时，在检查点自动保存。\n意外的控制，从使用者的角度看，对于程序是非必要的，但可能也是关乎程序能否工作的基础功能。这种控制的复杂度一般分为两种形式。第一种是结构性的，如支持某种编程范式、提供性能改进、驱动一种算法等。第二种，则是防御性编程或用于辅助开发者的，如引用计数、垃圾回收。这些技术在使用时会去确定数据是否存在，也会检查边界，因而也会增加复杂度。实践中，可以在使用容器和其他结构时看到它们，控制流会以边界检查确保数据没有以超出范围。垃圾回收也会增加复杂度。许多语言中，都难以确保回收会何时，怎样触发。也就意味很难推断对象的生命周期。使用这些语言时，人们倾向于在开发初期忽略内存分配，因此在临近交付时，可能很难修复内存泄漏。非托管语言的垃圾回收处理起来要容易些，因为引用计数更易查询，但也是因为非托管语言通常预先分配的频率较低。\n调试 #  在高复杂度的程序中，会遇到哪些问题？分析系统的复杂度有助于了解其测试难度，反过来也有助于了解其调试难度。有些问题可以归类为处于意外状态，但也无法更进一步了。其他的可以归类为进入坏的状态：由于对无效数据做出反应而表现出意外的行为。不过，还有一些问题可以归类为性能问题，而非正确性问题。某种程度上，这些问题虽然被大量的学术文献忽视，但在实践中代价很高，而且通常来自于复杂的状态依赖关系。\n例如，由缓存等优化技术引入的复杂度，是状态复杂度问题。CPU 的缓存处于一种不知道的状态，且在工作中没能预期到，就会导致性能不佳或不稳定。\n许多时候，调试中的困难来自于：没有完全了解所有的流程控制点，假设已经采取了一条措施，而实际上并没有。程序按我们的要求去做，而非遵照我们的意思，它们就会进入一个预料外状态。\n使用虚拟调用的运行时多态，会大大增加这种情况发生的可能性。因为不确定我们是否已经完全知道代码所有不同的分支，除非使用日志记录代码，或者用调试器来查看它在运行时的走向。\n为什么要用 if #  真实的游戏开发案例中，显式的流程控制语句常常属于非必要集。实行防御性编程的地方，许多流程控制语句只是为了防止崩溃。阻止越界访问，保护为 NULL 的指针，防御其他会使程序终止的特殊情况。好在，GitHub 上有很多高质量的 C++ 源码，与这种趋势背道而驰。它们更倾向于使用引用类型，或尽可能使用值类型。游戏开发中，另一种常见的流控制是循环。虽然这种情况很多，但大多数编译器都能识别它们，并做出很好的优化，而且在去除不必要的条件检查方面做得很好。最后一种不重要但常见的流程控制来自多态调用，它对于实现一些游戏逻辑很有用，但主要是为了满足面向对象编写游戏的方法中，部分执行的 \u0026ldquo;更少代码，更多用途\u0026rdquo; 开发模式。\n本质上，游戏设计中的流控制，不太会在性能分析文件中以分支控制出现，因为所有支持性代码会运行得更频繁。因此可能会忽视每个条件对软件性能的影响。用条件实现 AI，处理角色移动，决定何时加载关卡的代码，会在充满循环和树状遍历的系统中调用；或对访问中的数组边界检查，返回数据，产生布尔值，最终驱动 if 落入其中一个分支。也就是说，当代码库其他部分都很慢时，就很难验证为其中一项任务编写快速的代码。很难讲又增加了哪些额外成本。\n如果觉得值得考虑一下清除控制流，就得先了解哪些控制流操作是可以清除的。如果从防御性编程开始着手，可以用数组的集合来表示工作数据集。这样就可以保证数据中没有 NULL。仅这一步，就可以清除许多流程控制语句。这样并不会摆脱循环，但只要是运行纯函数式变换的数据的循环，就不必担心副作用，并且反而会更容易推理。\n虚拟调用中固有的流程控制也可以避免。事实上，有许多程序是以非面向对象风格编写的。没有虚拟，还可以依赖 switch 语句。没有那些，还可以依赖函数指针表。再不济，还能用一连串 if。有许多方式能实现运行时多态。可以认为，如果没有显式类型，就不需要对其进行切换。所以如果能根除面向对象的方法来解决问题，那些流程控制语句也会完全消失。\n当涉及到游戏逻辑中的控制流时，就会发现，想要根除他没那么容易。这倒也没那么可怕，游戏开发中，游戏逻辑是我们能看到的最接近本源的复杂度。\n减少条件语句，从而减少这种规模的循环复杂度，能带来不容忽视的好处，但也是有代价的。之所以能够避免检查 NULL，是因为数据格式根本不允许出现 NULL。我们很快会证明，这种不灵活性其实是种优势，但需要一种新的方法来处理实体。\n以前，游戏中会有一片区域的对象实例，我们会查询它是否有去其他区域的出口；而现在，只需要查看一个只包含区域间链接的结构，并通过我们所在的区域做过滤。这种所有权的颠倒在调试中很有优势，但是当有时只想找出哪些出口可以离开一个区域时，就显得很落后。\n如果读者用过购物清单或待办清单，肯定能理解，如果有个明确的要完成的清单时，效率会高很多。制定清单很容易，只要把东西添加上去即可。如果要去购物，很难用排除法得出自己需要什么。如果要规划三餐，一张清单就必不可少，除了要弄清楚要哪些原料，还要计算出所需的数量，才能保证膳食计划。如果有待办清单和日程，就可以知道谁会来，需要做什么准备。知道有多少张嘴要吃饭，要买多少食物和饮料，以及要为访客准备多少套床褥。\n待办清单好就好在，可以设定一个最终目标，然后加入子任务，使一个庞大而遥远的目标看起来更加可行。加入估算可以提供一些紧迫感，而这种紧迫感，在最后期限如此遥远的情况下，通常是缺失的。许多公司使用软件来跟踪任务，这些软件通常提供一些功能，允许生产者确定关键路径、预估所需的开发人员时间，甚至是维持项目所需的技术平衡。不使用这种软件常常是公司没有不怎么关注效率，甚至是浪费的标志。如果关注项目中的效率和浪费，任务清单就不失为一个分析成本来源的好方法。通过记录并追踪这些清单，可以通过观察数据，了解软件执行中的操作的大致形态。不这样做的话，就很难定位真正的瓶颈，问题可能不是处理，而是处理数据的请求本身就已经失控了。\n程序运行时，若不让它处理同质化的列表，而是有什么做什么，那效率就会很低，还会导致帧时长不规则、不稳定。低效利用硬件往往都是因为处理无法被预测。在指向异质类的大数组都被 update() 函数调用时，会遭遇大量的数据依赖，导致数据和指令缓存均出现未命中。原因详见第 8 章。\n程序慢，也可能是因为不清楚有多少工作待办，因而无法确定工作的优先级和规模，进而不能确定在给定的一帧时间内完成多少任务。若没有待办清单，也没能力估计每项任务的耗时，就难以在保证用户反馈的同时，决定最佳行动方案来减少开销。\n面向对象编程工作能在程序运行时，模式较少的情况下，工作地很好。程序只处理少量的数据，或数据有难以置信的异质性，以至于有多少种事物就有多少类。\n不规则的帧时长，往往是因为没有提前对远期目标采取行动。如果读者，作为一个开发者，知道必须为一个新的岛屿加载资产，当玩家冒险进入周围的海域时，流加载系统能收到通知，载入必要的数据。可能是一个房间和远处的其他房间。也可能是玩家视线范围内的地下城或洞穴的数据。我们把这种先发制人的数据流当作一种特殊情况，并创造提供这一级别规划的系统。依靠人类（哪怕是关卡设计师）来把这些联系在一起很容易出错。许多情况下，如果没有自动检查，就会漏掉一些依赖关系链。没有一种常规语言可以描述时间上的依赖关系，因而也无法让系统有足够的自我意识去执行自我加载。\n许多游戏中，我们会用显式的触发器将事情串联起来，但对于许多其他游戏元素，往往没有这样的系统。没怎么听说过 AI 因为待会儿可能会去某个目标点，从而执行寻路，是因为待会儿可能会去那边。最接近的做法是，开发者预填充一个导航图(navigation map)，这样就可以迅速粗略地完成路径选择。\n还有一个先期工作的深度问题。考虑一个小房间，创建为独立资产，一个等候室有两个相邻的门，都通向很大但不同的两张地图。当玩家在地图 A 中靠近等候室的门时，这个小房间就可以被抢先流加载进来。然而，在许多引擎中，地图 B 不会流加载，因为地图 B 到地图 A 的位置特性隐藏在等候室的逻辑层后面。\n物理系统做预判也不太常见，比如为了执行下一步工作，检查未来是否会发生碰撞。如果它能感知更多，或许能实现一个更复杂的破碎模拟。\n如果让游戏生成待办清单、购物清单、远期目标，并允许通过前瞻性思考来采取预防措施。那就可以把程序员的任务，简化为对目标和效果做优先级排序，或编写运行时生成优先级的代码。读者可以考虑如何将这些依赖关系连锁起来，以解决等候室的问题。也就可以开始抢先处理所有类型了。\n处理的类型 #  存在性处理与待办清单有关。处理同质的数据集时，我们已经知道，要以相同方式处理每个元素。集合中的每个元素上会执行相同的指令。这里对输出没有明确的要求。但通常归结为三种操作：过滤(filter)，突变(mutation)，散发(emission)。突变是对数据执行一对一操作，接收数据输入和一些在变换前设置的常数，并为每个输入生成一个唯一元素。滤波同样接收传入的数据，在变换前设置一些常数，并为每个输入元素要么生成 0 或 1 个元素。散发是对传入数据的操作，能生成多个输出元素。和其他两种变换一样，散发可以使用常数，但输出表的大小没有限制，它能生成零到无穷个元素。\n第四种，也是最后一种形式，叫做生成(generation)，并不能算是真正的数据操作，但通常是变换管线的一部分。生成不需要数据输入，而只根据设置的常数产生输出。使用计算着色器时，就可能会遇到这样的函数，它只是对数组执行置 0、置 1、升序操作。\n 变换\n          突变 $in == out$ 处理输入数据。每一个输入项目产生一个输出项目。   过滤 $ in \u0026gt;= out $ 处理输入数据。每一个输入项目最多产生一个输出项目。   散发 $out = \\begin{cases} 0, \u0026amp;in = 0\\\u0026gt;=0, \u0026amp;otherwise \\end{cases}$ 处理输入数据。每项输入产生未知数量的项目。如果没有输入，输出也是空的。   生成 $in = 0 \\wedge out \u0026gt;= 0$ 不读取数据。仅仅通过运行就产生了未知数量的项目。      [表 3.1]: 常见的变换类型\n 这些类别可以帮助决定：要使用什么数据结构来存储数组；是否需要一个结构；或是否应该用管线将数据从一个阶段输送到另一个阶段，而非在中间缓冲区上操作。\n每个 CPU 都能有效地在核心上处理同质数据集，也就是在连续的数据上反复做相同的操作。没有全局状态，没有累加器，就证明可以并行。可以看一下 map-reduce 和简单的计算着色器，用现有的技术举例，来说明如何在这些限制中，建立真正的工作应用。无状态变换在应用分布式处理技术时也安全。Erlang 由于于没有副作用，因而实现了线程间、进程间、乃至分布式计算的安全处理。对有状态的数据执行无状态的变换高度稳健，可以深度并行。\n处理每个元素时，对于变换核心操作的每个数据，使用控制流非常合理。几乎所有的编译器都应该能将简单的局部分支指令，简化为平台首选的无分支表示。如 CMOV，或 SIMD 操作的 select 函数。在考虑变换内部的分支时，最好是比对着现有的流处理实现，如显卡着色器或计算核心。\n在分支低阶断言(predication)2中，不会忽略流控制语句，而是被用作如何合并两个结果的指标。若流控制不基于常量时，一个低阶断言 if 会生成代码，同时运行分支两边，并根据条件的值放弃其中一个结果，选择另一个。如前所述，许多 CPU 本身就有这个功能，不过所有 CPU 都可以使用位掩码去实现它。\nSIMD (single-instruction-multiple-data, 单指令-多数据) 能在指令相同时并行处理数据。数据可以不同，但都是局部的。没有条件语句时，SIMD 操作在我们的变换上很容易实现。在 MIMD (multiple-instruction-multiple-data，多指令-多数据) 中，每块数据都可以由一组不同的指令操作。每一块数据都可以用不同路径。它是最简单，也最容易出错的编码，目前大多数并行编程都是如此。每增加一个线程，就要用一个单独的执行线程处理更多数据。MIMD 包括多核通用 CPU。通常，它允许共享内存访问，也会有伴随而来的同步问题。目前为止，它最容易启动和运行，但也最容易出现那种，由状态复杂度引发的罕见的致命错误。因为操作顺序不确定，通过代码产生的的不同的可能路线的数量，向着超指数级爆炸。\n避免使用 boolean #  研究压缩技术时，我们必须了解的最重要的一点：数据和信息之间的区别。系统中存储信息的方式有很多，从表明某物存在的可解析的明文字符串，到简单到用来描述某物具有某属性的单比特标记。例如，代码中声明的局部变量，或一个物理网格中用于查询会响应哪些碰撞类型的比特集。有时可以通过先进的算法（如算术编码）或领域知识让存储的信息少于比特集。领域知识标准化适用于大部分游戏开发。但它的应用越来越少，因为很多开发者都过度热衷于引用 \u0026ldquo;过早优化\u0026rdquo;，反而身陷囹圄。信息被编码进数据，而编码的信息量可以被领域知识放大。重点是，我们可以看到，压缩技术提供的建议是：真正编码的是概率。\n举个例子，一个游戏中的实体有生命条 (一段时间不受伤害后就可以回复)，会死亡，能互相射击。我们来看看怎样利用领域知识减少处理。\nstruct Entity { // information about the entity position  // ...  // now health data in the middle of the entity  float timeoflastdamage; float health; // ...  // other entity information }; list\u0026lt;Entity\u0026gt; entities;  [代码 3.1]: 基本的实体方法\n void UpdateHealth ( Entity *e ) { TimeType timeSinceLastShot = e-\u0026gt;timeOfLastDamage - currentTime; bool isHurt = e-\u0026gt;health \u0026lt; MAX_HEALTH; bool isDead = e-\u0026gt;health \u0026lt;= 0; bool regenCanStart = timeSinceLastShot \u0026gt; TIME_BEFORE_REGENERATING; // if alive, and hurt, and it\u0026#39;s been long enough  if( !isDead \u0026amp;\u0026amp; isHurt \u0026amp;\u0026amp; regenCanStart ) { e-\u0026gt;health = min(MAX_HEALTH , e-\u0026gt;health + tickTime * regenRate); } }  [代码 3.2]: 简单的生命回复\n 假设有以下领域知识:\n 若生命值已满，就不会继续回复。 一旦被击中，需要一些时间才开始回复。 一旦死亡，生命就不会再回复了。 死亡时，生命值会为零。  现在来看代码 [代码 3.1] 中的实体，可以看到这里的数据会引发常见的缓存行问题。此外，代码中会如何调用 update 相关的函数呢？如代码 [代码 3.2] 示，每次 update 都会针对每个实体调用一次相关函数。\n这里我们可以从流程控制语句入手，做些改进。如果生命值满，函数就不执行。如果实体已死亡，也不执行。回复函数只在距离上次受伤过了足够久才执行。考虑所有这些情况，其中血量回复并非常态。所以，这里应该尝试为常见的情况组织数据布局。\n现在把结构体改为代码[代码 3.3] 中所示。更新函数不再针对实体执行，而是针对生命表。因此我们知道，只要这个函数在执行，实体就没死，它就会受伤。\nstruct Entity { // information about the entity position  // ...  // other entity information }; struct Entitydamage { float timeoflastdamage; float health; } list\u0026lt;Entity\u0026gt; entities; map\u0026lt;EntityRef ,Entitydamage\u0026gt; entitydamages;  [代码 3.3]: 存在性风格处理的生命\n 只在实体受到伤害时才需要添加一个新的 Entitydamage 元素。如果实体在已有 Entitydamage 的情况下受伤，它就只需更新 health 状态和 timeoflastdamage，无须再创建新的。如果想知道某人的生命情况，只需检查他是否有 Entitydamage，或者查看 deadEntities 表中是否有他。之所以能这么做，是因为每个实体都有一个隐式的布尔值，藏在已有的行里。对于 entitydamages 表，这个布尔值就相当于第一个函数中的 isHurt 变量。同样的，deadEntities 表中的 isDead 也是隐式的，表示生命值为 0。这就可以省下资源用于其它系统。不必加载一个浮点数并判断其值是否小于 0，省去了浮点比较、转换为布尔值的过程。\nvoid UpdateHealth () { for( edIter : entityDamages ) { EntityDamage \u0026amp;ed = edIter -\u0026gt;second; if( ed.health \u0026lt;= 0 ) { // if dead , insert the fact that this entity is dead  EntityRef entity = edIter -\u0026gt;first; deadEntities.insert( entity ); // if dead, discard being damaged  discard(ed); } else { TimeType timeSinceLastShot = ed.timeOfLastShot - currentTime; bool regenCanStart = timeSinceLastShot \u0026gt; TIME_BEFORE_REGENERATING; if( regenCanStart ) ed -\u0026gt;health =ed -\u0026gt;health + tickTime * regenRate; // if at max health or beyond, discard being damaged  if( ed -\u0026gt;health \u0026gt;= MAX_HEALTH ) discard(ed); } } }  [代码 3.4]: 每个实体的生命回复\n 消除布尔值也不是什么新鲜事，因为每有一个指向某物的指针时，都会引入一个非空的布尔值。正因为不想检查 NULL，才促使我们为处理\u0026quot;对象是否存在\u0026quot;寻找不同的表示方法。\n其他类似的情况包括：武器换弹、游泳时的氧气余量、任意会耗尽的有数值的事物、有极值的数据等。甚至汽车的行驶速度：如果参与交通，大部分时间都会在限速区间内行驶，而非需要算出某个速度。如果有群人都朝同一个方向走，那么进入这个群体的人会一直受阻，直到与群体不再相斥。此时他可以放弃独立的想法，在群体中随波逐流。这一点，会在第五章详细介绍。\n转换为保存属性状态的列表，能实现更好的性能优化。与时间相关的属性，第一要务是将其放进有序的表中，按它们应被执行的时间排序。我们可以把回复时间放进有序表，然后不断 pop 出 entityDamage，直到遇到无法被移到活动表中的元素，然后一次性跑完所有活动列表。现在就知道哪些对象受伤了，没有死，可以再生，并且可以开始回复生命了。\n再来看不同时间间隔内更新的属性。动植物响应环境的机制有所不同。有的非常快，如远离危险的反应：把手抽离热锅。也有较慢的，如负责推理的脑区。也有快到近乎即时的，像是反射，是大脑在没时间详细思考时的反应，如接球、在自行车上保持平衡。大脑还有更慢的区域，比如现在，与其说你是在读这本书，不如说是在整理出一个模型，以便理解文字的含义，并最终吸收他们。还有更慢的：压力响应，如荷尔蒙弥散在体内的化学物质，当前体内能调动的糖分，当前的水合水平，所有这些组成一套相应的系统。能够在多个时间尺度上思考和反应的 AI 或许更节约资源，也不太可能出现奇怪的行为，或在决定间犹豫不定。保证每个系统每帧都更新，可能会陷入不可能的境地。将工作分成不同的更新率仍有规律可循，同时带来了能够平衡多帧工作的机会。\n另一个用途位于状态管理中。若一个 AI 听到了枪声，那他可以在表格中添加一行，记录最后一次听到枪声的时间，可以用来确定他们是否处于高度警觉状态。若 AI 与玩家进行了交易，只要玩家有可能想起，那 AI 也就必记住。若玩家刚把 +5 的长剑卖给 AI，且只是离开商店一会儿，那这把剑就很有必要保存在店主 AI 的库存里。有些游戏甚至在交易过程中也不保留库存，如果玩家不小心卖掉了需要的东西，然后存档，大概会相当痛苦。\n从游戏角度看，这些额外信息都是玩家与世界的互动。一些游戏中，玩家可以把自己的东西永远留在周围，它们会永远保持留下时的样子。一些开放世界 RPG 里，玩家丢在山洞里的所有东西，仍然准确出现在几个小时前丢下的位置，这已经是是相当大的成就了。\n增补数据(tacking on data)，或者说，用动态的附加属性补充加载的数据的基本概念，已经存在了相当长时间。保存游戏通常是将动态世界与基础状态比较后的差值编码，其中一个早期用途，是在完全动态环境中，加载世界，但其后可以被摧毁、改变。一些世界生成器使用程序化地形，允许其内容创作者添加额外的补丁信息：村庄、堡垒、前哨，甚至催生出大量地形工具，用于调整生成的数据。\n慎用枚举 #  枚举用于定义状态集。原本可以为回复中的实体设一个变量，包含 infullhealth、ishurt、isdead 三种状态。也可以给无效的实体设索引，枚举可用的组别。但这里，我们用表格表示所需的信息，毕竟只有两组。任何枚举都可以用各种表模拟。只需要为每个枚举值建一个表。设置枚举值即是插入，或是从一个表迁移到另一个。\n使用表替代枚举时，可能会带来更多困难：找出一个实体中的枚举值会变难，因为需要检查所有能代表该实体状态的表。然而，需要获取该值的主要原因，也许是为了根据外部状态执行操作；又或是为了找出满足状态的实体以判断是否需要进一步操作。大多数情况下，这些都是不允许，也没必要。首先，访问外部状态在纯函数中是无效的。其次，任何依赖数据都应该已经是表元素的一部分了。\n如果这个枚举是以前由 switch 或虚拟调用处理的状态或类型，就不需要再查询了。其实，要改变的是思考方式。解决方法是通过转换，将每个 switch case、虚方法的内容，作为操作应用在相应的表中，即对应原始枚举值的表。\n如果枚举是用来确定是否可以对一个实体进行操作，比如考量到兼容性，那可以考虑用一个辅助表，来表示处于兼容状态。如果情况是，查询结果需要返回一个实体，并且需要在确定提交修改前，知道它是否处于某种状态。那可以考虑，将兼容的数据，作为输出表标准的一部分先生成；也可以在提交一个过滤操作，创建正确形式的表。\n总之，之所以把枚举转换为表的形式，是为了减少控制流的影响。鉴于此，如果不使用枚举来控制指令流，就不用管了。还有一种情况，枚举的值频繁变化时，因为表到表迁移对象也是有成本的。\n合理的枚举的例子如：按键绑定、颜色枚举、命名合理的小的有限值集合。返回枚举的函数，如碰撞响应（无、穿透、通过）。任何实际表现为对另一种形式的数据的查询的枚举，都是好的。这些枚举用在那些较大、难以记忆的数据表中，将数据访问合理化。有些枚举还有一个好处，就是可以帮助你在 switch 中捕获未处理的情况，并且某种程度上，它们也是大多数语言中的自解释(self-documenting)功能。\n初探多态 #  现在来考虑如何实现多态。没必要使用虚表指针；可以使用枚举变量来指明类型。这个变量可以用于在运行时定义该结构应具备什么能力，以及要如何响应。也可以在对象上调用方法时，用来判断和选择函数。\n类型的定义基于成员变量的类型时，虚函数通常会实现为基于它的 swtich 或函数数组。若要允许运行时加载库，就得有个系统去更新被调用的函数。简陋的 swtich 无法胜任，但函数数组可以在运行时修改。\n现在有了一个既不优雅，也不高效的方案。数据仍然由指令负责，并且每当有意料外的虚函数出现，我们仍会在指令缓存未命中和分支预测错误的问题上煎熬。但真正避免使用枚举，并且用表来表示枚举的每个可能的值时，我们仍旧有可能，同基于指针的多态一样，兼容动态库加载。同时也能保证处理异质类型的数据流时的效率。\n对于每个类，都有一个工厂类来替代类的声明，它能选择生成正确的表插入调用。同时利用存在性处理，替代了多态方法调用。表中的元素允许类的特征以隐式存在。用工厂创建的类可以很容易通过运行时加载的库扩展。只要有数据驱动的工厂方法，注册新的工厂也应该很简单。表的处理和它们的 update() 函数也会被添加到主循环中。\n动态运行时多态 #  如果通过组合创建类，并允许通过对表做插入、删除来改变状态，那也就解锁了动态运行时多态。这是通常只在通过 switch 进行动态响应时才有的功能。\n多态是指程序中的一个实例能够以不同的方式对一个共同的入口点作出反应，具体由该实例的性质决定。C++ 中，编译时的多态可以通过模板和重载实现。运行时多态是指一个类能够为一个共同的基础操作提供不同实现，而该类的类型在编译时未知。C++ 通过虚表处理这个问题，在运行时根据隐藏在虚表指针中的类型，从该指针所指向的内存调用正确的函数。动态运行时多态是指一个类可以根据其类型以不同的方式对一个共同的调用签名做出响应，并且其类型在运行时可以改变。 C++ 没有明确实现这一点，但是如果类允许使用一个或多个内部状态变量，那它就可以根据状态，以及查询核心语言的运行时虚表提供不同的响应。其他能更流畅地定义其类的语言，如 Python，允许每个实例更新它响应消息的方式。但这些语言大多数总体性能非常差，因为调度机制已经建立在动态查找之上。\n现在来看代码 [代码 3.5]，我们希望通过运行时方法查找，来解决不知道类型但想知道大小的问题。允许对象在其生命周期内改变形状需要做出妥协。一种方法是在类中保存一个类型变量，如代码 [代码 3.6]，对象作为类型变量的容器，而非特定形状的实例。\nclass shape { public: shape() {} virtual ~shape() {} virtual float getarea() const = 0; }; class circle : public shape { public: circle(float diameter) : d(diameter) {} ~circle() {} float getarea() const { return d*d*pi/4; } float d; }; class square : public shape { public: square(float across) : width(across) {} ~square() {} float getarea() const { return width*width; } float width; }; void test() { circle circle( 2.5f ); square square( 5.0f ); shape *shape1 = \u0026amp;circle , *shape2 = \u0026amp;square; printf( \u0026#34;areas are %f and %f\\n\u0026#34;, shape1-\u0026gt;getarea(), shape2-\u0026gt;getarea() ); }  [代码 3.5]: 简单的面向对象形式的代码\n enum shapetype { circletype, squaretype }; class mutableshape { public: mutableshape ( shapetype type, float argument ) : m_type( type ), distanceacross( argument ) {} ~mutableshape() {} float getarea() const { switch( m_type ) { case circletype: return distanceacross*distanceacross*pi/4; case squaretype: return distanceacross*distanceacross; } } void setnewtype( shapetype type ) { m_type = type; } shapetype m_type; float distanceacross; }; void testinternaltype() { mutableshape shape1( circletype, 5.0f ); mutableshape shape2( circletype, 5.0f ); shape2.setnewtype( squaretype ); printf( \u0026#34;areas are %f and %f\\n\u0026#34;, shape1.getarea(), shape2.getarea()); }  [代码 3.6]: 丑陋的内部类型\n 另一个更好的方法是通过变换函数来处理每种情况。实现详见代码 [代码 3.7]\n虽然这样有用，但所有指向旧类的指针现在都无效了。使用句柄可以减轻这些忧虑，但大部分情况下，又增加了一层间接访问，反而会进一步拖累性能。\nsquare thecircle( const circle \u0026amp;circle ) { return square( circle.d ); } void testconvertintype() { circle circle( 5.0f ); square square = squarethecircle( circle ); }  [代码 3.7]: 更新现有的类\n 如果使用存在性处理技术，类由它们所属的表定义，就可以运行时在表之间切换。因此可以在没有任何技巧的情况下改变行为，而不需要为需要的所有状态管理 union 来保存所有不同的数据。如果用不同的属性和能力来组合类，又要在创建后改变它们，也是可以的。如果正在更新表，实体的指针地址发生变化也影响甚微了。在基于表的处理过程中，实体在内存中移动是很正常的，所以意外反而较少。从硬件的角度来看，为了实现这种形式的多态，需要为每个类属性、能力中的实体引用提供一点额外空间，但不需要虚表指针来寻找要调用的函数。还可以优先遍历相同类型的实体来提升缓存利用率，尽管它已经提供了一种安全的方式来在运行时改变类型。\n由于类是由它们所属的表隐式定义的，所以有机会将一个实体注册到多个表中。因此表明，一个类不仅可以在动态运行时具备多态性，还能具备多面性，即它可以在同一时间内成为多个类。单一的实体可能会对同一个触发器调用做出两种不同的反应，因为它适合该类的当前状态。\n这种多维分类在传统的游戏代码中并不多见，但在渲染中，通常会有几个不同的维度，如材质、混合模式、某种蒙皮、其他顶点调整，会发生在某个特定的实例上。或许在代码中看不到这种灵活性，因为它不能通过语言的自然工具获得。可能我们确实看到了，但它其实就是一些人提到的 ECS (entity component system)。\n事件处理 #  过去，如果想监听系统中的事件，需要绑定到一个中断上。有时候可能还得琢磨一下这类代码，通常它们是给旧的、微控制器规模的硬件用。出发点也很简单，当时的处理器速度，还不足以快到轮询所有可能的信息来源并处理，但又足以接收事件并即时处理。游戏中通常这样处理事件，先注册某个感兴趣的事件，然后在事件发生时被告知。发布订阅模型已经存在了几十年，但一些语言中没有为它建立标准接口，另一些中则有太多的标准。它往往需要一些来自问题域的知识，以选择最有效的实现。\n有些系统希望能获取系统中的每一个事件，并自行决定，如 Windows 事件处理。有些只订阅非常特殊的事件，但期望立即对事件做出响应，如 BIOS 事件处理程序、键盘中断。有些事件可能非常重要，并直接由发布事件的这一行为来调度，如回调。有些也可能是懒惰的，停留在某个队列中，等待之后的某个时刻被分发。最佳的方法由要解决的问题来确定。\n通过利用在表中的存在性去注册的技术，让事情变得更简单，并且也能极大提升注册和取消的速度。订阅变成了插入，取消订阅变成了删除。可以用全局表来订阅全局事件。也可以有命名的表。通过命名的表，就可以使订阅者在发布者存在之前订阅事件。\n发布事件时，我们会有一个选择。可以选择立即启动转换；或者排队等待新事件，直到整个转换完成，然后一次性全部派发。随着模型变得更简单、更可用，带着更通用的可能性，我们能够以新的方式，实现传统中通过轮询完成的代码。\n例如：除非玩家角色在激活门的距离内，不然玩家的操作按钮的事件处理程序，不需要与门关联。当角色进入范围内时，就会在动作事件表中注册 has_pressed_action，并以 open_door_(X) 返回。这样就能避免 CPU 在搞清楚玩家到底想激活什么东西上浪费时间，同时也能帮助提供状态信息：如，显示按绿色按钮开门。\n如果所有的表都拥有类似 DBMS 中的触发器，就可以注册输入映射的变化及其响应。钩住低级别的表，如，插入 has_pressed_action 表，UI 就知道：该更新提示信息了。\n这种编码风格有点像面向方面编程，代码中很容易实现横切关注点。面向方面编程中，任何活动的核心代码都很干净，而任何副作用或禁止的活动行为，都借由其他关注点从外部钩住活动来处理。核心代码因此得以保持干净，但代价是，写代码时不知道哪些真正会调用。而使用注册机制的不同之处在于：响应从哪来？如何确定它？位于面向方面编程中，通常隐式存在的因果关系大大减少甚至移除，因而调试难度也大大降低。同时也能弱化面向对象的决策难以调整的性质，代码变得更加动态，并且免去了通常与数据驱动控制流有关的成本。\n  Ben Moseley and Peter Marks, Out of the Tar Pit, 2006\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：尚不确定这个词的术语，用法与一阶谓词逻辑中(或低阶断言逻辑)相同\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":4,"href":"/docs/translations/dod/","title":"Dod","section":"Translations","content":"[译介]面向数据设计 #   原作者：Richard Fabian\n 基于免费的在线版 https://www.dataorienteddesign.com/dodbook/\n译者水平有限，如果发现有问题，可以联系 blog.zko.ooo@gmail.com\n"},{"id":5,"href":"/docs/translations/%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/","title":"纹理压缩技术","section":"Translations","content":"[译介] 纹理压缩技术 #    本文翻译自一篇由 T. Paltashev 和 I. Perminov 撰写的论文，其英文版本链接如下：\nhttp://sv-journal.org/2014-1/06/en/index.php?lang=en\n 概述 #  本篇文章，会从压缩比和图像质量角度出发，分别在技术层面和现代硬件 (如：PC，手机和平板) 层面对不同的纹理压缩技术进行深入分析和比较。首先我们会分析最早广泛使用的 S3TC (BC1-BC3) 系列。随后会逐个分析一些通过增加灵活性和使用块分割技术而大大改进图像质量的新系列： BC4, BC5, BC6H 以及 BC7。接着分析由爱立信开发的面向移动端的 ETC(PACKMAN, ETC1 ( iPACKMAN ) , ETC2/EAC) 和 Imagination Technologies 发明的 PVRTC。最后会分析由 AMD 与 ARM 协同开发的 ASTC 技术。我们也会详细讨论 ASTC 所使用的 BISE 编码技术和其他特性。\n关键词：computer graphics, texture compression, texture decompression, S3TC, DXT, BCn, BC6H, BC7, ETC, ETC2, EAC, PVRTC, PVRTC2, ASTC.\n前言 #  如果没有不同的纹理，3D 计算机图形学恐怕是不可想象的。在不增加几何复杂度的前提下，纹理技术能够大幅提升图形质量。简单的纹理是映射在 3D 表面上的 2D 图像。纹理中的每一个像素又称为纹素 (纹理的基本单位) 。通常除了颜色信息，纹理还能够存储高度信息、法线方向以及镜面系数等 (见图1) 。现代 3D 应用和游戏会占用大量的内存，而其中一半以上都被纹理所占用，因此对内存大小和带宽有很高的需求。各种纹理压缩技术应运而生，以减少对内存和带宽的压力。基于这种情况，材质通常都是以压缩状态存储在内存中并传输至 GPU。解压过程只发生在 GPU 上，通常位于 L1 和 L2 cache 之间。这样的话，不仅减少了内存占用，也同时节省了带宽。压缩同时也能够节省功耗，因为 GPU 核心同显存之间的数据交换也是会产生功耗的，而这一点对于移动设备尤为重要。\n [图1]: 不同类型的纹理映射示例。A - 漫反射贴图； B - 法线贴图 C - 位移 (高度) 贴图\n 纹理压缩的特性 #  绝大多数情况下，纹理表现为一张 2D 图片。但标准的压缩算法 ( RLE, LZW, Deflate) 以及常用的图片压缩格式 ( JPEG, PNG TIFF) 并不适用于纹理压缩。主要原因是上述算法不满足随机访问。因此很难在不解压整张纹理的前提下直接访问某个特定的纹素。纹理访问的模式高度随机：只有在渲染时被用到的部分才需要访问到，且无法提前预知其顺序。而且在场景中相邻的像素在纹理中不一定是相邻的 (见图2) 。因此图形子系统的性能高度依赖于纹理访问的效率。随机访问决定了各种纹理压缩格式的主要特点。\n [图2]: 纹理布局示例。(纹理和3D网格来源：Microsoft DirectX 9 SDK)\n 多数纹理压缩策略会将整张纹理划分为固定大小的块 (Block)，又称为瓦片 ( Tile)，每个瓦片被单独压缩。但也有一些特例，如 PVRTC。评估一个纹理压缩方案，需要考虑以下因素：\n 随机访问。GPU 需要能够随机有效地访问任意纹素。因此几乎所有的压缩器都拥有固定的压缩比。 这也就意味着有损压缩。当然非固定压缩比也是能够胜任随机访问的需求的。例如，Inada和McCool在(2)中提出了无损的可变速率方案，通过修改纹理缓存结构来实现高性能。 高解压速度。 贴图访问速度也是会影响图形子系统性能的关键因素，由此引出下述两个因素：  解码器的低成本硬件实现。解压算法应当相对简单，所以很少用到小波变换 (wavelet) 以及离散余弦变换 (DCT- disrete cosine transform) 。 无间接和连锁内存访问。理想情况下，只需读取一次内存就能获取解码一个小区域的纹理所需的全部信息。而为了获得过滤的纹理，只进行最低限度的额外读取。任何额外的内存访问 (如读取调色板或其他表) 都增加了整体延迟。由于降低了局部性，间接访问还会拉低缓存效率。   高压缩比。这是在进行纹理读取时，决定带宽占用的主要因素。压缩比通常用比特率或每像素平均比特数 ( bpp - byte per pixel 译注：原文为 byte per texel) 来表示。典型的 bpp 的值为从 2bpp 到 8bpp。 图片会被分割成小块，通常为 4x4 纹素。块太小的话会比较难压缩，而太大的话又会影响到 cache 命中。另外，为了减少延迟和简化硬件实现，压缩块的大小最好小于内存总线的宽度。如果一个压缩块所占的位数与总线宽度相同，就可以避免流水线停顿(3)。现代图形处理器的内存总线通常从 64 位到 512 位。由于严格的硬件和功率预算，移动设备的纹理压缩方案利用非常高的压缩比 (2bpp) 或更小的块来适应内存总线宽度。 解压后的纹理有可接受的视觉质量。压缩器引入的失真当然是越小越好。  流式纹理压缩 #  在这篇文章中，我们将只详细讨论提供随机访问并有硬件支持的格式。但是这里仍旧需要提及一下流式纹理压缩。这种技术用于将贴图快速从硬盘或网络加载到显存中。对于图像数据达到千兆字节量级的现代应用来说，这的确是个问题。\n首要的目标是降低数据大小。在没有随机访问的要求时，便可以实现非常高的压缩比和 (或) 无损压缩。当纹理加载进内存之后，就可以用可编程着色器解压它。其输出可能是未压缩的格式，也可能是硬件支持的压缩格式。也可能通过以下方式优化内存管理：在显存中保存高度压缩的完整纹理集，并为当前场景的纹理子集使用一个对 GPU 有好的格式。\n相较于常用的压缩手段 (RLE, LSW, Deflate)，这种特殊的压缩方式提供了更好的压缩比。对于游戏主机，也能够让开发者在一张光盘里存放更多内容。\n例如，IdTech5 引擎 (4) 使用的虚拟纹理技术可以将类似 JPEG 格式的纹理加载并实时转码至 DXT。不过这两种格式都会引入压缩伪影。\n说到这里，就需要提及一下其他出版物中， Olano 等人 (5) 提出的与 mip-map 紧密耦合的有损和无损压缩方案，以及 Ström 等人 (6) 提出的针对 ETC 格式再进行无损压缩的方案。\n速度与质量 #  虽然原始图像与重建图像之间的区别很大程度取决于压缩格式，压缩算法在其中也起着重要作用。显然，基于穷举搜索的算法能够以性能为代价获得最好的质量。对于大多数算法来说，以合理的速度获得良好的质量仍是一项艰巨的任务。如上所述，在比较纹理压缩的质量时，必须详细说明如何进行压缩以及使用哪种算法。\n解压算法同样能够影响图像质量。例如，在 GeForce/GeForce2 的芯片中硬件实现的 DXT1 解码器，所有内部色彩指令均工作在 16 位模式下，而不会转换到 24 位模式 (7) 。因此会在解压时引入额外的伪影 (见图3) 。\n [图3]: 压缩的伪影。A - 未压缩，B - S3 Savage2000 上的 DXT1，C - NVidia GeForce 256上的 DXT1 (来源：iXBT (7) )\n 传统的实时 3D 图形会采用离线压缩器对纹理进行预压缩。而现代的渲染引擎越来越多使用大量动态生成的数据，如：用于模拟反射的环境贴图、延迟着色中使用的 G-Buffer 等。这就使得实时纹理压缩 (纹理会在每一帧都进行压缩) 有了用武之地。实时压缩也会用于低延迟高分辨率的视频流，如 UltraGrid (8) (9)。\n虽然针对某些格式的快速压缩算法早已存在 (10) (11) (12)，但由于硬件限制，针对动态生成数据的压缩仍需要新的方法。\n例如，像素着色器无法访问相邻的像素。为了避免可能的像素重叠，因此一个瓦片的结果只有在整帧渲染结束之后才能访问。 解决这些问题的方法之一是使用 tile-based GPU 架构。尽管纹理在被送入显存后也可以被压缩，但当前的 3D API (D3D 11.2, OpenGL 4.4) 所引入的数据复制开销大大削弱了这种方法的效率(13)。\n在本文中，我们将会更详细讨论一些知名的纹理压缩格式：\n S3TC 系列，应用于个人电脑 针对移动端设计的 ETC 和 PVRTC 系列 以及 ASTC，适用于全平台的新格式  早期的重要工作 #  最简情况下，一个像素的编码可以直接用一个数字 (通常为 4 位或 8 位 ) 表示，对应调色板上的一个索引。这个技术在早期广泛应用于视频适配器或游戏主机上，用以降低视频帧缓冲器的大小和带宽。然而，调色板并不太适用于纹理压缩，原因如下：\n 低压缩比 (比较典型的为 8bpp) 受限于调色板的色彩上限，质量差 (8bpp 时只有 256 色) 两次内存访问 (一次纹素，一次调色板) 占用了更高的带宽，同时也增大了延迟。尽管调色板的内存可以作为一个专用的 RAM 来实现，但每次访问新的纹理时，仍需重写调色板。  调色板压缩是矢量量化 ( VQ - Vector Quantization) 的一个特例，矢量是单个像素。世嘉 Dreamcast 游戏机使用了一种更为复杂的 VQ 压缩，在压缩比为 1:5 和 1:8 时纹理质量尚可。\n块 (block) 压缩是一种替代方案，采用固定大小的块压缩。由于每个压缩块包含解码整个瓦片所需的所有信息，解码可以只读取一次内存。\n最早的块压缩方案之一是块截断编码 ( BTC - Block Truncation Coding) ，用于压缩灰度图。该算法的核心思想是保存两份样本矩：均值和方差。每个块会通过使用 “a” 和 “b” 两个值进行重建 (见图 4 )。一个压缩块由这两个值和一个位图组成，其中每个位对应一个纹素。\n [图4]: BTC 编码的例子。A - 源块，B - 位图，C - 解码块\n BTC 编码需要几步来完成：首先，将一张图像拆分成 $M * N$ (通常为 $4 * 4$ ) 大小的小块。然后针对每个区块计算平均值 $\\overline{x}$ 和 标准差 $\\sigma$ 。接着，构建位图，如果对应的纹素值大于均值则将该位置 1。最后则会根据如下公式计算 $a$ 和 $b$ 的值。 $$ a = \\overline{x} - \\sigma \\sqrt{\\frac{m-q}{q}} \\tag {1.1} $$\n$$ b = \\overline{x} + \\sigma \\sqrt{\\frac{(m-q)}q} \\tag{1.2} $$ 其中 $m$ 是一个块中纹素的数目， $q$ 是位图中 1 的数目。\nBTC 以简单的编码和轻量的解码算法，实现了良好的压缩比。对于 4x4 的瓦片， 可以达到 1:4 或 2bpp。它曾用于压缩火星探路者的漫游车图像 (15)。\n对于彩图，则可以对每个通道分别使用 BTC 算法，能达到 6bpp 的压缩比。不过这种方案会显著降低画质 (见图 5)。而基于 BTC 的 CCC (Color Cell Compression) 算法则能达到 2bpp 到 3bpp 。与 BTC 相似，CCC 把所有值量化为两个值，三条通道共享一张位图。\n  CCC 的编码算法与 BTC 相似。 首先逐纹素计算亮度 $Y$ 以及平均亮度 $\\overline Y$ (见等式$(1.3)$) 。然后通过比较每个纹素的亮度和平均亮度来构建位图。最后确定基色 $ a $和 $ b $。 $$ Y = 0.3 * R + 0.59 * G + 0.11 * B \\tag{1.3} $$ 有两种 CCC 算法，第一种以 RGB565 格式直接将 $a$ 和 $b$ 存储在压缩块 中， 因此一个块有 48 位 (每个基色各 16 位，位图 16 位 ) 可以达到 3bpp 的压缩比。第二种则是用一个 8 位的调色板索引替代原有的基准色，从而达到 2bpp的压缩比。当然这个版本的 CCC 也会有调色板压缩的缺点。\nCCC 算法兼具高压缩比和低成本硬件实现。由于一个块中只有两种颜色，导致画质损失严重。但其主要思想被应用于现代的纹理压缩格式中，这便是我们接下来要讨论的。\nS3TC 系列 #  S3TC (S3 Texture Compression) 最早由S3公司研发并取得专利。自1999年推出以来，它已被广泛接受为行业标准，且至今仍是最常见的压缩方案之一。 微软将 S3TC 引入其 3D 图形API DirectX 6.0，名称为 DXT1。而它的带有 Alpha 通道的纹理的修改即为现在大家所熟知的 DXT2-DXT5。这些格式统称为 DXTC (DirectX Texture Compression) 。DXT1 在 OpenGL 和 OpenGL ES 中也通过 EXT_texture_compression_dxt1 扩展得以支持。这个扩展属于 EXT_texture_compression_S3TC的一部分，其余部分也描述了 DXT3 和 DXT5。\n从 DirectX 10 开始，这些格式又被称为 BC1-BC3 (块压缩) 。同时添加了两种新的格式： BC4 和 BC5，它们早期被称为 ATI1/3Dc+ 和 ATI1/3Dc。3Dc格式是由压缩法线图的需求所催生的。DXT1 被设计来压缩彩色数据，在压缩法线数据时效率不高。BC4 和 BC5 的功能在OpenGL中对应 EXT_texture_compresion_rgtc(19) , ARG_texture_compresion_rgtc (20) 以及 EXT_texture_compresion_latc (21)这些扩展。\n随着 DirectX 11 的发布 ，又引入了两种新的格式： BC6H， 第一种是针对高动态范围 (HDR - high dynamic range) 纹理的标准格式；而 BC7，则用于处理非常高质量的压缩。在 OpenGL，两种格式都在 ARB_texture_compression_bptc (22) 规范中有所描述。\n所有 S3TC 系列格式都使用 4x4 的块。我们会在接下来的小节中详细描述这些压缩格式。\nBC1 块 (S3TC/DXT1) #  和 CCC 类似， BC1 也使用 $c0$ 和 $c1$两个基色，以及一张索引表 (位图) (见图6)。不过BC1的索引表每个像素使用了 2 位。这是因为 BC1 允许通过混合两个基色，从而产生 $c2$, $c3$两个新的颜色。所有 $c0, c1, c2, c3$ 一起就构成了一个压缩块的局部调色板。相较于 CCC，引入新色彩无疑让图像质量显著提升。基准色以 RGB565 格式存储，即红色占5bit， 绿色占6bit，蓝色占5bit，能够达到 4bpp 的压缩比。\n [图6]: BC1 块示例\n BC1 块有两种类型，一种不支持透明通道，另一种则支持。\n对于第一种，有两种方法定义 $c2$ 和 $c3$。最常见的实现是：基于等式 2.1，分别以 $1:2$ 和 $2:1$的比例进行线性混合。如果我们假设块中的颜色遵循正态分布，等式 2.2 产生的误差会更小。nVidia 的 GPU (23) 中使用了这种方法。此外，从 RGB565 到 RGB888 颜色转换的硬件实现可能会有一些简化，这也能够影响结果。所以相同的压缩数据在不同的硬件上可能产生不同的结果。对于这两种类型，四种颜色都位于 RGB 空间上以 $c0$ 和 $c1$ 为端点的同一线段上。\n$$ c2 = \\frac {2}{3} c0 + \\frac {1}{3}c1 , c3 = \\frac {1}{3} c0 + \\frac {2}{3}c1 \\tag{2.1} $$\n$$ c2 = \\frac {5}{8} c0 + \\frac {3}{8}c1 , c3 = \\frac {3}{8} c0 + \\frac {5}{8}c1 \\tag{2.2} $$\n第二种类型的 BC1 块允许编码一个 1 位的 alpha 通道，用于处理具有简单透明度的纹理。每个纹素只有完全透明和完全不透明之分。这种模式也称为穿通 Alpha (翻译存疑)。对于这种类型的 BC1 块，$c3$ 以 $1:1$ 线性混合，而 $c2$ 则表示完全透明。第二种类型的块能够更准确地编码一些没有透明像素的原始图像块。 $$ c3 = \\frac{1} {2}c0 + \\frac{1} {2}c1 \\tag{2.3} $$ 在较为原始的实现里，需要一个额外的位来区分第一种和第二种类型的块，但实际上会使用数据冗余来完成。通过交换端点和重新计算索引来对不同类型的同一块进行编码。这样，如果$c0$ (解释为16位整数) 大于$c1$，则将该块解码为第一类型块，否则为第二种类型的块。\n端点的选择对质量有很大的影响。寻找适当的端点 (使误差最小) 很有挑战性。有许多旨在提升速度 (10) (11) (24) 或提高质量 (25) 的编/解码器。\n2004年，nVidia 提出了 OpenGL (26) 的NV_texture_compression_vtc扩展，增加了对 3D 纹理压缩的支持，块大小为 4x4x1、4x4x2、4x4x3 或 4x4x4。但是，此扩展没有提供任何新的压缩方法。一个VTC块由1、2、3或4个独立的 S3TC / BC1 块组成，每个块编码一个二维 4x4 切片。\nBC2 块 (DXT2/DXT3) #  BC1 格式可以处理 24 位的 RGB 纹理，但不适用于 32 位的 RGBA8888 纹理。Alpha 通道可以用于存储透明度、高光或其他材质属性。Direct3D 中的 BC2 和 BC3 格式则专为此类纹理而设计。 BC2 块占用 128 位，是 BC1 大小的两倍。因此压缩级别为 8bpp。BC2 的一半数据用于保存 4 位精度的 alpha 值 (从 alpha a到alpha b) ，另一半是用于存储 RGB 数据的BC1 (见图7) 。实际上，BC2 相当于压缩了RGB通道的格式为RGBA8884的纹理。颜色通道的解码方式与 BC1 相同。唯一的区别是，它始终被视为第一种类型的块。\n [图7]: BC2 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n 要对半透明纹理进行合成或与背景混合，必须将颜色值乘以 Alpha 通道的透明系数。此时，直接将已经预乘的值存进颜色通道中会比较方便。DXT2 格式比较适用于这种情况。DXT3 块布局与 DXT2 一致，但假定颜色值不进行预乘。不过它们的解码程序都相同。格式名称仅用作区分颜色数据的含义。因此，BC3 格式并不对上述情况进行区分，解释数据的责任就落在了应用程序这边。\n需要注意的一点，在进行材质过滤之前，一定要先将颜色值乘以 Alpha。否则过滤的结果就会有误。在进行 Alpha 混合时，预乘 alpha 模式要优于直接存储初始值，并能够简化硬件实现。想了解更多预乘 Alpha 的信息，可参见 «Jim Blinn\u0026rsquo;s Corner: Compositing, Part 1: Theory» (28).\nBC3 块 (DXT4/DXT5) #  BC3 的块 (与 BC2 类似) 由两段64位数据组成：一段是 Alpha 数据，另一段是颜色数据。颜色部分同样使用了 BC1 的格式，但 Alpha 部分则以压缩形式存储 (见图8)。除了通道数外，Alpha 通道的压缩与 DXT1 类似：有两个 8 位精度的端点，3 位的索引表，因此能在局部调色板上 8 选 1。\n [图8]: BC3 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n 这里解码时也使用了与 BC1 相同的数据冗余技巧。如果alpha_0 \u0026gt; alpha_1，则通过线性插值计算局部调色板的六个附加值。否则，仅插值四个值，其余两个对应最大和最小有效值。代码 1 描述了 Alpha 通道的调色板填充过程。BC1 子块始终被视为第一种类型的块，使用公式 2.1 或 2.2。\n [代码1]: Alpha 通道的调色板填充 ( 来源：Programming Guide for Direct3D 10 (27) )\n 和 DXT2 / DXT3 类似，Direct3D 9 中的 DXT4 / DXT5 格式仅在颜色通道数据的含义上有所不同。DXT4 会假定存储的颜色数据已经预乘 Alpha，而 DXT5 则假定不预乘。 Direct3D 10 中只有一种 BC3 格式，因此不区分这两种情况。\n通常，BC3 能提供比 BC2 更好的图像质量，后者更适用于低一致性的 alpha 数据。\nBC4 块 (ATI1/3Dc+) #  BC4 块 (图9) 只是 BC3 块的 alpha 部分。它用于单通道纹理，例如高度图或高光贴图。解码后的值与红通道相关联。\n [图9]: BC4 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n  [代码2]: BC4 块调色板填充 ( 来源：Programming Guide for Direct3D 10 (27) )\n BC4块与 BC3 alpha 部分的使用相同的解码方式。但通常单通道数据 (例如位移贴图) 直接将浮点范围限制在 $[0, 1]$ 或 $[-1, 1]$ 内会更方便。因此，通常会直接将其对应到 red_0 和 red_1 两个端点。代码 2 描述了范围为 $[-1, 1]$ 时的调色板填充 。\nBC5 块 (ATI2/3Dc) #  3Dc 格式最初由 ATI 专门为压缩法线贴图而开发，因为 DXT1 并不能达到此类数据要求的质量。顾名思义，法线贴图包含每个纹素的法线的信息，使得可以在不增加几何图形的复杂度的情况下，计算出更高细节的光照 (见图1.B)。法线信息会以范围为 $[-1, 1]$ 的浮点数的形式分别存储在各个颜色通道中。BC1 的问题是不同颜色通道的值通过共用的索引表耦合在一起。这一点用在常规 RGB 图像没有问题，但不适用于通道间互不相关的法线贴图。并且由于局部调色板较小，BC1 显著限制了梯度值。 基于以上原因，使用BC1压缩的法线贴图的质量较差 (见图10) 。\n [图10]: 法线贴图压缩( 来源：ATI 3Dc 白皮书 (29) )\n 根据定义，法向向量具有单位长度，因此只需要指定 $x$, $y$ 值，就可以依照公式 2.4 来计算 $z$。而对于切线空间法向量 (24)，$z$ 值始终为正。 $$ z = \\pm \\sqrt {1 - x^2 - y^2} \\tag{2.4} $$ BC5 其实是一个双重的 BC4。它允许独立存储两个通道 (见图 11)。 同时 BC5 拥有更大的局部调色板，在处理双通道图像时可以获得远超 BC1 的效果。\n [图11]: BC5 块布局( 来源：Programming Guide for Direct3D 10 (27) )\n 每个子块的解码过程与 BC4 完全相同。 默认情况下，不会计算 $z$ 坐标，因为 BC5 格式可用于任意两种成分的纹理，解码后的值会填充红色和绿色通道。对于法线贴图，可以在像素着色器中计算丢失的 $Z$ 轴坐标。\nOpenGL中对应的扩展名为EXT_texture_compression_rgtc (19) ，ARB_texture_compression_rgtc (20) 和EXT_texture_compression_latc (21) 。_rgtc和_latc版本均同时描述了单通道 BC4 块和双通道 BC5 块。在使用_rgtc时，未打包的数据将解释为红和绿通道的值。 在_latc的情况下，未打包的数据将解释为亮度，或亮度和 alpha 值。\nBC6H 和 BC7 的通用信息 #  限制 BC1 压缩质量的主要因素有：\n 端点的精度低 (RGB565)。此外，通道中不均匀的位分布可能会导致颜色偏移。例如，很多纯灰色的颜色不能用RGB56 “精确” 地表示：RGB565 (12,24,12) 就是 RGB888 (99,97,99) 略带紫色，而 RGB565 (12,25,12) 则是偏绿的 RGB888 (99, 101, 99 )。 局部调色板较小。一个块中只能使用 4 种颜色。 所有颜色都位于 RGB 色彩空间中的同一条直线上。 如果原始块中的颜色没有映射到线段，则压缩块可能看起来很差 (见图 12)。   [图12]: BC1 \u0026ldquo;坏掉的\u0026rdquo; 压缩块示例\n 在新格式中，上述问题已经通过提高端点精度以及存储最多 3 对端点解决了。两种格式都使用 128 位块，因此得到了 8bpp 的压缩比。而根据块类型，压缩块会使用不同的字段集，每块字段集的大小也不同。因此可以针对每个块选择最佳编码。这种灵活性极大减少了压缩带来的伪影，但同时也显著增加了压缩复杂度。块类型的数量在 BC6H 中增加到 14 个，BC7 增加到 8 个。 与 BC1 不同的是，块类型会在压缩块的第一位中明确设置。 块类型也称为块模式 (block mode)。\n在利用多个端点对时，一个瓦片会被分为多个纹素组，称为子集 (subsets)。每个子集拥有自己的端点对。有两组和三组纹素的块各拥有64个预定义分区集 (partition set) 。因此只需要将分区 ID 存储在压缩块中就可以指定特定分区。图13 展示了其中一些分区集。\n [图13]: 两组(上) / 三组(下) 纹素块的前 8 个分区集\n  [图14]: 双区瓦片的 BC6H / BC7 块解码的简化示例\n 与之前的格式一样，索引表中的值指定了端点混合的比例。 分区 ID 用于确定每个纹素的端点对。 简化的解码示例如图 14 所示，其中 $A0-A1$ 和 $B0-B1$ 端点对分别用于子集 0 和子集 1。 索引的大小可以是 2 到 4 位。 因此，每个子集中可用的中间颜色数量从 2 到 14 不等。\nBC6H 和 BC7 格式有一个重要特性：位级精确解码。硬件必须返回与参考解码器一致的结果，即使是无效块也应如此。有关所有块模式的详细信息可以参考 Direct3D 11 文档 (30) 和 OpenGL ARB_texture_compression_bptc 扩展规范 (22) 。从 OpenGL 4.2 (31) 开始，此规范成为 OpenGL Core Profile 的一部分。\n端点插值 #  DXT1 格式并没有指定插值 (混合) 程序，因此不同的硬件会使用不同的权重 (见 BC1 ( S3TC / DXT1 )) 。新格式中总是会使用 64 作为系数，并严格定义插值权重。BC7 插值的伪代码如 [代码3] 示，其中 indexprecision  表示单个索引的比特大小，可以是 2，3，4比特。\n [代码3]: BC7 解压过程中使用的插值 (来源: Programming Guide for Direct3D 11 (30) )\n BC6H 的插值过程与之相似，只是使用有符号值，这里不再赘述。\n索引编码 #  DXT1 使用了数据冗余来帮助编码。在 BC6H / BC7 中也采用了同样的技巧来缩小索引表，每个端点对编码为 1 bit。例如，考虑左上角的 texel 0 的索引。如果其最高位为 1，则可以交换相应的端点，使其变为 0。于是总是可以通过重排端点使得子集里的某个索引的最高位为 0。这样的索引被称为锚索引 ( anchor indexes )，且该索引的最高位也不会存储在压缩块中。texel 0 的索引必定是子集 0 的锚索引。图 15 展示了一些分区集的锚索引：\n  BC7 块 #    表 1 展示了所有 BC7 块模式下不同字段的大小 ( NS 和 Format 列除外 )，单位为比特。\n Color - 每个颜色通道占用的大小 Alpha - alpha 通道的大小 P-bit - 是否有 P-bit P-Shared - 是否有共享 P-bit Rotation - ”Rotation“ 的字段大小 ISB - 是否有 idxMode/ISB 索引选择位 (Index Selection Bit) NS - 子集数量 ( Number of Subsets ) PB - 分区索引的字段大小 IB - 索引表中的索引的字段大小 IB2 - 第二个索引表中的索引的字段大小 Table - 索引表的总大小  表 1 中的块模式为最低位在右侧的最低有效字节 (LSB) 的值。 在下文取自 Direct3D 11 MSDN 页面 (30) 的图中 ，模式字段显示为最低位在左侧。 这两个值是序列正好是反的。\nBC7 在模式 0 下的 PB 字段仅有 4 位 (见图 16 )。因此，只有前 16 个分区集可用。而在其他多子集模式中，所有 64 个分区集都可用。\n新字段 P-bit 的含义与 RGBP/RGBAP 缩写中相应的字母 P 的含义，可以看看 BC7 Mode 0 的例子 (见图 16 ) 。块中存储了三个 RGB444 端点对，每个端点都有一个 P 位。端点会在反量化 (译注：量化为数字信号处理术语，此处翻译参考了 MSDN) 之前扩展到 RGB555，而 P-bit 会被解释为每个通道的最低位。相较于直接存储 RGB555，现在每个端点直接省下了 2 比特，精度损失却不超过 1 比特( 所有颜色通道里总共只会有 0 或 1 比特失真 )。\nBC7 在模式 1 时会使用 P-Shared 位。与 P-bit 相似，不过该位会在端点对中共享。\n [图16]: BC7 模式 0 的块布局 (来源: Programming Guide for Direct3D 11 (30) )\n  [图17]: BC7 模式 4 的块布局 (来源: Programming Guide for Direct3D 11 (30) )\n BC7 在 Mode 4 (见图 17) 和 Mode 5 下会有两个独立的索引表，可以用来独立存储四个通道中的一个。适用于像法线贴图这种，其中一个通道与其他通道无关的情况。这两个模式同样适用于分别存储色彩和 Alpha 值，这点和 BC3 有些相似。任何一个通道都可以成为拥有独立索引表的那个，Rotation 字段用于确定是具体哪个通道。\n在BC7 Mode 4下，索引表占用的位长度不一样，所以精度也会不一样。ISB 字段 (图17中的 idxMode) 用于确定表中有多少位用于独立通道，多少位用于其余通道 (译注：MSDN) 。\nBC6H 块 #  BC6H 格式旨在压缩高动态范围的纹理，即 HDR (High Dynamic Range)。仅支持不带 alpha 的 RGB 图像。通道值以有符号或无符号的 16 位浮点数表示。 因此解码器也需要支持两种模式。不仅如此，解码后的数据还需要满足 IEEE 754 half/binary16 格式 (见图 18) 。解码后，数据会以 32-bit 浮点形式返回给 shader。 BC6 的有符号和无符号版本的块模式相同。通常意义上，图 18A 对应有符号的浮点数格式，而 18B 对应无符号浮点数。不过在实践中，解码过程仅会使用整数算数运算。有符号、 无符号的解码模式仅在反量化期间对符号位的处理有所不同。\n [图18]: 16位精度的浮点数格式。A - signed, B - Unsigned.\n BC6H 共有14种块类型 (见表2 ) ， 只支持 1 到 2 个纹素组。PB 字段 (Partition ID) 始终为 5 位。 因此，只有前 32 个分区集可用。在大多数情况下 (模式 10 和 11 除外) ，端点使用增量编码存储：直接存储一个端点，再存储其他端点的偏移量。\n [表2]: BC6H 在不同块模式下的各字段的尺寸\n 上文中提到，即便最终值被解释为浮点数，解码和插值时也只会使用整数算数运算。其原理基于浮点数的编码 (图18) ，其中指数偏移值位于高位，小数部分 (隐含 1 ) 位于低位。将这样的二进制编码解释为整数也同样具有数学意义。尤其是，相邻的浮点数也具有相邻的整数表示。对于任意正的 $A$ 和 $B$ ， 如果 $A \u0026gt; B$， 那么二进制解释成为整数时也满足 $A\u0026gt;B$ 。代码 4 中展示了作用于浮点数的整数运算示例。当线性插值作用于具有不同指数偏移的浮点数的整数表示时，变换中将含有指数 (对数) 运算 (见图 19 ) 。\n   [图 19]: 插值示例。 “No cast” - 直接对浮点数使用线性插值，\u0026ldquo;Int. Cast\u0026rdquo; - 将浮点数转换为整型后再线性插值。\n 解码过程包含如下四步：\n  符号扩展和 delta 变换反置。 在有符号 BC6H 的情况下，压缩块中存储的所有端点和偏移量 (delta) 都进行了符号扩展 (符号位扩充到了高位) ，在无符号 BC6H 的情况下，只有偏移量进行了符号扩展。 此外，对于所有块类型，除了模式 10 和模式 11 之外，其余的端点都是通过将相应的偏移值添加到直接存储的端点来恢复的。 在模式 10 和模式 11 块中，所有端点都直接存储。\n  端点的反量化。 对于无符号 BC6H，反量化过程如 (((X \u0026lt;\u0026lt; 16) + 0x8000) \u0026gt;\u0026gt; uBitsPerComp)，其中 uBitsPerComp 是直接存储的端点的一个通道的大小 (bits) 。 边界条件 (zero, max value) 会单独考虑。\n  线性插值过程与 BC7 类似。考虑到有符号和无符号格式的存在，未量化值的范围为 -32768 到 65535。因此，插值器使用了17-bit的有符号代数运算。\n  最后的调整或反量化。 由于在 IEEE 754 中使用指数字段的最大值 (全部为 1) 来编码特殊的 INF/NaN 值，因此有符号格式下，插值之后的值按 $31/32$ 缩放，而无符号格式按 $31/64$ 缩放。 最终结果是一个合法的 16 位半浮点数。\n  ETC 系列 #  ETC (Ericsson Texture Compression) 格式最初是针对移动设备开发的。 今天 (译注：2014 年)，它是基于 Android 系统的设备的标准压缩方案。 OpenGL ES 和 WebGL 通过 (33) 和 WEBGL_compressed_texture_etc1 (34) 扩展支持 ETC1 格式。 ETC1 和 ETC2 规范则从 OpenGL 4.3 (35) 以来，成为 OpenGL Core Profile的一部分。\n第一个版本的压缩方案 PACKMAN 于 2004 年推出 (3)。 而后在 2005 年，被称为 iPACKMAN 的增强版被提出 (36)。 该版本更为人知的名称是 ETC1，广泛应用于移动设备。 该方案的后续发展，催生了 2007 年 ETC2 格式 (37)。\n [图20]: PACKMAN的核心思想。(来源: ETC2 论文 (37))\n ETC 压缩的核心是基于：人眼对亮度而不是色度更敏感这一事实。 因此，每个子块中仅存储一种基色 (ETC1/ETC2 由两个子块组成) ，但亮度信息是按每个纹素存储的 (见图 20)。 亮度偏移由单个整数值设置，最终会和每一个颜色分量相加。 一个子块内只有四种不同的亮度偏移可用，即只有四种不同的颜色可用。 可以认为这些颜色就是一个局部调色板。\nETC1 (38) (39) 和 ETC2 (40) (41) 的对应专利属于瑞典爱立信公司 (Telefonaktiebolaget L. M. Ericsson)。\nPACKMAN #  如果压缩块占用的位数与总线宽度相同，则可以避免管线停顿，从而简化硬件实现 (3)。由于移动设备在内存大小和总线宽度方面受到严格限制，PACKMAN 决定使用 2x4 的块。因此压缩块仅占用 32 位，压缩比为 4bpp，等于 BC1 的压缩比。\n块中仅存储一种 RGB444 基色 (译注：12bits) 。 其他颜色是通过改变纹素的亮度取得的 (译注：每个纹素 2bits， 共16bits) 。 虽然基本思想与 BC1 区别巨大，但解码过程却非常相似。 首先，恢复四色局部调色板。 然后根据索引表从该调色板中挑选颜色 (见图 21) 。 不过由于块尺寸小，只剩下 4 位用于存储亮度变化和调色板中的三种附加颜色。 因此，这 4 位的编码被直接用于指向预定义的亮度集 (见表 3) 。\n [图21]: PACKMAN 块解码示例。\n    Index 0 1 2 3 4 5 6 7     Luminance 00 2 4 6 12 8 19 28 42   Luminance 01 8 12 31 34 50 47 80 127   Luminance 10 -2 -4 -6 -12 -8 -19 -28 -42   Luminance 11 -8 -12 -31 -34 -50 -47 -80 -127     [表3]: PACKMAN 亮度码表的前半部分\n 可以看到，表 3 的下半部分是上半部分对应的负数，这点能用于简化解码器。 亮度组 8-15 (未在表中显示) 的值为0-7的 2 倍 。 这张表基于随机值生成，然后以将测试图像的误差降到最小为指标来进行优化 (3) 。\nETC1 ( iPACKMAN ) #  单一的低精度 (RGB444) 基色是 PACKMAN 中图像质量的主要限制因素。 这个问题在 ETC1 中得到了解决。\nETC1 瓦片的大小是 4x4，它由两个子块组成，和在 PACKMAN 中的块一样。 这些子块可以垂直或水平排列，为瓦片内基色的选择提供了更大的灵活性。 差分块 (Differential) 类型的引入，提升了精度。第一个子块的基色以 RGB555 精度存储，第二个基色存储 3bit 差异值。 将两种基色直接以 RGB444 格式存储的块称为独立块 (Individual) (见图 22) 。\n [图22]: ETC1 的块布局。\n    N 0 1 2 3 4 5 6 7     Luminance 00 2 5 9 13 18 24 33 47   Luminance 01 8 17 29 42 60 80 106 183   Luminance 10 -2 -5 -9 -13 -18 -24 -33 -47   Luminance 11 -8 -17 -29 -42 -60 -80 -106 -183     [表4]: ETC1 和 ETC2 的亮度码表\n 为了给块类型编码保留空间，亮度码本减少到 8 组，因此索引大小 (图 22 上的 T0 和 T1) 下降到 3 bits 。显然，码本中的值也经过重新计算 (见表 4) 。 因此腾出了 2 bits 空间，其中一个 “diff” 位用于指定块类型，另一个 “flip” 位指定子块的垂直或水平排列。\nETC2 #  差分模式和可旋转子块显着提高了图像质量。 然而在每个子块中只有一种基色可用，这导致颜色变化剧烈的图块会被压缩后会有更高的错误率。 此外，即使是平滑梯度在 ETC1 下也可能会产生问题。\nETC2 通过引入额外的块模式来解决上述问题。 这些新模式对在 ETC1 方案中无效的块进行编码，使得 ETC2 解码器与 ETC1 格式完全兼容。 当基色和偏移的总和溢出了 5 bit 的有效范围 [0, 31] 时，差分块中就会出现无效组合。 而这些 “无效” 块会使用一种新模式进行解码。 能够导致溢出的所有 R0 和 dR1 组合如表 5 示。\n   R0 dR1 R0, dR1 binary Encoded value     0 -4 00000 100 0000   0 -3 00000 101 0001   0 -2 00000 110 0010   0 -1 00000 111 0011   1 -4 00001 100 0100   1 -3 00001 101 0101   1 -2 00001 110 0110   29 3 11101 011 0111   2 -4 00010 100 1000   2 -3 00010 101 1001   30 2 11110 010 1010   30 3 11110 011 1011   3 -4 00011 100 1100   31 1 11111 001 1101   31 2 11111 010 1110   31 3 11111 011 1111     [表5]: 所有会导致溢出的 R0 和dR1 组合。\n 此类块中的有效载荷为 59 bits。 64 bits 中的 1 bit 用于 diff 位，8 bits 用于 R0 和 dR1 值，还剩 55 bits。 但是，可以使用 R0 和 dR1 的两个最低位来编码附加信息 (表 5 中的 Encoded value 列) 。\n绿通道中的溢出可用于编码另一种模式。 但载荷会更少，因为这个块在红色通道中一定不能有溢出。 否则会被视为前一种类型的块。 不过好在只占用了 1 bit。 R0 的两个最高位的不相等可以保证不会有溢出，这点可以在表 5 中观察到。在第二种模式中可以使用总共 58 bits。\n类似地，蓝通道溢出的第三种模式提供 57 bits 有效载荷。 表 6 中列出了所有块模式。\n    diff Overflow Overflow Overflow     Block mode diff R G B   Individual 0 - - -   59-bit mode (T-mode) 1 yes - -   58-bit mode (H-mode) 1 no yes -   57-bit mode (Planar mode) 1 no no yes   Differential 1 no no no     [表6]: ETC2 的块模式。\n 与独立模式和差分模式类似， T 形块和 H 形块都使用低 32 bits 存储索引表。但局部调色板使用的是不同的方式解码：$A(r_0, g_0, b_0)$ 和 $B(r_1,g_1,b_1)$ 以 RGB444 格式压缩在 T 块中， 其余 3 bits 则用于编码 d 值。A，B 的值将反量化为 RGB888。另外两个局部调色板的颜色用这个方法计算: $C0 = (A - (d, d, d))$，$C1 = (A + (d, d, d))$。因此局部调色板在色彩空间中呈现 T 形 (见图23) 。此模式适用于那些，大多数点位于一条线上，而有些纹素又是其他颜色的块。这里需要强调一点，距离 d 是间接存储的：3bits 字段用于存储查找表 (LUT) {3,6,11,16,23,32,41,64} 的索引，T 形块和 H 形块相同 。\n [图23]: T形块的原始块和调色板的颜色分布。(基于: ETC2 论文 (37) )\n H 模式与 T 模式非常相似，存储着颜色 A、B 以及 d 值的索引。但局部调色板中使用的是 c0、c1、c2、c3 而非 A、B、C0、C1 (见图 24) 。这些颜色在 RGB 空间中形成 H 形。此模式适用于那些，颜色位于两条线上的块。然而 H 形块的有效载荷要比 T 形块少 1 比特，但是又必须存储同样多的数据 (两个 RGB444 颜色和一个用于查询 d 值的索引) 。这里使用了 BC1 中的技巧 (译注：冗余编码) ，由于 H 形是对称的，因此 A、B可以互换，基于此就可以补足缺失 bit 的信息。\n [图24]: H形块的原始块和调色板的颜色分布。(基于: ETC2 论文 (37) )\n Planar 模式用于对平滑梯度编码。所有 57bits 用于存储 RGB676 格式的三种基色 C0、CH、CV (见图25) ，所有纹素的颜色使用线性滤波方程 3.1 计算，其中 X 和 Y 的范围为 [0, 3]。 $$ C(x, y) = \\frac{x(C_H-C_0)}{4} + \\frac{y(C_V-C_0)}{4} + C_0 \\tag{3.1} $$  [图25]: ETC2-Planar 块的基色坐标以及解压示例。\n 除了 RGB 版本，OpenGL 中还有一个\u0026quot;穿通 Alpha\u0026quot; 版本的ETC2： 一个 RGBA8881 纹理。其中没有独立块类型，因此仅仅通过是否溢出来区分 T、H 和 Planar 模式。Diff-bit 用于指定差分子模式。如果是 “1” ，差分块像之前一样解压，如果是 “0”，索引 “10” 保留给全透明颜色 (见表 7) 。 T、H 和Planar 块的解码过程保持不变。\n   N 0 1 2 3 4 5 6 7     Luminance 00 0 0 0 0 0 0 0 0   Luminance 01 8 17 29 42 60 80 106 183   Luminance 10 T T T T T T T T   Luminance 11 -8 -17 -29 -42 -60 -80 -106 -183     [表7]: ETC2 “穿通 Alpha” 的亮度码表。(T - 透明 (transparent) )\n EAC #  ETC2 无法维护许多类型纹理所必需的、完整的 alpha 通道。此外，ETC2 不支持对二分量图像进行高质量的压缩，因此不适用于法线贴图。对于这种情况，可以使用名为 EAC 的 64bits 块。EAC 以高精度编码单通道的 4x4 的块。OpenGL中，还定义了如下包含 EAC 作为子块的格式：\n COMPRESSED_RGBA8_ETC2_EAC /COMPRESSED_SRGB8_ALPHA8_ETC2_EAC (类似于BC3) —— 是一个 128 bits 块，一个 64 bits ETC2 块存储 RGB 通道，一个 64 bits EAC 块存储 alpha 通道。 COMPRESSED_R11_EAC / COMPRESSED_SIGNED_R11_EAC (类似BC4) —— 是一个存储红通道的 64 bits EAC 块。 COMPRESSED_RG11_EAC / COMPRESSED_SIGNED_RG11_EAC (类似BC5) —— 是一个 128 bits 块，由两个 64 bits EAC 块组成，用于存储红色和绿色通道。  简洁起见，这里将仅详细描述COMPRESSED_RGBA8_ETC2_EAC 块。 所有 ETC 和 EAC 选项在 OpenGL 4.4 Core Profile 规范 (42) 中有详细描述。\nEAC 压缩方案复用了 ETC 中的思路，但针对单分量图像：整个 4x4 切片仅存储一个基值，并且每纹素索引用于调制其亮度 ( $Luninance$ ) (见图 26) 。 和上文中一样，有一个预定义的亮度码本 (见表 8) 。 特定亮度集 (N) 的索引直接存储在压缩块中。唯一新增的就是亮度修饰符的值需乘以 Mul 值，Mul值也直接存储在压缩块中。纹素值使用公式 3.2 计算，其中 clamp255 将值限制在 [0, 255] 范围内。 $$ A = clamp255(base+Mul \\times Luninance) \\tag{3.2} $$ 基值以 8 bits 精度存储 (见图 26) 。 使用了 3 bits 索引，因此局部调色板中最多可以使用八个不同的值。\n [图26]: EAC 的块布局。\n    N 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15     Luminance 000 3 -3 -2 -2 -3 -3 -4 -3 -2 -2 -2 -2 -3 -1 -4 -3   Luminance 001 -6 -7 -5 -4 -6 -7 -7 -5 -6 -5 -4 -5 -4 -2 -6 -5   Luminance 010 -9 -10 -8 -6 -8 -9 -8 -8 -8 -8 -8 -7 -7 -3 -8 -7   Luminance 011 -15 -13 -13 -13 -12 -11 -11 -11 -10 -10 -10 -10 -10 -10 -9 -9   Luminance 100 2 2 1 1 2 2 3 2 1 1 1 1 2 0 3 2   Luminance 101 5 6 4 3 5 6 6 4 5 4 3 4 3 1 5 4   Luminance 110 8 9 7 5 7 8 7 7 7 7 7 6 6 2 7 6   Luminance 111 14 12 12 12 11 10 10 10 9 9 9 9 9 9 8 8     [表8]: EAC 的 Mod 值\n 例如，考虑一个压缩块，其中 base = 0b11011110，mul = 0b1010，N = 0b1101，特定纹素的索引为 0b0012。转换为十进制后，base = 222，mul = 10，N = 13。在此示例中 N 对应于亮度集 {-1, -2, -3, -10, 0, 1, 2, 9} (表 8 中的第 13 列) ，纹素索引 0012 从该集合中选取 mod 值，mod = -2。将这些值代入公式 3.2 后，$A=clamp255(222 + 10 × (-2))$ ，即， $A=202$。\nPVRTC 系列 #  PVRTC (PowerVR Texture Compression) 格式 (14) 是由 Imagination Technologies (43) (44) (45) (46) 持有专利，专为 PowerVR 图形核心系列设计的。 用于 Apple 移动设备，例如 iPhone 和 iPad。 不久前针对新的图形核心，引入了增强版的 PVRTC2。 OpenGL ES 中 IMG_texture_compression_pvrtc (47)、IMG_texture_compression_pvrtc2 (48) 和 EXT_pvrtc_sRGB (49) 扩展支持这两种格式。 对应的的 WebGL 草案扩展为 (50)。\n相较于本文中的其他技术，PVRTC 或许是最封闭的。除了 Simon Fenney (14) 最早的关于 PVRTC 论文 《使用低频信号调制的纹理压缩》(Texture Compression using Low-Frequency Signal Modulation) 以及Imagination Technologies 网上的几篇博客之外(51) (52) (53)，没有其他公开的技术信息了。即使是 OpenGL 和 WebGL 的扩展标准中也没有提供任何实现细节。尽管如此，crunch 纹理压缩库的开发者 R.Geldreich 为 PVRTC 压缩器的实现也作出了相当一部分努力 (54) (55)。\nPVRTC 压缩技术比较有趣，和前述中提到的技术有很大不同。严格来讲，PVRTC 并非基于块的编解码器。核心思想与小波压缩有一些共通之处，即整张图像被分成低频和高频信号。低频信号由两张低分辨率图像 A 和 B 呈现，在两个维度上都按比例缩小了 4 倍。高频信号是完整分辨率低精度的调制信号 M。要解码整张图像，首先应放大图像 A 和 B，然后使与调制信号 M 混合，其中调制信号 M 指定了每个纹素的混合权重 ( 见图 27) 。\n [图27] : PVRTC的核心思想 (源自: PVRTC 的论文 (14))\n 有别于其他压缩方案，PVRTC 利用了跨块边界的颜色的相似性。因此这种方案本身支持平滑梯度。同时没有块伪影。此外，它还利用了实际纹素坐标与其颜色值的相关性。类似 BC 和 ETC 的方案利用了块内颜色的相似性，但只关注于颜色集合，而非特定颜色的位置。 也就是说，图块内的所有纹素都可以随机重排，同时 BC 编解码器仍可以生成完全相同的局部调色板。 但 PVRTC 可能会丢失压缩纹理中的一些高频细节。\nImagination Technologies 已将对 PVRTC2 的支持添加到其最新的 PowerVR 图形核心系列 – PowerVR Series5XT 和 PowerVR Series6 (51) (52) (53)。 PVRTC 和 PVRTC2 两个版本都有 4bpp 和 2bpp 模式。\n随着 PVRTC2 的发布，产生了新的命名混乱。 在原始 PVRTC 格式引入时，PVRTC2 和 PVRTC4 缩写分别成为 2bpp 和 4bpp 模式的流行标签。 但由于缩写之一与新格式的名称相同。 因此建议使用以下别名：PVRTC 4bpp、PVRTC 2bpp、PVRTC2 4bpp、PVRTC2 2bpp (或 PVRTCII 2bpp/4bpp) 。\nPVRTC 4bpp #  从性能的角度来看，访问三个不同的图像来解包单个 texel 或 tile 看起来不是很妙。 因此，所有数据以 64 比特的块存储在一处。 每个块由图像 A 的一个像素、图像 B 的一个像素和相应的 4x4 调制系数区域组成 ( 见图 28) 。\n [图28]: PVRTC 4bpp 的块布局。\n 任意 A 和 B 颜色都能以 RGB 或 RGBA 格式存储。 两个颜色字段中的最高位决定使用哪种格式。 但是，色域 A 比色域 B 小一位。因此，色 A 可以用 RGB554 或 ARGB3443 编码，色 B 用 RGB555 或 ARGB3444 编码。\n通常来讲，必须读取四个相邻的 PVRTC 块才能对任意纹素进行解包 (见图 29) 。 因此需要恢复已经放大的图像 A 和 B 的相应区域。 4 个相邻 PVRTC 块的包含的信息就能够解码一个 5x5 块。 解码示例如图 30 所示。\n [图29]: 可以使用 4 个相邻 PVRTC 块解码的纹理区域。\n  [图30]: PVRTC 4bpp 解码示例。\n 放大过程使用双线性滤波。然后使用逐纹素索引确定图像 A 、B 的混合权重 (见表 9 ) 。Mode-bit (见图 28) 用于穿通 alpha 模式。此模式允许对 1 位 alpha 通道进行编码，而不损失 RGB 通道的精度。 当模式位为“1”时，索引“10”保留给全透明值。\n   Index (modulation data) Modulation value (Mode=0) Modulation value (Mode=1)     00 0/8 0/8   01 3/8 4/8   10 5/8 4/8 (+ «punch through alpha»)   11 8/8 8/8     [表9]: PVRTC 中使用的模式值\n 需要说明的一点是，尽管基本思想不同，但 BC1 方案可以被视作 PVRTC 的一个使用阶跃函数执行放大的特例。\n初看起来读取四个块可能对性能影响会很大。 但其实纹理缓存减少了负面影响，因为相邻区域需要更少次数的内存访问。 此外，双线性以及更复杂的过滤类型对于 3D 渲染几乎是不可或缺的。因此，每个纹理获取操作至少需要 2x2 源纹素。 当这些纹素位于相邻的块中时，在 BC/ETC 压缩的情况下也必须读取两个或四个块。 对于任何 PVRTC、BC 或 ETC 方案，最坏的情况都需要四个块。\n由于单块影响的面积大，因此压缩过程会复杂一些。 修改任意基色 (A 或 B) 会改变最近的 7x7 区域内的所有纹素 (见图 31) 。此功能使得动态纹理合成和创建纹理图集变得更加复杂。因此，纹理图集的各个元素必须有边界填充。\n [图31]: 一个 PVRTC 块影响的区域。\n PVRTC 2bpp #  PVRTC 有一种压缩比极高的模式，仅有 2bpp。它与 4bpp 模式相似，并且使用相同的块布局 ( 见图 32) 。不过图像 A 和 B 在水平维度上又缩小了一半。因此 ，32 位调制字段必须保存 8x4 纹素的调制信息。Mode-bit 指定了调制数据的编码。 如果是 $0$，则每纹素存储 1-bit 在调制字段中。 否则，将存储 2-bit 索引，但仅对以棋盘模式排列的一半纹素。随后通过平均相邻的两个或四个调制值来计算剩余纹素的调制值。\n [图32]: PVRTC 2bpp 块的布局。\n PVRTC 2bpp 解码的简化示例如图 33 所示。假设所有四个压缩块中的 Mode位均为0。\n [图33]: PVRTC 2bpp (Mode = 0) 解码示例。\n PVRTC2 4bpp #  PVRTC2 增强了压缩质量，并消除了 PVRTC 的一些不足之处。例如，PVRTC2 支持 NPOT 纹理 (Non Power Of Two) ，两个维度的分辨率都可以不为 2 的幂。此功能与压缩方案没有直接关系，但需要一定的硬件支持。 尤其是，硬件应该能够正确计算被请求的压缩块的地址。\n类似于之前的做法，可以通过引入新类型的块或解码模式以改善质量。在 PVRTC 中，基色 A 和 B 各自可以独立选择使用 RGB 或 ARGB 存储格式。 然而通常是两种颜色具有相同格式。因此，在 PVRTC2 中仅使用一个位 (Opacity) 来指定两种颜色的格式，第二个位 (Hard) 用于编码新模式 (见图 34) 。\n [图34]: PVRTC2 块的布局。\n “Hard”位和“Mode”位一起能够表示四种解码模式 (见表 10) 。\n   «Hard» bit «Mode» bit Decoding mode     0 0 标准双线性插值   0 1 穿通 alpha   1 0 无插值   1 1 局部调色板     [表10]: PVRTC2 4bpp 的块模式。\n \u0026ldquo;标准双线性插值\u0026rdquo; 和 \u0026ldquo;穿通Alpha\u0026rdquo; 的解码方式与上文提到的 PVRTC 相同，不过在 alpha 模式中会有一些变化。在 \u0026ldquo;穿通 alpha\u0026rdquo; 模式下透明的索引也会将颜色值设为 0。 这其实是预乘 alpha (参阅 BC2 块 (DXT2/DXT3)) ，方便进行混合和过滤。另一个变化与 alpha 值反量化过程有关。 现在，A 和 B 图像的 alpha 值以些微不同的方式转换为 8 比特格式，如代码 5 所示；AlphaA3、AlphaB3 – 是 3 bit 打包的 alpha 值，而 AlphaA8、AlphaB8 – 是未打包的 8 bit 值。如果仔细观察，会发现 AlphaA8 不会等于 “255”，AlphaB8 不会等于 “0”，不过倒也不是什么问题。\n [代码5]: PVRTC2 解压时 Alpha 转换至 8 位。\n 新的模式，将 \u0026ldquo;Hard \u0026ldquo;位设置为 \u0026ldquo;1\u0026rdquo;，简化了纹理图集的创建，并改善了某些对 PVRTC 块来说相对困难的情况下的压缩质量。在 \u0026ldquo;无插值 \u0026ldquo;模式下，图像A和B被放大，没有插值。相反，所有相应的像素都有相同的基础颜色。随后的解码过程与PVRTC中的解码过程相同。必须指出的是，\u0026rdquo; Hard \u0026quot; 标记会影响偏移量为 [2, 2] 的 4x4 纹素区域 (见图35) 。对于边界块，\u0026rdquo; Hard \u0026quot; 标志区域是环绕 ( wrap )，就和环绕的纹理映射一样。\n [图35]: Hard 标记影响的区域。\n 这种模式的解码例子见图 36。其类似于 S3TC 压缩。事实上，如果所有相邻的块都有标志 Hard=1 和 Mode=0，那么对应于一个 PVRTC 块的纹理解码将与 BC1的解码方案相同。因此，这种模式可用于对纹理图集中单个元素的边界进行编码。\n [图36]: PVRTC2解码示例, Hard = 1, Mode = 0 (无插值)。\n 在 \u0026ldquo;局部调色板 \u0026ldquo;模式下 (Hard=1，Mode=1) ，A和B不会混合。局部调色板由来自四个相邻的 PVRTC2 块的 A 、 B 对填充，共有8种颜色。但一个索引的大小只有2 比特，这意味着这 8 种颜色中只有 4 种可用于每个特定的纹素。图 37 显示了每个纹素可用的颜色集，其中描述了解码所需的四个 PVRTC2 块。P 块指定了灰色阴影区域纹素的解码模式。每个块中存储的 A 和 B 的颜色分别表示为 Pa, Pb, Qa, Qb, Ra, Rb, Sa, Sb。每一个纹素的颜色都可以在放大的 4x4 区域内描述。唯一的例外是最左上方的texel P* ：它的颜色是由 Pa 和 Pb 混合得到的。\n [图37]: 逐像素可访问的局部调色板模式。 (来源: 美国专利 8526726 (46))。\n ASTC 格式 #  ASTC (自适应可扩展纹理压缩) 是由 ARM 和 AMD 联合开发，并于2012年提出的(56)。格式规范 (57) 被 Khronos 联盟批准并在 OpenGL 中采用。在 OpenGL 和 OpenGL ES 中对应的扩展为KHR_texture_compression_astc_hdr (58)。从 Mali-T628 和 Mali-T678 开始，所有 ARM 图形核心都有 ASTC 硬件支持(59)。专利 (60)(61)(62)(63) 归 ARM 所有。尽管如此，仍需要指出，ASTC 是完全开放和免专利费的。\n以下每个用例都对压缩方案有自己的要求：\n 支持从 1 到 4 个分量的纹理。虽然单通道纹理也可以使用BC7、PVRTC2或ETC2来存储，但空通道上大量bit被浪费掉了。 在通道之间数据无相关性的情况下，拥有可以接受的质量。这对于法线图和 RGBA 图像来说非常重要。 支持 LDR 和 HDR。BC6H可用于HDR纹理压缩，但它不支持alpha通道。 跨平台。特别是：PVRTC 只在 iOS 平台上可用，BC6H/BC7 在移动设备中缺失，ETC 不被桌面级 GPU 所支持。对于跨平台应用程序的开发者来说，有诸多不便。 比特率/质量比的灵活性。根据纹理类型，不同程度的压缩伪影是可以接受的，因为不同图像的可压缩性是不同的。前文中提到的格式里，能提供的比特率/质量选项的不超过两个 (BC1/BC7或PVRTC 4bpp/2bpp) 。如果不能使用 5bpp 的压缩级别 (如果4bpp的质量略显不足) ，就必须使用8bpp的选项。带宽增加了一倍，但质量却没有明显改善。 支持 2D 和 3D 纹理。  新的压缩方案是在考虑到所有这些要求的情况下制定的。ASTC格式有一个固定大小的 128 位块。然而，对于 2D 纹理，编码的瓦片尺寸从4x4到12x12 纹素不等，3D 纹理则是从3x3x3到6x6x6。所有支持的瓦片尺寸和相应的比特率可以在表11中找到。“Increment”一栏显示，比特率可以在非常细致的级别中进行调整。在ASTC 规范中，瓦片尺寸也被称为块足迹 (block footprint)。\n   № 2D textures   3D textures       Tile size Bit rate Increment Tile size Bit rate Increment    1 4x4 8.00 bpp 125% 3x3x3 4.74 bpp 133%   2 5x4 6.40 bpp 125% 4x3x3 3.56 bpp 133%   3 5x5 5.12 bpp 120% 4x4x3 2.67 bpp 134%   4 6x5 4.27 bpp 120% 4x4x4 2.00 bpp 125%   5 6x6 3.56 bpp 114% 5x4x4 1.60 bpp 125%   6 8x5 3.20 bpp 120% 5x5x4 1.28 bpp 125%   7 8x6 2.67 bpp 105% 5x5x5 1.02 bpp 120%   8 10x5 2.56 bpp 120% 6x5x5 0.85 bpp 120%   9 10x6 2.13 bpp 107% 6x6x5 0.71 bpp 120%   10 8x8 2.00 bpp 125% 6x6x6 0.59 bpp -   11 10x8 1.60 bpp 125%      12 10x10 1.28 bpp 120%      13 12x10 1.07 bpp 120%      14 12x12 0.89 bpp -        [表 11]: ASTC 块大小和压缩比。\n ASTC是文章中描述的最为灵活的格式，因为它支持 LDR、HDR、2D 和 3D 纹理，最多有4个通道。甚至支持低于 1bpp 的比特率。\n概念上讲，ASTC 类似于 S3TC/BC7：一个压缩块中最多存储四个端点对和插值权重，只支持预定义的分区，特定的分区由分区ID指定，也存储在一个块中。在弱相关的情况下，该通道会存储一个独立的索引表。每个独立的编码被称为一个平面。\n或许 ASTC 最主要、最有趣的创新是用小数位编码整数值的技术，称为BISE。同时，BISE可以在硬件中有效实现。\n有界整数序列编码 (Bounded Integer Sequence Encoding (BISE)) #  有界整数序列编码，或称 BISE，解决了如下抽象问题：从大小为 $N$ 的字母表中给定等概率的符号序列， 找到一种编码，使得能够在常数时间复杂度内使用最少的硬件消耗提取第 $i$ 个符号，并允许相同硬件设计能够用于多种不同大小的字母表，同时具备存储效率(64)(65)。\n例如，考虑一个由 5 个整数组成的序列，其中每个整数可以是 0，1 或 2（译者注：5 位的 3 进制数）。使用标准二进制编码时，需要为每个值分配 2 位，总共 10 位。但不同序列的数量是 $3^5=243$，小于 $2^8=256$。因此，可以用 8 比特对整个序列进行编码，每个值的比特率为 1.6。换句话说，可以用8比特来表示5 位的 3 进制数。\n现在，考虑任意长度的序列，其中每个值都属于范围$[0, N-1]$，其中 $N=3*2^n$。每个值都可以用一个三进制位和 n 个比特来表示。假设 $N=12$，那么满足该条件的任何值都可以用以下形式表示: $X = t2^2 + b_{1}2^1 + b_{0}2^0$，其中 $t$ 是一个三进制位，$b_0$ 和 $b_1$ 是比特位。整个序列可以被划分为五组值，最后一组会在必要时填充 0 。二进制形式下，一个特定的组可以表示为一个比特串 $t_4B_4t_3B_3t_2B_2t_1B_1t_0B_0$，其中 $t_i$ 是一个三进制位的 2 比特表示，$B_i$ 是一个值的剩余比特位( 译注: 即上文中的 $b_0$ 和 $b_1$)。只要三进制位与比特信息保持这种相关性，就可以用比特串 $T_{[7]}B_4T_{[6:5]}B_3T_{[4]}B_2T_{[3:2]}B_1T_{[1:0]}B_0$ 保存这五组值。其中 $T_{[i:j]}$ 为 $T$ 的各个比特，这段数据要比原先短 2 比特。\n事实证明，这种编码能够保留尾部的零。例如，如果我们序列中的最后一组被填充了两个零 (所以$t_4B_4$和$t_3B_3$是零) ，那么 $T_{[7]}B_4$ 和 $T_{[6:5]}B_3$ 是零，它们不需要被存储。因此，任何长度的序列，假如其数值范围从 $0$ 到 $3*2^n-1$，都可以用接近于理论上的最小的比特率进行编码。同时，其中的任意值能以最小的硬件消耗容易的提取出来。\n同样的推理也可以应用于$N=5*2^n$的序列。这里，3 个五进制数 (基数为5的数字) 可以用 7 位来编码，因为 $5^3=125$ 小于 $2^7=128$ 。因此，使用三进制数和五进制数的BISE技术在存储方面都是是有效率的 (见图38) 。\n [图38]: ISE 与 二进制编码的存储效率。(来源: CGDC2013 的 ASTC intro (65))\n ASTC 压缩方案使用 BISE 对颜色端点和插值权重进行编码。而且它还为插值权重提供了硬件友好的二次方除数。一个三进制位编码为三个权重 ${0, ½, 1}$ 中的一个，一个五进制位编码为 ${0, ¼, ½, ¾, 1}$ 这五个中的一个。此外，BISE允许对端点的精度进行细致的改变。表12中描述了所有使用三进位或五进位的彩色端点编码的情况。\n   Range Number of used digits Number of used digits Number of used digits Bit size Bit size      Trits Quints Bits Effective Theoretical Minimum   0..5 1  1 ~ 2.60 2.58   0..9  1 1 ~ 3.33 3.32   0..11 1  2 ~ 3.60 3.58   0..19  1 2 ~ 4.33 4.32   0..23 1  3 ~ 4.60 4.58   0..39  1 3 ~ 5.33 5.32   0..47 1  4 ~ 5.60 5.58   0..79  1 4 ~ 6.33 6.32   0..95 1  5 ~ 6.60 6.58   0..159  1 5 ~ 7.33 7.32   0..191 1  6 ~ 7.60 7.58     [表12] : 用于颜色反量化的参数。\n BISE解码之后，解包的数值被反量化为标准范围[0, 255]。\n其他改进 #  ASTC 还改进了分区模式。BC6H 和 BC7 压缩方案也使用了预定义的分区集表 (见图13) ，但这种方法不适合 ASTC，因为它支持大量的瓦片尺寸，支持更多的区域，还增加了分区ID字段的大小 (10位，而BC7是6位) 。ASTC 的分区模式是用一个特殊的哈希函数生成的，它为每个纹素分配一个分区索引。这个函数将纹素在瓦片中的位置、分区ID、瓦片大小和分区数量作为输入，并输出一个分区索引。该函数很简单，可以用硬件实现。该函数也用于 3D 纹理。图 39 中描述了 8x8 瓦片的所有分区模式。\n [图39]: ASTC 8x8 块的分区集。(来源: ARM Mail Graphics blogs (66))\n ASTC 的一个更显著的特点是内插权重的编码方式。S3TC 系列方案使用每个顶点的索引来设置插值权重。根据块的类型，索引的大小可以是 2、3 或 4 比特。然而，对于 12x12 瓦片来说，即使每个像素使用 1bit 的索引，也无法存储在一个 128 位块。因此，ASTC 为权重和纹素提供独立的网格大小。例如，对于 12x12 的瓦片，只能存储 4x6 的权重网格。在解码阶段，权重网格被双线性地放大到瓦片大小。不过虽然看起来像，但是它和简单的瓦片缩放并不一样。例如，平滑的梯度通常可以用一个小的权重网格来表示，如 2x2。因此有更多的比特可用于端点。同时尖锐的边缘和颜色过渡可以用适合的分区模式进行编码。权重网格的大小是根据每个块来选择的。因此某些具有强烈垂直特征的瓦片，可以用 4x2 或 8x4 的权重网格进行编码。\n所有这些配置数据 (网格大小、分区数量、端点格式) 都必须存储在一个压缩块中。虽然不得不牺牲一些颜色数据位，因而可能降低图像质量，但这种方法带来了很好的灵活性，并且大大增强了压缩质量。ASTC 允许在每个块中进行不同的比特权衡，任意瓦片都可以在分区、端点和权重之间的分布选用最合适的比特分布进行编码。事实证明，即使在较低的比特率下，ASTC也能够提供比 PVRTC、BC1-BC5 和 ETC 更好的质量。PSNR (译注：峰值信噪比) 增益平均为 1.5dB 至 2dB，大多数观察者 (译注：推测此处数值为 ASTC 对比其他压缩格式获得的增益 ) 大约能察觉 0.25dB 的增益。BC6H的质量与之相当，而 BC7 平均比 ASTC 多出0.5dB。不过在 8bpp 时，ASTC 和 BC7 压缩图像的 PSNR 质量都在45dB左右，这种差异很难从视觉上发现 (56) 。\n此外，ASTC 是第一个支持 3D 纹理的标准压缩方案，它利用了所有三个维度的颜色相关性。nVidia 的 OpenGL(26)的 VTC 扩展也是针对3D纹理的，但它只是把一个3D瓦片分成2D片，使用BC1方案进行压缩。ASTC 则使用 3D 权重网格和分区，利用分区模式生成器来压缩整个3D瓦片。不过权重网格是用单线法而非三线插值法进行放大的 (67) 。整个 3D 瓦片的压缩比分片压缩的 PSNR 高出 2dB (68) 。\n另外，ASTC 的所有特征都是 \u0026ldquo;正交 \u0026ldquo;的，即任何特征都可以独立使用，例如可以用两个弱相关的HDR通道来压缩一个三维纹理。\nASTC 块 #  首先是一些全局解码参数，这些参数对任何特定的纹理都是一样的。因此，没有必要在压缩块中存储这些。\n  动态范围 (LDR/HDR)\n  纹理尺寸(2D/3D)\n  瓦片尺寸\n  输出色彩空间 (sRGB/RGB)\n  而每块指定的数据如下。\n  权重网格大小\n  权重范围 (用于BISE解码\n  权重值\n  分区的数量\n  分区模式 ID\n  颜色端点模式\n  颜色端点数据\n  平面的数量 (1或2)\n  平面到通道的分配\n  纹理可以被编码为单通道、双通道、三通道或四通道图像。但解码后的值总是以 RGBA 格式输出。在LDR sRGB 模式下，颜色值以 8 位整数返回，否则以 16 位浮点数返回。图40展示了 ASTC 块的布局。\n [图40]: ASTC 块的布局。\n 除了 \u0026ldquo;BlockMode \u0026ldquo;和 \u0026ldquo;Part \u0026ldquo;字段，所有字段的长度都是可变的。\n\u0026ldquo;Part\u0026rdquo; 字段指定了分区的数量 (减一) 。在双平面模式下，分区的数量必须是1、2或3。\u0026ldquo;BlockMode\u0026rdquo; 字段指定了平面数、权重范围和权重网格的大小。\u0026ldquo;ConfigData\u0026rdquo; 和 \u0026ldquo;MoreConfigData\u0026rdquo; 字段指定每个端点对的端点模式。\n如果是 2D 瓦片，\u0026ldquo;BlockMode\u0026rdquo; 由5个字段组成。A、B、R、D、H (表13) 。 特殊的 \u0026ldquo;void-exten\u0026rdquo; 模式有一个单独的编码，用于单色瓦片。void-exten 块还允许识别附近的单色区域。可以缩短获取相同的块的过程，并进一步减少内存带宽占用。\n [表13] : 2D 块的 BlockMode 字段布局。(源自: ASTC 技术手册 (57))\n A、B 字段分别指定权重网格的宽度 (N) 和高度 (M) 。D位 (双倍) 被设置为表示双平面模式。R字段 (范围) 和H位 (高精度) 指定重量范围 (见表14) 。注意，由于R字段的编码，为了避免产生歧义，位 $R_1$ 和 $R_2$ 不能同时为零， (见表13) 。\n [表14] : 权重编码的参数\n ConfigData 和 MoreConfigData 指定了端点对的编码，每个端点对都可以有独立的编码模式。共有16种编码模式：10 种 LDR 格式和 6 种 HDR 格式。然而，HDR 纹理可以使用其中任何一种。所有这些端点格式都是基于以下基本方法之一:\n 独立性。两个k位的值直接存储。 base + offset (类似于ETC的差分编码) 。第一个值为base, 用 (k+1) 位存储。第二个值为 offset, 用 (k-1) 位存储。 base + scale。两个RGB值由四个数值 (R、G、B、s) 表示。颜色一等于 (R，G，B) ，颜色二等于 (sR，sG，sB) 。  在 ASTC 规范 (57) 和 ASTC 原始论文 (56) 中有所有端点模式和 BISE 编码的详细描述。\n从概念上讲，ASTC块的解码是这样进行的。BlockMode 字段用于确定权重范围和权重网格的大小。权重数据从压缩块的尾部读取，并使用BISE进行解包。之后，权重被反量化为 [0, 64] 范围。如果权重网格的尺寸小于瓦片的尺寸，则使用双线性插值进行升格。\n之后，Part 字段用于指定分区的数值。分区模式 ID 从块中读出，然后针对每个纹素生成哈希作为分区索引。\n给定分区数量，还可以利用 ConfigData 和 MoreConfigData 字段计算标量的总值，该值会被用于端点编码 (端点可以有不同数量的通道，不同的端点存储模式下会使用不同数量的值) 。然而，这些标量值的范围在 BISE 解码时必须是已知的，因为该范围并没有被明确指出。在权重和分区数据解码阶段之后，就可以知道可用于彩色端点数据的比特数。颜色端点的值会使用适用于上述比特数的最大范围的值来存储。端点被解压缩和反量化。\n端点对会根据分区索引来选择。端点的颜色则使用插值权重来混合。\n简要描述上文讨论的所有纹理压缩格式 #   [表15] : 本文所讨论的所有纹理压缩格式的简述 (已经弃用的方案使用灰色背景)\n 对压缩格式的选择受目标硬件限制。例如，S3TC 系列只在 PC 上可用。根据特定的移动平台，可能支持 ETC 或 PVRTC (一些设备支持 BC1-BC5，但并不常见) 。只有一些最新的移动GPU支持ASTC格式。\n在 S3TC 系列中：\n BC7能够为RGB和RGBA纹理提供最好的质量，可以完全取代BC2和BC3 BC1 可用于较低质量的RGB压缩 BC4 和 BC5 用于单通道和双通道纹理 BC6H 用于 HDR 纹理  PVRTC 被 PVRTC2 所取代，后者不仅提高了质量，解决了其前身的一些问题。PVRTC2 也支持 RGB 和 RGBA 纹理。\nETC2 完全取代了 PACKMAN 和 ETC 格式，但只支持RGB纹理。另外，ETC2 和 EAC 块的某些组合提供与 BC1-BC5 格式相仿的功能。\nASTC格式支持任何类型的纹理，并提供多种比特率以供选择。\n结论 #  纹理压缩在现代计算机图形中占重要地位。现如今，许多智能手机的显示屏已经具有 FullHD 分辨率 (1920x1080) ，而桌面 GPU 的则面向的是 4K 和 8K 这样的超高清分辨率 (分别为 3840x2160 和 7680x4320) ，大大增加了内存带宽要求。预计纹理的分辨率也会增长，高压缩比变得越来越重要。\n由于不同纹理的可接受的压缩伪影水平不同，针对每种纹理，需要选择能够保证图像质量的前提下，可以减少内存带宽的合适的压缩比。在可选格式中，ASTC 是最好的一种。虽然桌面 GPU 尚不支持，但我们相信 ASTC 会因为它的灵活性和质量而取代所有其他格式。在任何给定的比特率下，ASTC 的质量都优于除了 BC7 外的所有其他格式。广泛采用 ASTC 也将简化跨平台应用开发。\n至于纹理压缩的未来，目前的策略可能朝着增加块和瓦片的大小的方向发展。也有可能使用可变比特率 (VBR) 方案，进一步提高压缩的灵活性。\n这项工作由 AMD 公司 (Advanced Micro Devices, Inc.) 支持，并获得了俄罗斯联邦政府 074-U01号财政拨款的部分支持。作者在此感谢 Vladimir Kibardin 帮助撰写文章的英文版本。\n译者在此感谢原作者 T. Paltashev 与 I. Perminov 在翻译过程中提供的帮助。特别感谢 Zhongliang Chen 在校对过程中给出的专业建议和帮助。\nReferences #    McDonald John. Eliminating Texture Waste: Borderless Ptex. 2013. GDC2013.\n  Inada T. and McCool M. D. Compressed lossless texture representation and caching. New York, NY, USA : ACM, 2006. Proceedings of the 21st ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware. pp. 111-120.\n  Strom Jacob and Akenine-Moller Tomas. PACKMAN: Texture Compression for Mobile Phones. . New York, NY, USA : ACM, 2004. ACM SIGGRAPH 2004 Sketches.\n  van Waveren, J.M.P. id Tech 5 Challenges: From Texture Virtualization to Massive Parallelization. Siggraph. Part of Beyond programmable shading course. 2009.\n  Olano M., et al., et al. Variable Bit Rate GPU Texture Decompression. 2011. Computer Graphics Forum, vol. 30, pp. 1299–1308.\n  Strom Jacob and Wennersten Per. Lossless Compression of Already Compressed Textures. Strom Jacob and Wennersten Per. s.l.: Eurographics Association. High Performance Graphics, 2011, pp. 177-182.\n  Vorobev Andrey. 3DGiTogi iyul 2001 goda — Vliyanie tekhnologii S3TC (FXT1) na kachestvo i skorost [3DGiTogi ]uly 2001 - impact of technology S3TC (FXT1) on quality and speed]. 2001. Available at: http://www.ixbt.com/video/0701i-video-s3tc1.html\n  WesleyandSmith Ian N., Liska Milos and Holub Petr. Implementation of DXT Compression for UltraGrid. Implementation of DXT Compression for UltraGrid. s.l. : CESNET, 2008.\n  Petr Holub, et al., et al. GPU-accelerated DXT and JPEG compression schemes for low-latency network transmissions of HD, 2K, and 4K video. Future Generation Computer Systems, vol. 29, № 8, 2013, pp. 1991-2006.\n  van Waveren, J.M.P. Real-Time DXT Compression. Id Software. 2006. Tech. rep.\n  FastDXT. Available at: http://www.evl.uic.edu/cavern/fastdxt/\n  Fast CPU DXT Compression. 2012. Available at: http://software.intel.com/en-us/vcsource/samples/dxt-compression\n  Ilya Perminov. Povyshenie effektivnosti obrabotki dinamicheski szhimaemykh tekstur [Improvement of Dynamic Texture Compression]. Nauchno-tekhnicheskiy vestnik informatsionnykh tekhnologiy, mekhaniki i optiki [Scientific and Technical Journal of Information Technologies, Mechanics and Optics], vol. 6 (88), 2013 г., стр. 164-165.\n  Fenney Simon. Texture compression using low-frequency signal modulation. Eurographics Association, 2003. Graphics Hardware. pp. 84-91.\n  Rover Camera Instrument Description. Available at: http://pdsimg.jpl.nasa.gov/data/mpfr-m-rvrcam-2-edr-v1.0/mprv_0001/document/rcinst.htm\n  Iourcha Konstantine I., Hong Zhou and Nayak Krishna S. System and method for fixed-rate block-based image compression with inferred pixel values. US Patent 5,956,431 US, 1999.\n  EXT_texture_compression_dxt1 extension specification. 2008. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_dxt1.txt\n  EXT_texture_compression_s3tc extension specification. 2013. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_s3tc.txt\n  EXT_texture_compression_rgtc extension specification. 2008. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_rgtc.txt\n  ARB_texture_compression_rgtc extension specification. 2009. Available at: http://www.opengl.org/registry/specs/ARB/texture_compression_rgtc.txt\n  EXT_texture_compression_latc extension specification. [Online] 2009. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_latc.txt\n  ARB_texture_compression_bptc extension specification. [Online] 2011. Available at: http://www.opengl.org/registry/specs/ARB/texture_compression_bptc.txt\n  Castano Ignacio. GPU DXT Decompression. 2009. Available at: http://www.ludicon.com/castano/blog/2009/03/gpu-dxt-decompression/\n  van Waveren, J.M.P. and Castano, Ignacio. Real-Time Normal Map DXT Compression. Real-Time Normal Map DXT Compression. 2008.\n  Brown Simon. DXT Compression Techniques. 2006. Available at: http://www.sjbrown.co.uk/2006/01/19/dxt-compression-techniques/\n  NV_texture_compression_vtc extension specification. 2004. Available at: http://www.opengl.org/registry/specs/NV/texture_compression_vtc.txt\n  Block Compression (Direct3D 10). Available at: http://msdn.microsoft.com/en-us/library/windows/desktop/bb694531\n  Blinn James F. Jim Blinn\u0026rsquo;s Corner: Compositing, Part 1: Theory. IEEE-CGA, Vol. 14, 1994, pp. 83-87.\n  3Dc™ White Paper. Available at: http://www.hardwaresecrets.com/datasheets/3Dc_White_Paper.pdf\n  Texture Block Compression in Direct3D 11. Available at: http://msdn.microsoft.com/en-us/library/windows/desktop/hh308955\n  The OpenGL Graphics System: A Specification Version 4.2 (Core Profile). The OpenGL Graphics System: A Specification Version 4.2 (Core Profile). 2012.\n  Sovremennaya terminologiya 3D grafiki [Modern terminology 3D graphics]. Available at: http://www.ixbt.com/video2/terms2k5.shtml#hdr\n  OES_compressed_ETC1_RGB8_texture extension specification. 2008. Available at: http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt\n  WEBGL_compressed_texture_etc1 Extension Draft Specification. 2013. Available at: http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\n  The OpenGL Graphics System: A Specification Version 4.3 (Core Profile). The OpenGL Graphics System: A Specification Version 4.3 (Core Profile). 2013.\n  Strom Jacob and Akenine-Moller Tomas. iPACKMAN: High-quality, Low-complexity Texture Compression for Mobile Phones. New York, NY, USA : ACM, 2005. Proceedings of the ACM SIGGRAPH/EUROGRAPHICS Conference on Graphics Hardware. pp. 63-70.\n  Strom Jacob and Pettersson Martin. ETC2: Texture Compression Using Invalid Combinations. Aire-la-Ville, Switzerland : Eurographics Association, 2007. Proceedings of the 22Nd ACM SIGGRAPH/EUROGRAPHICS Symposium on Graphics Hardware. pp. 49-54.\n  Strom Jacob and Akenine-Moller Tomas. Multi-mode alpha image processing. US Patent 7,693,337 US, 2010.\n  Multi-mode image processing. US Patent 7,734,105 US, 2010.\n  Multi-mode image processing. US Patent 7,751,630 US, 2010.\n  Pettersson Martin and Strom Jacob. Texture compression based on two hues with modified brightness. US Patent 8,144,981 US, 2012.\n  The OpenGL Graphics System: A Specification Version 4.4 (Core Profile). The OpenGL Graphics System: A Specification Version 4.4 (Core Profile). 2013.\n  Fenney Simon. Method and apparatus for compressing data and decompressing compressed data. US Patent 7,236,649 US, 2007.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 7,242,811 US, 2007.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 8,204,324 US, 2012.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 8,526,726 US, 2013.\n  IMG_texture_compression_pvrtc extension specification. 2012. Available at: http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt\n  IMG_texture_compression_pvrtc2 extension specification. 2012. Available at: http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc2.txt\n  EXT_pvrtc_sRGB extension specification. 2013. Available at: http://www.khronos.org/registry/gles/extensions/EXT/EXT_pvrtc_sRGB.txt\n  WEBGL_compressed_texture_pvrtc Extension Draft Specification. 2013. Available at: http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n  51.Voica Alexandru. PVRTC: the most efficient texture compression standard for the mobile graphics world. [Online] January 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/pvrtc-the-most-efficient-texture-compression-standard-for-the-mobile-graphics-world\n Taking texture compression to a new dimension with PVRTC2. January 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/pvrtc2-taking-texture-compression-to-a-new-dimension\n  Beets Kristof. Understanding PowerVR Series5XT: PVRTC, PVRTC2 and texture compression. June 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/understanding-powervr-series5xt-pvrtc-pvrtc2-and-texture-compression-part-6\n  Geldreich Rich. PVRTC Compression - First Experiments. Available at: https://sites.google.com/site/richgel99/early-pvrtc-compression-experiments\n  PVRTC Compression - First Coded 4bpp. PVR Texture. Available at: https://sites.google.com/site/richgel99/pvrtc-compression2\n  Nystad, Jorn, et al., et al., Adaptive Scalable Texture Compression. Eurographics Association. High Performance Graphics, 2012, pp. 105-114.\n  Ellis Sean and Nystad Jorn. ASTC Specification. 2012.\n  KHR_texture_compression_astc_hdr extension specification. 2013. Available at: http://www.opengl.org/registry/specs/KHR/texture_compression_astc_hdr.txt\n  ARM Launches Second Generation of MALI-T600 Graphics Processors Driving Improved User Experience for Tablets, Smartphones and Smart-TVs. 2012. Available at: http://www.arm.com/about/newsroom/arm-launches-second-generation-of-mali-t600-graphics-processors-driving-improved-user-experience.php\n  Lassen Jorn and Nystad Anders. Method of and apparatus for encoding and decoding data. UK Patent Application 2491689 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491448 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491687 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491688 GB, 2012.\n  Nystad Jorn Lassen, Anders and Olson, Tomas. Flexible Texture Compression Using Bounded Integer Sequence Encoding. New York, NY, USA : ACM, 2011. SIGGRAPH Asia 2011 Sketches. pp. 32:1\u0026ndash;32:2.\n  Ellis Sean. ARM ASTC Texture Compression. CGDC (China Game Developers Conference), 2013.\n  Smith Stacy. ASTC does it. 2013. Available at: http://community.arm.com/groups/arm-mali-graphics/blog/2013/10/22/astc-does-it\n  Gustavson Stefan. Simplex noise demystified. 2005. Available at: http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n  Ellis Sean. More ASTC in ARM Mali GPUs – High Dynamic Range and 3D. 2013. Available at: http://malideveloper.arm.com/engage-with-mali/more-astc-in-arm-mali-gpus-high-dynamic-range-and-3d/\n  "}]