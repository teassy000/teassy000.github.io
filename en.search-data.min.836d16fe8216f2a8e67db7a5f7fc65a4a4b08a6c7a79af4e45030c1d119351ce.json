[{"id":0,"href":"/docs/translations/","title":"Translations","section":"Docs","content":" \u0026ldquo;Happiness is only real when shared. - Christopher McCandless\n "},{"id":1,"href":"/docs/translations/dod/","title":"Dod","section":"Translations","content":"[译介]面向数据设计 #   原作者：Richard Fabian\n 基于免费的在线版 https://www.dataorienteddesign.com/dodbook/\n译者水平有限，如果发现有问题，可以联系 blog.zko.ooo@gmail.com\n"},{"id":2,"href":"/docs/translations/dod/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1/","title":"面向数据设计","section":"Dod","content":"面向数据设计 #  面向数据设计，已经以各种形式存在了几十年，但直到 2009 年 9 月，才在 Noel Llopis 的同名文章 1 首次这样出现。一直以来，关于它算不算是种编程范式，争议不断。有人认为它可以与面向对象、过程式、函数式编程等其他范式混用。某种意义上的确如此，面向数据设计确实能同其他范式共同发挥作用，但也不否认，它是种更广义的编程方式。Lisp 程序员知道，函数式编程可以与面向对象共存，C 程序员很清楚面向对象能与过程式编程共存。这里，我们先将这些争议搁置，直接断言：面向数据设计是新的重要工具；它能够与其他工具共存。2\n2009 年正合适。革命性的硬件业已成熟；潜力巨大的计算机被无视硬件的编程范式束缚；开发者编码的方式能让许多引擎程序员落泪。但时代变了。现在许多移动端和桌面端解决方案，似乎不太需要面向数据设计，并不是机器擅长处理低效实现，而是游戏设计要求不高，也不复杂。但现在手游的开发趋势似乎正向 AAA 级迈进，又一次，产生了对复杂情况管理的需求，以期最大程度发挥硬件。\n如今，我们被多核设备围绕着，口袋里这个也不例外。学习如何较少依赖串行开发软件就变得尤为重要。面向数据的程序员能获得诸多好处，包括但不限于：摆脱对象信息传递、获得即时响应等。编程时，坚实依赖对数据流的认识，为将来进入 GPGPU 和其他计算方法做好准备。由此，落地诸多游戏构想。面向数据设计的需求只会增长。抽象和串行思维将制约你的竞争对手，而那些接受面向数据方法的人会茁壮成长。\n一切围绕数据 #  数据即一切。数据是创造用户体验时需要变换的；是打开文档时加载的；是屏幕上的图形；手柄按钮的脉冲；是扬声器震动空气产生的波；是角色升级的路线；也是对手向玩家开枪的诱因。数据是炸药引信的时长；是撞到尖刺掉宝的数量；是游戏结束时绚丽场景中每个粒子即时的位置和速度：经由源码，编译到汇编指令，再解码为机器指令，操纵磁盘读取内容，再一步步最终呈现到眼前。\n不存在没有数据的应用。没有图像，Photoshop 无从谈起。没有画笔、图层、笔压，它什么也不是。没有字符、字体、分页符，Microsoft Word 也没有意义。没有事件，FL Studio 毫无价值。没有源码，Visual Studio 只能算作花瓶。过去所有的程序，都是基于输入数据，输出数据。数据的形式有时极其复杂，有时简单到无需文档，但所有应用程序都接收、产出数据。如果没有可识别的数据，顶多只算是玩具、Demo。\n指令也是数据。指令会占用内存，使用带宽，并且可以被变换，加载，保存，构建。对于开发者，自然不会认为指令是数据3，但在旧的、保护性较差的硬件上，它们的区别很小。尽管大多数当代硬件，会保护为可执行文件预留的内存，避免其被损害、被修改，但这一相对较新的发明仍未成熟。改进的哈佛架构对内存中的数据和指令同等依赖4。因此，指令仍是数据，它们也是要变换的对象。我们接受指令并将其转化为行动。指令的数量、大小、频率都很重要。我们控制、筛选、使用哪些指令来解决问题的行为，即是优化。知道了数据是什么，便能决定如何处理数据。了解指令，便有了理论支撑，能决定哪些指令是必要的，哪些是冗余的，哪些可以用低成本方案替代。\n现在，我们有了面向数据的开发方法的论证基础，但还遗漏了一个主要因素。所有这些数据和及其变换，从字符串，到图像，再到指令，都必须在某样东西上运行。这个东西有时相当抽象，如，未知硬件上运行的虚拟机；有时又很具体，比如已知 CPU、GPU、内存容量、带宽的自己的电脑。所有情况下，数据又不仅仅是数据，而是存在于某个硬件上的数据，而且必须经由同一硬件变换。本质上讲，面向数据设计是变换结构良好的数据，设计软件的方法，其中结构良好的标准是由数据的目标硬件，对其执行变换的模式与类型共同决定。有时，数据并不是很明确，硬件可能也捉摸不透。但大多数情况下，良好的硬件评判能力几乎对每一个软件项目都有所帮助。\n如果应用程序的最终结果是数据，且所有的输入都可以表示为数据，并且了解所有的数据变换都没有凭空发生，那就可以基于此原则建立一个软件开发的方法论：理解数据，了解机器对特定数量、频率、统计量的数据执行变换时都发生了什么。在此基础上，就可以草拟一个关于如何使方法论面向数据的声明。\n数据不是问题域 #  原则一：数据不是问题域。\n对于有些人，面向数据设计似乎处于大多数其他编程范式的对立面，因为它不太容易让问题域进到软件源码中。它不鼓励将对象概念映射到用户的语境(Context)。因为数据刻意地，自始至终没有意义。重视抽象的范式会假装计算机和它的数据不存在，将字节、CPU管道、其他硬件特征等概念抽象出去，取而代之的是：引入问题模型。他们常把有观点的模型引入代码，或者把世界模型作为问题的语境。就是说，要么围绕预期解决方案的属性，要么围绕问题域的描述来构建代码。\n赋予数据意义就能创造信息。意义并非数据固有。只有一个数字 4，几乎没意义，但如果说 4 英里，或 4 个鸡蛋，就有了意义。假设有 3 个数字，作为一个三元组意义不大，但如果将它们命名为 $x , y , z$，就可以赋予其位置的意义。有一份游戏中的位置列表，在没有语境的情况下也没什么意义。面向对象设计可能会把位置作为对象的一部分，通过类的名称和相邻的数据（也已经命名），就可以推断出数据的含义。如果没有已命名的语境数据与之关联，位置可以被赋予其他意义。虽然某种程度上，把数字放在语境当中是好的，但同时也阻碍了把位置作为三个数字的集合来思考，然而这一点对程序员思考如何解决的真正问题时，至关重要。\n举例来讲，当把数据放在对象的深层，到后来又忘了它的存在。想想诸多已发售或尚在制作中的游戏，本可以使用一个 2D 或 3D 网格(grid)系统处理数据布局。不知为何，开发人员将地图上的每一个引用都实例化了。这还不是个例，在已经发售的游戏中，这种以对象为中心的方法摧残硬件的案例并不少见：相较于由真正的网格驱动，有数百个对象直接放置在世界空间的网格坐标上。可能程序员看到一个网格，看到所需的元素数量，就会对是否要为它分配一块内存而犹豫不决。一个简单的 $256 \\times 256$ 的 tileMap 需要 $65,536$ 个 tile 。面向对象程序员可能会觉得 6 万多个对象相当耗费。对他们来说，只在必要的时才为 tile 分配对象可能更有意义，甚至到了在编辑器中真的有 $65000$ 个人工创建的 tile 的地步。但正由于它们是人工放置的，必要性就被确定了，于是就变成了不得不处理的确切问题。\n缺乏对底层的认识，不仅会导致用糟糕的方式处理渲染、放置元素，同时在解释元素的位置时，也引入更高的复杂度。在无网格的形式上访问元素往往会有一些障碍，比如保有相邻元素的链接（需要保持更新）；或需要执行整个元素列表（开销很大）；或引用一个辅助的增强网格对象（或空间映射系统）管理那些被游戏设计限制移动的对象（原本可以自由移动的）。这种无网格设计带来的虚假的自由，流露出对数据的理解不足，并且已经给一些游戏造成了显著的性能损失。同样也是对程序员心智的极大浪费。\n除了当用不用网格系统，很多游戏还将每个对象都实例化，而不是用一个变量保存物品数量。对于某些游戏，这算种优化，因为创建、销毁对象也会产生相当大的开销。但这种趋势实在令人担忧，这种存储方式将游戏的数据结构埋藏至深处。\n许多游戏都试图把关于玩家的所有信息都保存在玩家类里。如果玩家在游戏中死亡，则须作为一个已死亡的对象继续存在，否则将无法访问成就数据。将数据是什么、存在哪里、与谁共享生命周期的联系到一起，带来单体类以及种种难以理清的关系。而这些关系被也随后被证明是最大的 bug 来源。在这里我不会提及任何游戏名称，不只是一个游戏，也不只是一个工作室，这是种不良技术设计的流行病。似乎那些使用现成的面向对象引擎的人比那些自己开发的人更易感，而且绝不局限于某个范式。\n面向数据设计并不会把现实问题的模型引入到代码里。资深的面向对象开发者常将其看作是面向数据方法的缺陷，因为面向对象设计的成功范例来自于：把人类的概念带到机器上，然后在这个中间地带，可以写出一个人类和计算机都能理解的解决方案。面向数据方法则把问题域留在设计文档中，因而放弃了些人类的可读性，将约束和期望的因素带入到变换中。但也正是这一类操作，可以防止机器在数据层面上处理人类的概念。\n现在考虑，在提倡无谓抽象的编程范式中，问题域如何成为软件的一部分。对于对象而言，我们把它包含的类及其相关的函数联系起来，将意义与数据联系起来。在高层次的抽象中，我们通过高层次的概念将操作与数据分离，而这一类概念可能并不适用于底层，从而使函数变得更难实现。\n类包含数据，就赋予了这些数据语境，但有时也会限制数据的复用，影响对操作的理解。针对语境添加函数可以访问更多的数据，但很快就会导致类中包含许多不同的数据。这些数据本身并不相关，但却得在同一个类里。因为某个操作需要语境，而这个语境由于某些原因需要更多数据，如，其他相关的操作。听起来很熟悉，引用 Joe Armstrong 的话说：\u0026quot;我认为缺乏复用性出现在面向对象的语言里，而不是函数式语言里。面向对象的语言的问题是它们随时携带着所有隐含的语境。你想要一根香蕉，但你得到的是一只拿着香蕉的大猩猩和整个丛林。\u0026quot;5显然这是被面向对象语言的语境引用问题困扰产生的吐槽。\n使用接口（或依赖注入）消除语境间的联系倒也情有可原，但实际的联系不止如此。对象中的语境往往用于联接不同类型，不同级别的数据。比如一根香蕉，有多种不同用途，可以作为一种水果，也可以代表一种颜色，抑或是以字母 B 开头的单词。需要仔细考量香蕉作为实例带来的问题，香蕉同时也可以是\u0026quot;种类\u0026quot;的实例。如果从进口商品的法律角度去看，或者要获取它的营养价值的信息，显然，相对于香蕉的库存数量，是截然不同的呈现。好在还是从香蕉说起。如果谈论的是大猩猩，那么我们也会止步于：大猩猩个体的信息；动物园或丛林中的大猩猩；以及大猩猩的种类。上述示例是给同一个名字的东西的三个不同层次的抽象。至少对于香蕉，每个个体并没有多少重要的数据。现实世界中也经常能看到这种语境的联系，但在对话中我们能够很好地处理了这种复杂度。一旦开始强行规定这些语境，就使得不同语境之间产生了联系。那么原本赋予的意义就会变得脆弱不堪。\n混合在一起的抽象层都很难解开，因为对每个语境进行操作的函数都会从各种类中拖入随机的数据块。也就意味着，为了保证正常访问，就不能随意删除数据。这足以阻止大多数程序员尝试大规模的软件项目。同时还有另一个问题，那就是隐藏对数据的操作，会引入不必要的复杂度。当看到链表、树、数组、map、表单、行，很容易就推测出其交互、变换方式。但如果你想对家庭、办公室、道路、上班族、咖啡馆、公园做同样的事情，往往会先陷入对问题域概念的思考中。反而因此错失了探明更好的数据表达和算法的这一类细节的机会。\n很少有计算机科学的算法不能在原始数据类型上重复使用。但是当引入新类，有自己的内部数据布局，没有明确遵循现有数据结构的模式，那么就不能完全利用这些算法，甚至可能看不到它们会如何应用。把数据结构放在你的对象设计中，从它们的本质来看可能是有意义的，但从数据操作的角度来看，往往没有什么意义。\n当从面向数据设计角度考虑数据时，数据只是一种存在，为了获取所需格式的输出，可以用任何必要的方式解释它。我们只关心我们做了什么变换，以及数据的最终去向。实践中，抛弃数据的含义，就减少了事实与其语境相互纠缠的几率，因此也降低了仅仅为了一两个操作而混合无关数据的可能性。\n数据与统计 #  原则二：数据指类型、频率、数量、布局、概率。\n这个原则是指，数据不仅仅是结构。对于面向数据设计，一个常见的误解是，以为只跟缓存命中 (cache miss) 有关。即便只是为了保证缓存命中率，也只是通过结构化数据，将冷、热数据分离开。这是种有效的编程技巧，但面向数据设计要考量的，是数据的所有方面。要写一本关于如何避免缓存未命中的书，需要的不仅仅是些关于如何组织结构的技巧，还需要了解当计算机在运行程序时，里面究竟发生了什么。在书里讲这些也不太现实，因为这只适用于一代的硬件和一代的编程语言。尽管获益最大的是 C++，而收效最大的硬件是任何存在不平衡的瓶颈的硬件，但面向数据设计并不只植根于一种语言和某些不寻常的硬件。数据的模式很重要，但是数值和数据的变换方式同样重要，甚至更重要。通过猎豹的照片来了解它能跑多快终究是纸上谈兵。要在野外环境里去看，去了解慢的真正代价。\n面向数据设计模式以数据为中心。以实时的、真实的、同时也是信息的数据为支点。而面向对象的设计则以问题的定义为中心。对象不是真实的东西，而是要被解决的问题的语境的抽象表示。对象通过操作所需的数据以表示它们，不考虑硬件或现实世界的数据模式与数量。这就是为什么面向对象设计能够快速建立起应用程序的原型，允许把早期的设计文档或问题定义直接放进代码，从而快速尝试解决方案。\n面向数据设计采取了另一套策略，相较于假设用户对硬件一无所知，这里选择假设用户对问题的真正性质知之甚少，并将数据模式贬为二等市民。任何一个写过大型软件的人都会意识到，一个项目的技术结构和设计经常会发生很大的变化，以至于在后来的实施过程中，几乎没有任何部分能维持初稿的设计。面向数据设计避免了资源浪费，它从不认为设计需要存在于文档之外的任何地方。通过一系列上层代码来控制事件序列，解决当前问题，并指定模式来赋予数据临时的意义，从而推进工作。\n面向数据设计从已有或预期的数据中获取线索。相较于为所有可能性，或保证扩展性做规划，不如说它倾向于使用最可能的输入来决策算法。与其说计划需要支持扩展性，不如说计划要简单、可替换，并能够落实。扩展性能以后再添加，通过单元测试这张安全网，确保它简单，且仍能正常工作。好在已经有一种不需要过多考虑，就能够保证扩展性的技术了：就是利用经过多年实践开发的数据库技术。\n引入关系模型后，数据库技术发生了巨大的转变。在Out of the Tar Pit [^bmospmark] 一文中提到了通过函数式方法变换关系模型数据结构，使得函数式关系编程6又向前迈进了一步。这份文献，正是一部教你如何调整数据结构匹配需求的秘籍。\n数据是可变的 #  面向数据设计只适用于当下。它无法解决过去的问题，也不是什么新颖的方案，更不是解决潜在问题的通用方案。拘泥于过去会干扰灵活性，一味的着眼未来则又可能一场空，毕竟程序员也不是什么算命先生。以作者之浅见，很少有面向未来的系统。实际应用中，伴随着设计发生变化，面向对象设计的弱点才开始显现。\n在面向对象设计的介绍中常提到：面向对象设计能很好地处理底层实现细节的变化。但实际上，仅限于那些显著的、可预期的。它无法很好地处理诸如用户需求、输入格式、数量、频率、信息传输通道等这一类更实际的变化。在 On the Criteria To Be Used in Decomposing Systems into Modules7 中提到，当时许多人会像管线一样利用模块化，在方案的各个阶段使用可执行单元。每个阶段都可以看作解决局部问题的方案。在早期的文档中，模块化通过隐藏数据得以实现。当时这还算是一种改进，但在后来的 Software Pioneers: Contributions to Software Engineering 8 一书中，作者重新审视了这个问题，并提醒我们，虽然这样在开发初期根据业务状况做方案选择时更快，但同时也会增加维护和迭代成本。受到这种固有惯性的影响，面向对象的设计方法始终会有问题域与实现之间的耦合。如前所述，当问题域被引入到实现中，可以立即看到实现是否有效处理、解决了当下问题，因而可以快速做出决策。但面向对象设计的问题在于，在更高层次上的变化是不可避免的。\n设计会因许多原因改变，偶尔也会包括实际上没有改变的时候。对设计的误解，或者是曲解，会直接改变设计，进而改变实现。面向数据代码的设计从数据层面理解其变化的意义，反过来指导设计。不同于 OOP 在封装内部操作状态，面向数据还允许在数据源发生变化时，修改代码。通常而言，对比对象的复用和突变，数据块及其变换的耦合和解耦更易实现，因而 DOD 能更好地处理变化。\n数据，与其特征和用法产生了关联。把数据及其功能与对象混为一谈时，对象即为数据的画皮。数据的特征与对象关联，意味着很难从其他视角考虑数据。因而数据的用例和真实的设计，都与对象暗含的用法和特征产生联系。若数据的布局与用法相关联，而用法又与数据的特征相关联，就很难仅仅根据特征拆解数据。不同特征用到不同的数据子集时，因其(特征)相互交叠，便会化为重重阻碍。同时交叠的数据又会形成一个越来越大的值集，作为独立的单元在系统中到处传递。这种情况，常见的做法是将一个类重构为多个类，或将数据的所有权交给不同的类。这就是将数据与一种特征联系起来。强行赋予数据以目的。而对于静态对象，则是多个预定义的目的合集，甚至还会引入原本不存在的联系。有些目的可能不再是设计所需。然而，需求的关联总比不需求的更明显，看得见的、看不见的，随着时间的推移，关联只会越来越多。\n倘若通过数据的关联性来决定其操作，如给一个类添加新方法：在数据改变或被拆分时，就很难再移除对数据的操作了；而当一个操作需要数据关联在一起，那不太方便再拆分数据了。但如果把数据与对其的操作分开，将数据的各个特征、用途，从操作与数据变换中提取出来，就不难发现：原本面向对象代码重构时会遇到的困难，变得微不足道。但也是有代价的，需要维护一份操作与其所需数据的标记（用于间接查找和访问），同时面临二者可能的不同步的风险。综上，代码保持面向对象的风格：其中对象负责保持内部一致性，效率和可变性的优先级也不是那么高。有些时候，面向对象的设计是要远优于面向数据。例如系统或硬件驱动层：Vulkan 和 OpenGL 是面向对象的，只不过对象的粒度很大，并在它自己的体系里与保持理念一致；又或者像 FILE 类型的面向对象方法：文件系统中的打开、关闭、读取、写入等操作。\n许多刚接触面向数据设计范式的人，常会有一个误解：可以通过抽象，设计一个静态库（或一组模板）作为通用的面向数据的方案，就能够解决本书中提出的所有问题。领域驱动设计 (DDD) 一样，面向数据设计是针对产品和工作流的。这里学习的是如何做面向数据设计，而不是如何将其添加到项目中。这里遵循的基本原则是：尽管数据的类型可以是通用的，但在其使用层面却不是。数值千变万化，但常常隐含我们可以利用的模式。数据能够通用的想法，从根本上就是错的，面向数据设计则要去纠正它。应用于数据的变换，在某种意义上可以通用，但实际执行的操作及其次序，才是实质上的解决方案。源码是将数据从一种形式变换为另一种形式的秘方。不会有一个模板库去理解和利用数据中的模式，这应当是一个成功的面向数据设计的任务。诚然，我们可以建立算法来匹配数据中的模式（比如压缩），但提及面向数据设计时，这个模式是更高层次的，特定域(domain-specific)的，而非单纯的频率映射。\n程序运行时，常会使用一些专业技巧优化性能。这样或许会降低代码可读性，但也常常因不是面向对象，或因为是硬编码的原因不被采纳。硬编码一个变换，可能要比把它包装进通用容器，再套一层算法来假装它不是硬编码来得好。如果熟悉现有模板库，直接用现成，可读性会更好；当然如果恰巧用到的是通用功能，潜在错误也会减少。但如果该功能没能很好地映射到现有的通用解决方案中，此时通过函数模板再对其扩展，无疑增加了理解代码的难度。取巧地将背后技术已被替换这一事实隐藏，会产生误导。这时候，硬编码一个实质上的新算法可能会更好，当然前提是做好充分测试。如果限定在具体数据上，只用简单真实的数据（而不是什么通用数据，通用类型）测试，测试也更好写。\n数据的形态 #  现如今的游戏有大量不同格式的数据：针对不同平台的纹理；根据骨架、播放类型优化过的动画；音频、光照、脚本；还有由多个不同属性的 buffer 组合成的网格。只有很小一部分有固定用途，如顶点数据中的位置、UV 和法线。游戏开发中的数据很难框定，并且越来越难。许多以前无法实现的想法，现在逐渐流行。这也是为什么，需要在编辑器和工具链上花费大量时间，以便将设计师和美术们自由创作的产出，以某种形式放进引擎里。如果没有工具链、编辑器、查看器、调整工具，就不可能以同等时长产出游戏。面向对象是处理所有这些不同格式数据的方法之一。它能提供集中的视图，显示每种类型数据的归属，并根据可对其执行的操作归类。它还很容易快速添加、使用数据，但实现、封装这些不同的对象需要时间。有时对象归类的方式，无法再添加新功能时，可能还需要大量重构。例如，在许多过去的引擎中，纹理总是每像素 1、2、4 字节。随着引入浮点纹理，这些代码就都需要做些重构了。以前，顶点着色器中无法访问纹理。所以当基于纹理的蒙皮出现时，许多程序员不得不重构引擎渲染模块，使其能够更新顶点着色器的纹理，因为更新 transform 用以渲染蒙皮的网格时，可能会用到。PlayStation2 面世时，或某个引擎首次使用到着色器时，\u0026ldquo;材质\u0026rdquo; 这一概念，就发生了变化。从小型 3D 场景看向更开阔的世界的过程中，细节层次(LoD)不断变大。于是工程师们开始考虑，\u0026quot;渲染\u0026quot; 到底意味着什么。新的硬件越来越注重对齐，因此实现不得不变得难以插入操作。许多引擎中的网格数据是为渲染优化过的，但是如果必须对网格投射射线，以确定子弹命中的位置，或用 IK，或用物理，一个实体就需要有多重呈现。从这点来看，面向对象的方法就像是拼凑起来的，只有较少的对象用以代表实物，更多的则只是容器，程序员就得从更大的构建块的角度思考。实际上，这些块只会阻碍思考，在脑海中就只剩了独立的块，而其中内在的联系很快就被抛诸脑后了。从 2D 精灵到 3D 网格，始终遵循硬件厂商的格式，自定数据流和运算单元被转化为渲染的三角形。音频波形，到 bank 文件，到包络控制的音频粒子和多层音频的回放。Tile-map，到传送门、房间，再到流式的有多级 Lod 的世界，最后到混合网格调色板(hybrid mesh palette)、数据、特殊的混合资源。从翻书到欧拉角序列，到四元数和球形内插动画，到动画树和行为映射/树。不变的只有变化本身。\n如果读者从事过游戏行业，可能已经有接触这些数据类型。许多引擎确实做了会抽象这些相对基本类型。新的数据类型被大量使用时，就会作为核心类型集成到引擎里。通常，该类型被推广之前，会当作特殊情况处理，算是在可用性和性能之间的权衡。谁都不想在游戏开发中，为尚未充分理解的元素敞开大门。那些不愿或不能投入时间了解新功能最佳实践的人，也可能会吃到闭门羹。面向对象开发中的对象，并不会呈现数据本身，转而向了解更高级的工具的用户提供各种功能。\n除了代表数字资产的对象外，还有用于内部游戏逻辑的对象。每个游戏，都有一些对象仅仅为了推动游戏玩法而存在。可收集的卡牌游戏有很多纹理，但也有大量的规则、卡牌统计、玩家卡组、比赛记录，以及表示当前游戏状态的对象。这些都是为一个游戏完全定制的。游戏可能会有续作，但除非是换皮，不然游戏逻辑变化可能会相当大，因此需要不同的数据，意味着需要实现新的方法，原有的对象，实际上已经不再是前作中的那一个了。\n游戏数据很复杂。第一次数据布局几乎都是受最初设计的启发。一旦开发启动，布局就需要跟上游戏开发的变化。面向对象技术能够快速实现任何给定设计，在分别实现每个单一设计时非常快，但难以胜任从一种干净或优雅的数据模式迁移到下一个。当然也有一些小窍门，比如使用基于版本的资产管理程序，或结合更新系统并变换脚本的框架，但通常情况下，游戏开发者会同时改变工具链和引擎，完全重新导出所有资产，然后一次性提交到下一个版本。如果必须同时更新多个网站；或者资产量巨大；又或者试图为同时用于多个项目的引擎提供支持，而只有其中一个项目想要更新；那这个过程或许会相当痛苦。Django 框架是面向对象方法的一个例子，它能比较优雅地处理设计的迁移。但原因是，这些对象呈现的是数据模型的视图，而非数据本身。\n尝试建立出一个通用的游戏资产解决方案，到目前为止还没有一个成功案例。可能是因为所有的游戏都有很多微妙的不同，如果真的提供了一个通用的解决方案，那就不是游戏解决方案，只是一种新的语言。试图提供一个游戏可以使用的所有可能的对象类型，是不会找到解决方案的。但如果我们回到对游戏本身的思考，把它当作只是在一些数据上运行一组计算，那就有一个解决方案。截止到 2018 年 ，能得到的最接近的尝试是 FBX 格式，当然，它还一定程度上依赖当前的标准着色器语言。目前的解决方案似乎还有不太容易去除的包袱。由于需要通用，许多细节在以非对抗方式呈现数据的抽象过程中丢失了。\n框架(framework) #  无论是从底层性能的角度，还是从上层的游戏性与交互角度，游戏开发者们对于开发的理解都声名狼藉。或许由于高性能代码与内容层代码之间的差距越来越大了。面向对象技术能很好地覆盖上层需求，生产内容的程序员们对此十分满意。而性能专家们则致力于利用硬件做更多的事情，以至于内容创作者们常常会觉得在优化过程中没他们的份。可在游戏开发中，并不存在什么 \u0026ldquo;中间环节\u0026rdquo;，这可能也是为什么不采用大型计算机 9 的架构和性能技术。其次，游戏开发者通常不需要开发预期维护十几年的系统和应用10，因而不太可能在代码封装和保护上费心，甚至不会劳神维护文档。20 世纪 90 年代末，游戏开发行业首次蓬勃发展，较大的工作室开始涌现。但那时学术界和企业的软件工程实践却备受质疑，哪里有他们的身影，哪里就出现性能骤降，来自这些行业的雇员，几乎都没能留下印记。随着游戏机变得更像标准的微机，而标准微机在设计上更接近以前的大型机，那些标准专业软件工程实践的用处开始逐渐显现。现在，游戏的规模已经发展到与硬件相匹配，但行业已经不再关注那些非游戏开发实践的方向。作为一个行业，我们应该关注前人走过的路，而最接近的学术和专业开发技术似乎是以模拟和海量数据分析为基础的。我们要面临行业特有的挑战，比如在足够多的 AI 环境中遇到的高频高异构转化需求的问题，以及网络环境中的用户距离问题，又比如 MMO 中有基于位置的事件时，面临的带宽 $n^2$ 问题，因为每个人都在试图给其他人发消息。\n随着游戏世代更迭，开发者创作游戏的时间也在增加，这就是为什么项目管理和软件工程实践在大型游戏公司里已经标准化。曾几何时，游戏开发者被视做顶尖程序员，根据需求开发新的技术；但随着不太冒险的硬件出现（最知名的是第八代 x86 架构处理器），重心从巧妙的编码实践转变成为标准化的过程。也即是说，为了确保发布日期与营销日期吻合，游戏开发进度可以调整。高调的游戏开发中，总会有随机因素存在。总会有新的原因，几乎可以保证无法准确预测项目（或某个阶段）的时长。即便不通过面向数据设计来提升游戏的运行效率，也可以靠它让游戏开发的时间表变得规律。\n在游戏中引入新功能，困难之一在于数据布局。若要在现有框架内改变数据布局，就需要重新设计或扩展对象。即便没有新的数据，一个功能也可能从以前的独立系统变得突然需要密切交换信息。这种耦合往往会导致整个系统的混乱，进一步引发时间耦合和额外的边界情况。而这些情况或许只有百万分之一的复现几率。听起来好像问题也不大，但如果期望游戏能卖出几百万甚至几千万份，百万分之一的话，就是几个到几十个玩家。然后他们录下游戏的 bug 集锦传到网上，表示这游戏是垃圾，开发者都不好好干活：这么明显的 bug 都没有修复。这还不是最差的，如果这个问题是个规避内购的方法，而发现的人知道复现方式，随后这些步骤在网上大肆传播，或许足以在一个 MMO 游戏里产生一股破坏游戏内经济系统的资源流11。现在怎么办？若是买断制的游戏，如果已经卖出了几百万几千万份，大可不必在意。但若是现如今的免费游戏，五百万玩家可能只算个好开局，而差评会遏制增长。绕过内购会直接扼杀收入，经济崩坏则直接断送前程。\n早在 20 世纪 70 年代，大型计算机的开发人员们就有这样的担忧。由于他们的程序经常在与真实货币交易有关的数据上工作，因而软件必须以高标准构建。他们需要编写操作数据的业务逻辑，但必须确保数据是通过一套可证明的谨慎操作来更新的，进而保证其完整性，这一点非常重要。数据库技术的发展正是源于对处理和存储需求：对数据进行复杂分析，存储，更新，并保证其无论何时都有效。因此使用 ACID 测试来确保数据库的原子性 (atomicity)、一致性 (consistency)、隔离性 (isolation)、耐久性 (durability)。原子性测试确保所有事务只有\u0026quot;完成\u0026quot;或\u0026quot;不做\u0026quot;两种状态。如果一个数据库一次金融交易只更新一个账户，那可以说是非常差劲了。如果交易不是原子性的，就可能引发错误。一致性是为了确保在交易中应当发生的结果状态都会发生，也就是说，所有应触发的触发器都会被触发，即便是递归的也会，没有限制。若某个账户触发了欺诈检测需要被封禁，这一点就显得尤为重要。如果其中一个触发器失灵，数据库的使用者 (公司) 可能要因未能及时阻止账户而担责。隔离性是指确保所有发生的交易不会干扰任何其他交易行为。也就是说，如果两个交易出现要在相同的数据上工作，就必须排队，而非试图同时操作。尽管通常不会出什么问题，但它确实会引起并发问题。最后，耐久性。这是四要素中第二重要的，确保一个事务一旦完成，就要一直保持下去。在数据库术语中，耐久性意味着交易将确保以某种方式存储，即使服务器崩溃或停电时仍然存在。这一点对于联网的计算机来说是非常重要的，当服务器崩溃或连接中断时，需要知道哪些交易确实已经发生。\n现代在线游戏也不得不担心类似的非常重要的数据。对于非免费的可下载内容，消费者关心的是一致性。对于付费的可下载内容，用户会关心每一笔交易。为了提供数据库 ACID 测试需求的大部分功能，游戏开发者们开始回过头来研究数据库如何应对严格的要求，找到大量关于分阶段提交、幂等函数、并发等参考，从文献中学习如何为数据库设计表。\n结论和启示 #  前面已经谈到了面向数据设计是一种思考，布局数据，并决定架构的方式。面向数据设计时的许多决定由两个原则来驱动。在本章结束之前，让我们用一些可以直接应用的 tips 开始旅程吧。\n考虑一下称谓如何影响数据。考虑临近数据对数据本身可能的影响，会把它困在灵活性受限的模型中。第一个原则：数据不是问题域，要考虑以下问题：\n  是什么将数据联系起来，是概念还是隐藏的涵义\n  数据的布局是由单一角度的单一阐释定义的吗？\n  考虑如何重新解释这些数据，并按思路细分数据。\n  什么让数据独特而重要？\n  目标平台不是未知设备。了解数据，了解目标硬件。或者说，了解每个数据流的优先级，对每个使用者的重要程度。理解改进的成本和潜在收益。访问模式也很重要，如果在突发情况下访问数据，然后在整个应用周期内不再碰它们，就会影响到缓存命中。第二个原则：数据指类型、频率、数量、布局、概率，接下来考虑以下条目：\n 目标平台的最小内存单位是什么？ 12 读取数据后，又实际使用了多少？ 数据访问的频率是？1次/帧、或是1000次/帧？ 如何访问这些数据的？是随机的，还是突发的？ 数据一直在被修改，还是只读？需要修改所有数据吗？ 数据对谁重要，它的哪些方面重要？ 找出解决方案在带宽和延迟方面的质量限制。 有什么信息不在数据中？其中隐含的是什么？    Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP) http://www.gamesfromwithin.com/data-oriented-design\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 不过仍有一些限制，但并不与任何范式相互排斥，可能除了像 Prolog 这种逻辑编程语言。完全陈述性的 what, not how 的方法，看起来先天放弃考虑数据本身，以及它如何与机器互动。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 除非是 Lisp 程序员\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：有一种改进中，提供了指令存储器和 CPU 间的通路，来自指令存储器的字被当作只读数据。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 摘自 Peter Seibel 的 Coders at Work [@pseibel]。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：此处取函数式编程和关系模型的组合。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n D. L. Parnas: On the Criteria To Be Used in Decomposing Systems into Modules\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Manfred Broy, Ernst Denert: Software Pioneers: Contributions to Software Engineering\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 译注：原文为 Big-Iron companies, 代指 60 到 70 年代开发大型计算机的公司\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 暴雪娱乐公司的人可能有话要说。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 在线漫画网站 The-Trenches 上有一则关于产品上线后发现问题并尝试修复它的漫画。http://www.trenchescomic.com/comic/post/apocalypse\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 2018年，大多数机器上，内存的最小单位是 64 字节对齐的块，称为缓存行 ( Cache Line)。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":3,"href":"/docs/translations/%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/","title":"纹理压缩技术","section":"Translations","content":"[译介] 纹理压缩技术 #    本文翻译自一篇由 T. Paltashev 和 I. Perminov 撰写的论文，其英文版本链接如下：\nhttp://sv-journal.org/2014-1/06/en/index.php?lang=en\n 概述 #  本篇文章，会从压缩比和图像质量角度出发，分别在技术层面和现代硬件 (如：PC，手机和平板) 层面对不同的纹理压缩技术进行深入分析和比较。首先我们会分析最早广泛使用的 S3TC (BC1-BC3) 系列。随后会逐个分析一些通过增加灵活性和使用块分割技术而大大改进图像质量的新系列： BC4, BC5, BC6H 以及 BC7。接着分析由爱立信开发的面向移动端的 ETC(PACKMAN, ETC1 ( iPACKMAN ) , ETC2/EAC) 和 Imagination Technologies 发明的 PVRTC。最后会分析由 AMD 与 ARM 协同开发的 ASTC 技术。我们也会详细讨论 ASTC 所使用的 BISE 编码技术和其他特性。\n关键词：computer graphics, texture compression, texture decompression, S3TC, DXT, BCn, BC6H, BC7, ETC, ETC2, EAC, PVRTC, PVRTC2, ASTC.\n前言 #  如果没有不同的纹理，3D 计算机图形学恐怕是不可想象的。在不增加几何复杂度的前提下，纹理技术能够大幅提升图形质量。简单的纹理是映射在 3D 表面上的 2D 图像。纹理中的每一个像素又称为纹素 (纹理的基本单位) 。通常除了颜色信息，纹理还能够存储高度信息、法线方向以及镜面系数等 (见图1) 。现代 3D 应用和游戏会占用大量的内存，而其中一半以上都被纹理所占用，因此对内存大小和带宽有很高的需求。各种纹理压缩技术应运而生，以减少对内存和带宽的压力。基于这种情况，材质通常都是以压缩状态存储在内存中并传输至 GPU。解压过程只发生在 GPU 上，通常位于 L1 和 L2 cache 之间。这样的话，不仅减少了内存占用，也同时节省了带宽。压缩同时也能够节省功耗，因为 GPU 核心同显存之间的数据交换也是会产生功耗的，而这一点对于移动设备尤为重要。\n [图1]: 不同类型的纹理映射示例。A - 漫反射贴图； B - 法线贴图 C - 位移 (高度) 贴图\n 纹理压缩的特性 #  绝大多数情况下，纹理表现为一张 2D 图片。但标准的压缩算法 ( RLE, LZW, Deflate) 以及常用的图片压缩格式 ( JPEG, PNG TIFF) 并不适用于纹理压缩。主要原因是上述算法不满足随机访问。因此很难在不解压整张纹理的前提下直接访问某个特定的纹素。纹理访问的模式高度随机：只有在渲染时被用到的部分才需要访问到，且无法提前预知其顺序。而且在场景中相邻的像素在纹理中不一定是相邻的 (见图2) 。因此图形子系统的性能高度依赖于纹理访问的效率。随机访问决定了各种纹理压缩格式的主要特点。\n [图2]: 纹理布局示例。(纹理和3D网格来源：Microsoft DirectX 9 SDK)\n 多数纹理压缩策略会将整张纹理划分为固定大小的块 (Block)，又称为瓦片 ( Tile)，每个瓦片被单独压缩。但也有一些特例，如 PVRTC。评估一个纹理压缩方案，需要考虑以下因素：\n 随机访问。GPU 需要能够随机有效地访问任意纹素。因此几乎所有的压缩器都拥有固定的压缩比。 这也就意味着有损压缩。当然非固定压缩比也是能够胜任随机访问的需求的。例如，Inada和McCool在(2)中提出了无损的可变速率方案，通过修改纹理缓存结构来实现高性能。 高解压速度。 贴图访问速度也是会影响图形子系统性能的关键因素，由此引出下述两个因素：  解码器的低成本硬件实现。解压算法应当相对简单，所以很少用到小波变换 (wavelet) 以及离散余弦变换 (DCT- disrete cosine transform) 。 无间接和连锁内存访问。理想情况下，只需读取一次内存就能获取解码一个小区域的纹理所需的全部信息。而为了获得过滤的纹理，只进行最低限度的额外读取。任何额外的内存访问 (如读取调色板或其他表) 都增加了整体延迟。由于降低了局部性，间接访问还会拉低缓存效率。   高压缩比。这是在进行纹理读取时，决定带宽占用的主要因素。压缩比通常用比特率或每像素平均比特数 ( bpp - byte per pixel 译注：原文为 byte per texel) 来表示。典型的 bpp 的值为从 2bpp 到 8bpp。 图片会被分割成小块，通常为 4x4 纹素。块太小的话会比较难压缩，而太大的话又会影响到 cache 命中。另外，为了减少延迟和简化硬件实现，压缩块的大小最好小于内存总线的宽度。如果一个压缩块所占的位数与总线宽度相同，就可以避免流水线停顿(3)。现代图形处理器的内存总线通常从 64 位到 512 位。由于严格的硬件和功率预算，移动设备的纹理压缩方案利用非常高的压缩比 (2bpp) 或更小的块来适应内存总线宽度。 解压后的纹理有可接受的视觉质量。压缩器引入的失真当然是越小越好。  流式纹理压缩 #  在这篇文章中，我们将只详细讨论提供随机访问并有硬件支持的格式。但是这里仍旧需要提及一下流式纹理压缩。这种技术用于将贴图快速从硬盘或网络加载到显存中。对于图像数据达到千兆字节量级的现代应用来说，这的确是个问题。\n首要的目标是降低数据大小。在没有随机访问的要求时，便可以实现非常高的压缩比和 (或) 无损压缩。当纹理加载进内存之后，就可以用可编程着色器解压它。其输出可能是未压缩的格式，也可能是硬件支持的压缩格式。也可能通过以下方式优化内存管理：在显存中保存高度压缩的完整纹理集，并为当前场景的纹理子集使用一个对 GPU 有好的格式。\n相较于常用的压缩手段 (RLE, LSW, Deflate)，这种特殊的压缩方式提供了更好的压缩比。对于游戏主机，也能够让开发者在一张光盘里存放更多内容。\n例如，IdTech5 引擎 (4) 使用的虚拟纹理技术可以将类似 JPEG 格式的纹理加载并实时转码至 DXT。不过这两种格式都会引入压缩伪影。\n说到这里，就需要提及一下其他出版物中， Olano 等人 (5) 提出的与 mip-map 紧密耦合的有损和无损压缩方案，以及 Ström 等人 (6) 提出的针对 ETC 格式再进行无损压缩的方案。\n速度与质量 #  虽然原始图像与重建图像之间的区别很大程度取决于压缩格式，压缩算法在其中也起着重要作用。显然，基于穷举搜索的算法能够以性能为代价获得最好的质量。对于大多数算法来说，以合理的速度获得良好的质量仍是一项艰巨的任务。如上所述，在比较纹理压缩的质量时，必须详细说明如何进行压缩以及使用哪种算法。\n解压算法同样能够影响图像质量。例如，在 GeForce/GeForce2 的芯片中硬件实现的 DXT1 解码器，所有内部色彩指令均工作在 16 位模式下，而不会转换到 24 位模式 (7) 。因此会在解压时引入额外的伪影 (见图3) 。\n [图3]: 压缩的伪影。A - 未压缩，B - S3 Savage2000 上的 DXT1，C - NVidia GeForce 256上的 DXT1 (来源：iXBT (7) )\n 传统的实时 3D 图形会采用离线压缩器对纹理进行预压缩。而现代的渲染引擎越来越多使用大量动态生成的数据，如：用于模拟反射的环境贴图、延迟着色中使用的 G-Buffer 等。这就使得实时纹理压缩 (纹理会在每一帧都进行压缩) 有了用武之地。实时压缩也会用于低延迟高分辨率的视频流，如 UltraGrid (8) (9)。\n虽然针对某些格式的快速压缩算法早已存在 (10) (11) (12)，但由于硬件限制，针对动态生成数据的压缩仍需要新的方法。\n例如，像素着色器无法访问相邻的像素。为了避免可能的像素重叠，因此一个瓦片的结果只有在整帧渲染结束之后才能访问。 解决这些问题的方法之一是使用 tile-based GPU 架构。尽管纹理在被送入显存后也可以被压缩，但当前的 3D API (D3D 11.2, OpenGL 4.4) 所引入的数据复制开销大大削弱了这种方法的效率(13)。\n在本文中，我们将会更详细讨论一些知名的纹理压缩格式：\n S3TC 系列，应用于个人电脑 针对移动端设计的 ETC 和 PVRTC 系列 以及 ASTC，适用于全平台的新格式  早期的重要工作 #  最简情况下，一个像素的编码可以直接用一个数字 (通常为 4 位或 8 位 ) 表示，对应调色板上的一个索引。这个技术在早期广泛应用于视频适配器或游戏主机上，用以降低视频帧缓冲器的大小和带宽。然而，调色板并不太适用于纹理压缩，原因如下：\n 低压缩比 (比较典型的为 8bpp) 受限于调色板的色彩上限，质量差 (8bpp 时只有 256 色) 两次内存访问 (一次纹素，一次调色板) 占用了更高的带宽，同时也增大了延迟。尽管调色板的内存可以作为一个专用的 RAM 来实现，但每次访问新的纹理时，仍需重写调色板。  调色板压缩是矢量量化 ( VQ - Vector Quantization) 的一个特例，矢量是单个像素。世嘉 Dreamcast 游戏机使用了一种更为复杂的 VQ 压缩，在压缩比为 1:5 和 1:8 时纹理质量尚可。\n块 (block) 压缩是一种替代方案，采用固定大小的块压缩。由于每个压缩块包含解码整个瓦片所需的所有信息，解码可以只读取一次内存。\n最早的块压缩方案之一是块截断编码 ( BTC - Block Truncation Coding) ，用于压缩灰度图。该算法的核心思想是保存两份样本矩：均值和方差。每个块会通过使用 “a” 和 “b” 两个值进行重建 (见图 4 )。一个压缩块由这两个值和一个位图组成，其中每个位对应一个纹素。\n [图4]: BTC 编码的例子。A - 源块，B - 位图，C - 解码块\n BTC 编码需要几步来完成：首先，将一张图像拆分成 $M * N$ (通常为 $4 * 4$ ) 大小的小块。然后针对每个区块计算平均值 $\\overline{x}$ 和 标准差 $\\sigma$ 。接着，构建位图，如果对应的纹素值大于均值则将该位置 1。最后则会根据如下公式计算 $a$ 和 $b$ 的值。 $$ a = \\overline{x} - \\sigma \\sqrt{\\frac{m-q}{q}} \\tag {1.1} $$\n$$ b = \\overline{x} + \\sigma \\sqrt{\\frac{(m-q)}q} \\tag{1.2} $$ 其中 $m$ 是一个块中纹素的数目， $q$ 是位图中 1 的数目。\nBTC 以简单的编码和轻量的解码算法，实现了良好的压缩比。对于 4x4 的瓦片， 可以达到 1:4 或 2bpp。它曾用于压缩火星探路者的漫游车图像 (15)。\n对于彩图，则可以对每个通道分别使用 BTC 算法，能达到 6bpp 的压缩比。不过这种方案会显著降低画质 (见图 5)。而基于 BTC 的 CCC (Color Cell Compression) 算法则能达到 2bpp 到 3bpp 。与 BTC 相似，CCC 把所有值量化为两个值，三条通道共享一张位图。\n  CCC 的编码算法与 BTC 相似。 首先逐纹素计算亮度 $Y$ 以及平均亮度 $\\overline Y$ (见等式$(1.3)$) 。然后通过比较每个纹素的亮度和平均亮度来构建位图。最后确定基色 $ a $和 $ b $。 $$ Y = 0.3 * R + 0.59 * G + 0.11 * B \\tag{1.3} $$ 有两种 CCC 算法，第一种以 RGB565 格式直接将 $a$ 和 $b$ 存储在压缩块 中， 因此一个块有 48 位 (每个基色各 16 位，位图 16 位 ) 可以达到 3bpp 的压缩比。第二种则是用一个 8 位的调色板索引替代原有的基准色，从而达到 2bpp的压缩比。当然这个版本的 CCC 也会有调色板压缩的缺点。\nCCC 算法兼具高压缩比和低成本硬件实现。由于一个块中只有两种颜色，导致画质损失严重。但其主要思想被应用于现代的纹理压缩格式中，这便是我们接下来要讨论的。\nS3TC 系列 #  S3TC (S3 Texture Compression) 最早由S3公司研发并取得专利。自1999年推出以来，它已被广泛接受为行业标准，且至今仍是最常见的压缩方案之一。 微软将 S3TC 引入其 3D 图形API DirectX 6.0，名称为 DXT1。而它的带有 Alpha 通道的纹理的修改即为现在大家所熟知的 DXT2-DXT5。这些格式统称为 DXTC (DirectX Texture Compression) 。DXT1 在 OpenGL 和 OpenGL ES 中也通过 EXT_texture_compression_dxt1 扩展得以支持。这个扩展属于 EXT_texture_compression_S3TC的一部分，其余部分也描述了 DXT3 和 DXT5。\n从 DirectX 10 开始，这些格式又被称为 BC1-BC3 (块压缩) 。同时添加了两种新的格式： BC4 和 BC5，它们早期被称为 ATI1/3Dc+ 和 ATI1/3Dc。3Dc格式是由压缩法线图的需求所催生的。DXT1 被设计来压缩彩色数据，在压缩法线数据时效率不高。BC4 和 BC5 的功能在OpenGL中对应 EXT_texture_compresion_rgtc(19) , ARG_texture_compresion_rgtc (20) 以及 EXT_texture_compresion_latc (21)这些扩展。\n随着 DirectX 11 的发布 ，又引入了两种新的格式： BC6H， 第一种是针对高动态范围 (HDR - high dynamic range) 纹理的标准格式；而 BC7，则用于处理非常高质量的压缩。在 OpenGL，两种格式都在 ARB_texture_compression_bptc (22) 规范中有所描述。\n所有 S3TC 系列格式都使用 4x4 的块。我们会在接下来的小节中详细描述这些压缩格式。\nBC1 块 (S3TC/DXT1) #  和 CCC 类似， BC1 也使用 $c0$ 和 $c1$两个基色，以及一张索引表 (位图) (见图6)。不过BC1的索引表每个像素使用了 2 位。这是因为 BC1 允许通过混合两个基色，从而产生 $c2$, $c3$两个新的颜色。所有 $c0, c1, c2, c3$ 一起就构成了一个压缩块的局部调色板。相较于 CCC，引入新色彩无疑让图像质量显著提升。基准色以 RGB565 格式存储，即红色占5bit， 绿色占6bit，蓝色占5bit，能够达到 4bpp 的压缩比。\n [图6]: BC1 块示例\n BC1 块有两种类型，一种不支持透明通道，另一种则支持。\n对于第一种，有两种方法定义 $c2$ 和 $c3$。最常见的实现是：基于等式 2.1，分别以 $1:2$ 和 $2:1$的比例进行线性混合。如果我们假设块中的颜色遵循正态分布，等式 2.2 产生的误差会更小。nVidia 的 GPU (23) 中使用了这种方法。此外，从 RGB565 到 RGB888 颜色转换的硬件实现可能会有一些简化，这也能够影响结果。所以相同的压缩数据在不同的硬件上可能产生不同的结果。对于这两种类型，四种颜色都位于 RGB 空间上以 $c0$ 和 $c1$ 为端点的同一线段上。\n$$ c2 = \\frac {2}{3} c0 + \\frac {1}{3}c1 , c3 = \\frac {1}{3} c0 + \\frac {2}{3}c1 \\tag{2.1} $$\n$$ c2 = \\frac {5}{8} c0 + \\frac {3}{8}c1 , c3 = \\frac {3}{8} c0 + \\frac {5}{8}c1 \\tag{2.2} $$\n第二种类型的 BC1 块允许编码一个 1 位的 alpha 通道，用于处理具有简单透明度的纹理。每个纹素只有完全透明和完全不透明之分。这种模式也称为穿通 Alpha (翻译存疑)。对于这种类型的 BC1 块，$c3$ 以 $1:1$ 线性混合，而 $c2$ 则表示完全透明。第二种类型的块能够更准确地编码一些没有透明像素的原始图像块。 $$ c3 = \\frac{1} {2}c0 + \\frac{1} {2}c1 \\tag{2.3} $$ 在较为原始的实现里，需要一个额外的位来区分第一种和第二种类型的块，但实际上会使用数据冗余来完成。通过交换端点和重新计算索引来对不同类型的同一块进行编码。这样，如果$c0$ (解释为16位整数) 大于$c1$，则将该块解码为第一类型块，否则为第二种类型的块。\n端点的选择对质量有很大的影响。寻找适当的端点 (使误差最小) 很有挑战性。有许多旨在提升速度 (10) (11) (24) 或提高质量 (25) 的编/解码器。\n2004年，nVidia 提出了 OpenGL (26) 的NV_texture_compression_vtc扩展，增加了对 3D 纹理压缩的支持，块大小为 4x4x1、4x4x2、4x4x3 或 4x4x4。但是，此扩展没有提供任何新的压缩方法。一个VTC块由1、2、3或4个独立的 S3TC / BC1 块组成，每个块编码一个二维 4x4 切片。\nBC2 块 (DXT2/DXT3) #  BC1 格式可以处理 24 位的 RGB 纹理，但不适用于 32 位的 RGBA8888 纹理。Alpha 通道可以用于存储透明度、高光或其他材质属性。Direct3D 中的 BC2 和 BC3 格式则专为此类纹理而设计。 BC2 块占用 128 位，是 BC1 大小的两倍。因此压缩级别为 8bpp。BC2 的一半数据用于保存 4 位精度的 alpha 值 (从 alpha a到alpha b) ，另一半是用于存储 RGB 数据的BC1 (见图7) 。实际上，BC2 相当于压缩了RGB通道的格式为RGBA8884的纹理。颜色通道的解码方式与 BC1 相同。唯一的区别是，它始终被视为第一种类型的块。\n [图7]: BC2 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n 要对半透明纹理进行合成或与背景混合，必须将颜色值乘以 Alpha 通道的透明系数。此时，直接将已经预乘的值存进颜色通道中会比较方便。DXT2 格式比较适用于这种情况。DXT3 块布局与 DXT2 一致，但假定颜色值不进行预乘。不过它们的解码程序都相同。格式名称仅用作区分颜色数据的含义。因此，BC3 格式并不对上述情况进行区分，解释数据的责任就落在了应用程序这边。\n需要注意的一点，在进行材质过滤之前，一定要先将颜色值乘以 Alpha。否则过滤的结果就会有误。在进行 Alpha 混合时，预乘 alpha 模式要优于直接存储初始值，并能够简化硬件实现。想了解更多预乘 Alpha 的信息，可参见 «Jim Blinn\u0026rsquo;s Corner: Compositing, Part 1: Theory» (28).\nBC3 块 (DXT4/DXT5) #  BC3 的块 (与 BC2 类似) 由两段64位数据组成：一段是 Alpha 数据，另一段是颜色数据。颜色部分同样使用了 BC1 的格式，但 Alpha 部分则以压缩形式存储 (见图8)。除了通道数外，Alpha 通道的压缩与 DXT1 类似：有两个 8 位精度的端点，3 位的索引表，因此能在局部调色板上 8 选 1。\n [图8]: BC3 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n 这里解码时也使用了与 BC1 相同的数据冗余技巧。如果alpha_0 \u0026gt; alpha_1，则通过线性插值计算局部调色板的六个附加值。否则，仅插值四个值，其余两个对应最大和最小有效值。代码 1 描述了 Alpha 通道的调色板填充过程。BC1 子块始终被视为第一种类型的块，使用公式 2.1 或 2.2。\n [代码1]: Alpha 通道的调色板填充 ( 来源：Programming Guide for Direct3D 10 (27) )\n 和 DXT2 / DXT3 类似，Direct3D 9 中的 DXT4 / DXT5 格式仅在颜色通道数据的含义上有所不同。DXT4 会假定存储的颜色数据已经预乘 Alpha，而 DXT5 则假定不预乘。 Direct3D 10 中只有一种 BC3 格式，因此不区分这两种情况。\n通常，BC3 能提供比 BC2 更好的图像质量，后者更适用于低一致性的 alpha 数据。\nBC4 块 (ATI1/3Dc+) #  BC4 块 (图9) 只是 BC3 块的 alpha 部分。它用于单通道纹理，例如高度图或高光贴图。解码后的值与红通道相关联。\n [图9]: BC4 块布局 ( 来源：Programming Guide for Direct3D 10 (27) )\n  [代码2]: BC4 块调色板填充 ( 来源：Programming Guide for Direct3D 10 (27) )\n BC4块与 BC3 alpha 部分的使用相同的解码方式。但通常单通道数据 (例如位移贴图) 直接将浮点范围限制在 $[0, 1]$ 或 $[-1, 1]$ 内会更方便。因此，通常会直接将其对应到 red_0 和 red_1 两个端点。代码 2 描述了范围为 $[-1, 1]$ 时的调色板填充 。\nBC5 块 (ATI2/3Dc) #  3Dc 格式最初由 ATI 专门为压缩法线贴图而开发，因为 DXT1 并不能达到此类数据要求的质量。顾名思义，法线贴图包含每个纹素的法线的信息，使得可以在不增加几何图形的复杂度的情况下，计算出更高细节的光照 (见图1.B)。法线信息会以范围为 $[-1, 1]$ 的浮点数的形式分别存储在各个颜色通道中。BC1 的问题是不同颜色通道的值通过共用的索引表耦合在一起。这一点用在常规 RGB 图像没有问题，但不适用于通道间互不相关的法线贴图。并且由于局部调色板较小，BC1 显著限制了梯度值。 基于以上原因，使用BC1压缩的法线贴图的质量较差 (见图10) 。\n [图10]: 法线贴图压缩( 来源：ATI 3Dc 白皮书 (29) )\n 根据定义，法向向量具有单位长度，因此只需要指定 $x$, $y$ 值，就可以依照公式 2.4 来计算 $z$。而对于切线空间法向量 (24)，$z$ 值始终为正。 $$ z = \\pm \\sqrt {1 - x^2 - y^2} \\tag{2.4} $$ BC5 其实是一个双重的 BC4。它允许独立存储两个通道 (见图 11)。 同时 BC5 拥有更大的局部调色板，在处理双通道图像时可以获得远超 BC1 的效果。\n [图11]: BC5 块布局( 来源：Programming Guide for Direct3D 10 (27) )\n 每个子块的解码过程与 BC4 完全相同。 默认情况下，不会计算 $z$ 坐标，因为 BC5 格式可用于任意两种成分的纹理，解码后的值会填充红色和绿色通道。对于法线贴图，可以在像素着色器中计算丢失的 $Z$ 轴坐标。\nOpenGL中对应的扩展名为EXT_texture_compression_rgtc (19) ，ARB_texture_compression_rgtc (20) 和EXT_texture_compression_latc (21) 。_rgtc和_latc版本均同时描述了单通道 BC4 块和双通道 BC5 块。在使用_rgtc时，未打包的数据将解释为红和绿通道的值。 在_latc的情况下，未打包的数据将解释为亮度，或亮度和 alpha 值。\nBC6H 和 BC7 的通用信息 #  限制 BC1 压缩质量的主要因素有：\n 端点的精度低 (RGB565)。此外，通道中不均匀的位分布可能会导致颜色偏移。例如，很多纯灰色的颜色不能用RGB56 “精确” 地表示：RGB565 (12,24,12) 就是 RGB888 (99,97,99) 略带紫色，而 RGB565 (12,25,12) 则是偏绿的 RGB888 (99, 101, 99 )。 局部调色板较小。一个块中只能使用 4 种颜色。 所有颜色都位于 RGB 色彩空间中的同一条直线上。 如果原始块中的颜色没有映射到线段，则压缩块可能看起来很差 (见图 12)。   [图12]: BC1 \u0026ldquo;坏掉的\u0026rdquo; 压缩块示例\n 在新格式中，上述问题已经通过提高端点精度以及存储最多 3 对端点解决了。两种格式都使用 128 位块，因此得到了 8bpp 的压缩比。而根据块类型，压缩块会使用不同的字段集，每块字段集的大小也不同。因此可以针对每个块选择最佳编码。这种灵活性极大减少了压缩带来的伪影，但同时也显著增加了压缩复杂度。块类型的数量在 BC6H 中增加到 14 个，BC7 增加到 8 个。 与 BC1 不同的是，块类型会在压缩块的第一位中明确设置。 块类型也称为块模式 (block mode)。\n在利用多个端点对时，一个瓦片会被分为多个纹素组，称为子集 (subsets)。每个子集拥有自己的端点对。有两组和三组纹素的块各拥有64个预定义分区集 (partition set) 。因此只需要将分区 ID 存储在压缩块中就可以指定特定分区。图13 展示了其中一些分区集。\n [图13]: 两组(上) / 三组(下) 纹素块的前 8 个分区集\n  [图14]: 双区瓦片的 BC6H / BC7 块解码的简化示例\n 与之前的格式一样，索引表中的值指定了端点混合的比例。 分区 ID 用于确定每个纹素的端点对。 简化的解码示例如图 14 所示，其中 $A0-A1$ 和 $B0-B1$ 端点对分别用于子集 0 和子集 1。 索引的大小可以是 2 到 4 位。 因此，每个子集中可用的中间颜色数量从 2 到 14 不等。\nBC6H 和 BC7 格式有一个重要特性：位级精确解码。硬件必须返回与参考解码器一致的结果，即使是无效块也应如此。有关所有块模式的详细信息可以参考 Direct3D 11 文档 (30) 和 OpenGL ARB_texture_compression_bptc 扩展规范 (22) 。从 OpenGL 4.2 (31) 开始，此规范成为 OpenGL Core Profile 的一部分。\n端点插值 #  DXT1 格式并没有指定插值 (混合) 程序，因此不同的硬件会使用不同的权重 (见 BC1 ( S3TC / DXT1 )) 。新格式中总是会使用 64 作为系数，并严格定义插值权重。BC7 插值的伪代码如 [代码3] 示，其中 indexprecision  表示单个索引的比特大小，可以是 2，3，4比特。\n [代码3]: BC7 解压过程中使用的插值 (来源: Programming Guide for Direct3D 11 (30) )\n BC6H 的插值过程与之相似，只是使用有符号值，这里不再赘述。\n索引编码 #  DXT1 使用了数据冗余来帮助编码。在 BC6H / BC7 中也采用了同样的技巧来缩小索引表，每个端点对编码为 1 bit。例如，考虑左上角的 texel 0 的索引。如果其最高位为 1，则可以交换相应的端点，使其变为 0。于是总是可以通过重排端点使得子集里的某个索引的最高位为 0。这样的索引被称为锚索引 ( anchor indexes )，且该索引的最高位也不会存储在压缩块中。texel 0 的索引必定是子集 0 的锚索引。图 15 展示了一些分区集的锚索引：\n  BC7 块 #    表 1 展示了所有 BC7 块模式下不同字段的大小 ( NS 和 Format 列除外 )，单位为比特。\n Color - 每个颜色通道占用的大小 Alpha - alpha 通道的大小 P-bit - 是否有 P-bit P-Shared - 是否有共享 P-bit Rotation - ”Rotation“ 的字段大小 ISB - 是否有 idxMode/ISB 索引选择位 (Index Selection Bit) NS - 子集数量 ( Number of Subsets ) PB - 分区索引的字段大小 IB - 索引表中的索引的字段大小 IB2 - 第二个索引表中的索引的字段大小 Table - 索引表的总大小  表 1 中的块模式为最低位在右侧的最低有效字节 (LSB) 的值。 在下文取自 Direct3D 11 MSDN 页面 (30) 的图中 ，模式字段显示为最低位在左侧。 这两个值是序列正好是反的。\nBC7 在模式 0 下的 PB 字段仅有 4 位 (见图 16 )。因此，只有前 16 个分区集可用。而在其他多子集模式中，所有 64 个分区集都可用。\n新字段 P-bit 的含义与 RGBP/RGBAP 缩写中相应的字母 P 的含义，可以看看 BC7 Mode 0 的例子 (见图 16 ) 。块中存储了三个 RGB444 端点对，每个端点都有一个 P 位。端点会在反量化 (译注：量化为数字信号处理术语，此处翻译参考了 MSDN) 之前扩展到 RGB555，而 P-bit 会被解释为每个通道的最低位。相较于直接存储 RGB555，现在每个端点直接省下了 2 比特，精度损失却不超过 1 比特( 所有颜色通道里总共只会有 0 或 1 比特失真 )。\nBC7 在模式 1 时会使用 P-Shared 位。与 P-bit 相似，不过该位会在端点对中共享。\n [图16]: BC7 模式 0 的块布局 (来源: Programming Guide for Direct3D 11 (30) )\n  [图17]: BC7 模式 4 的块布局 (来源: Programming Guide for Direct3D 11 (30) )\n BC7 在 Mode 4 (见图 17) 和 Mode 5 下会有两个独立的索引表，可以用来独立存储四个通道中的一个。适用于像法线贴图这种，其中一个通道与其他通道无关的情况。这两个模式同样适用于分别存储色彩和 Alpha 值，这点和 BC3 有些相似。任何一个通道都可以成为拥有独立索引表的那个，Rotation 字段用于确定是具体哪个通道。\n在BC7 Mode 4下，索引表占用的位长度不一样，所以精度也会不一样。ISB 字段 (图17中的 idxMode) 用于确定表中有多少位用于独立通道，多少位用于其余通道 (译注：MSDN) 。\nBC6H 块 #  BC6H 格式旨在压缩高动态范围的纹理，即 HDR (High Dynamic Range)。仅支持不带 alpha 的 RGB 图像。通道值以有符号或无符号的 16 位浮点数表示。 因此解码器也需要支持两种模式。不仅如此，解码后的数据还需要满足 IEEE 754 half/binary16 格式 (见图 18) 。解码后，数据会以 32-bit 浮点形式返回给 shader。 BC6 的有符号和无符号版本的块模式相同。通常意义上，图 18A 对应有符号的浮点数格式，而 18B 对应无符号浮点数。不过在实践中，解码过程仅会使用整数算数运算。有符号、 无符号的解码模式仅在反量化期间对符号位的处理有所不同。\n [图18]: 16位精度的浮点数格式。A - signed, B - Unsigned.\n BC6H 共有14种块类型 (见表2 ) ， 只支持 1 到 2 个纹素组。PB 字段 (Partition ID) 始终为 5 位。 因此，只有前 32 个分区集可用。在大多数情况下 (模式 10 和 11 除外) ，端点使用增量编码存储：直接存储一个端点，再存储其他端点的偏移量。\n [表2]: BC6H 在不同块模式下的各字段的尺寸\n 上文中提到，即便最终值被解释为浮点数，解码和插值时也只会使用整数算数运算。其原理基于浮点数的编码 (图18) ，其中指数偏移值位于高位，小数部分 (隐含 1 ) 位于低位。将这样的二进制编码解释为整数也同样具有数学意义。尤其是，相邻的浮点数也具有相邻的整数表示。对于任意正的 $A$ 和 $B$ ， 如果 $A \u0026gt; B$， 那么二进制解释成为整数时也满足 $A\u0026gt;B$ 。代码 4 中展示了作用于浮点数的整数运算示例。当线性插值作用于具有不同指数偏移的浮点数的整数表示时，变换中将含有指数 (对数) 运算 (见图 19 ) 。\n   [图 19]: 插值示例。 “No cast” - 直接对浮点数使用线性插值，\u0026ldquo;Int. Cast\u0026rdquo; - 将浮点数转换为整型后再线性插值。\n 解码过程包含如下四步：\n  符号扩展和 delta 变换反置。 在有符号 BC6H 的情况下，压缩块中存储的所有端点和偏移量 (delta) 都进行了符号扩展 (符号位扩充到了高位) ，在无符号 BC6H 的情况下，只有偏移量进行了符号扩展。 此外，对于所有块类型，除了模式 10 和模式 11 之外，其余的端点都是通过将相应的偏移值添加到直接存储的端点来恢复的。 在模式 10 和模式 11 块中，所有端点都直接存储。\n  端点的反量化。 对于无符号 BC6H，反量化过程如 (((X \u0026lt;\u0026lt; 16) + 0x8000) \u0026gt;\u0026gt; uBitsPerComp)，其中 uBitsPerComp 是直接存储的端点的一个通道的大小 (bits) 。 边界条件 (zero, max value) 会单独考虑。\n  线性插值过程与 BC7 类似。考虑到有符号和无符号格式的存在，未量化值的范围为 -32768 到 65535。因此，插值器使用了17-bit的有符号代数运算。\n  最后的调整或反量化。 由于在 IEEE 754 中使用指数字段的最大值 (全部为 1) 来编码特殊的 INF/NaN 值，因此有符号格式下，插值之后的值按 $31/32$ 缩放，而无符号格式按 $31/64$ 缩放。 最终结果是一个合法的 16 位半浮点数。\n  ETC 系列 #  ETC (Ericsson Texture Compression) 格式最初是针对移动设备开发的。 今天 (译注：2014 年)，它是基于 Android 系统的设备的标准压缩方案。 OpenGL ES 和 WebGL 通过 (33) 和 WEBGL_compressed_texture_etc1 (34) 扩展支持 ETC1 格式。 ETC1 和 ETC2 规范则从 OpenGL 4.3 (35) 以来，成为 OpenGL Core Profile的一部分。\n第一个版本的压缩方案 PACKMAN 于 2004 年推出 (3)。 而后在 2005 年，被称为 iPACKMAN 的增强版被提出 (36)。 该版本更为人知的名称是 ETC1，广泛应用于移动设备。 该方案的后续发展，催生了 2007 年 ETC2 格式 (37)。\n [图20]: PACKMAN的核心思想。(来源: ETC2 论文 (37))\n ETC 压缩的核心是基于：人眼对亮度而不是色度更敏感这一事实。 因此，每个子块中仅存储一种基色 (ETC1/ETC2 由两个子块组成) ，但亮度信息是按每个纹素存储的 (见图 20)。 亮度偏移由单个整数值设置，最终会和每一个颜色分量相加。 一个子块内只有四种不同的亮度偏移可用，即只有四种不同的颜色可用。 可以认为这些颜色就是一个局部调色板。\nETC1 (38) (39) 和 ETC2 (40) (41) 的对应专利属于瑞典爱立信公司 (Telefonaktiebolaget L. M. Ericsson)。\nPACKMAN #  如果压缩块占用的位数与总线宽度相同，则可以避免管线停顿，从而简化硬件实现 (3)。由于移动设备在内存大小和总线宽度方面受到严格限制，PACKMAN 决定使用 2x4 的块。因此压缩块仅占用 32 位，压缩比为 4bpp，等于 BC1 的压缩比。\n块中仅存储一种 RGB444 基色 (译注：12bits) 。 其他颜色是通过改变纹素的亮度取得的 (译注：每个纹素 2bits， 共16bits) 。 虽然基本思想与 BC1 区别巨大，但解码过程却非常相似。 首先，恢复四色局部调色板。 然后根据索引表从该调色板中挑选颜色 (见图 21) 。 不过由于块尺寸小，只剩下 4 位用于存储亮度变化和调色板中的三种附加颜色。 因此，这 4 位的编码被直接用于指向预定义的亮度集 (见表 3) 。\n [图21]: PACKMAN 块解码示例。\n    Index 0 1 2 3 4 5 6 7     Luminance 00 2 4 6 12 8 19 28 42   Luminance 01 8 12 31 34 50 47 80 127   Luminance 10 -2 -4 -6 -12 -8 -19 -28 -42   Luminance 11 -8 -12 -31 -34 -50 -47 -80 -127     [表3]: PACKMAN 亮度码表的前半部分\n 可以看到，表 3 的下半部分是上半部分对应的负数，这点能用于简化解码器。 亮度组 8-15 (未在表中显示) 的值为0-7的 2 倍 。 这张表基于随机值生成，然后以将测试图像的误差降到最小为指标来进行优化 (3) 。\nETC1 ( iPACKMAN ) #  单一的低精度 (RGB444) 基色是 PACKMAN 中图像质量的主要限制因素。 这个问题在 ETC1 中得到了解决。\nETC1 瓦片的大小是 4x4，它由两个子块组成，和在 PACKMAN 中的块一样。 这些子块可以垂直或水平排列，为瓦片内基色的选择提供了更大的灵活性。 差分块 (Differential) 类型的引入，提升了精度。第一个子块的基色以 RGB555 精度存储，第二个基色存储 3bit 差异值。 将两种基色直接以 RGB444 格式存储的块称为独立块 (Individual) (见图 22) 。\n [图22]: ETC1 的块布局。\n    N 0 1 2 3 4 5 6 7     Luminance 00 2 5 9 13 18 24 33 47   Luminance 01 8 17 29 42 60 80 106 183   Luminance 10 -2 -5 -9 -13 -18 -24 -33 -47   Luminance 11 -8 -17 -29 -42 -60 -80 -106 -183     [表4]: ETC1 和 ETC2 的亮度码表\n 为了给块类型编码保留空间，亮度码本减少到 8 组，因此索引大小 (图 22 上的 T0 和 T1) 下降到 3 bits 。显然，码本中的值也经过重新计算 (见表 4) 。 因此腾出了 2 bits 空间，其中一个 “diff” 位用于指定块类型，另一个 “flip” 位指定子块的垂直或水平排列。\nETC2 #  差分模式和可旋转子块显着提高了图像质量。 然而在每个子块中只有一种基色可用，这导致颜色变化剧烈的图块会被压缩后会有更高的错误率。 此外，即使是平滑梯度在 ETC1 下也可能会产生问题。\nETC2 通过引入额外的块模式来解决上述问题。 这些新模式对在 ETC1 方案中无效的块进行编码，使得 ETC2 解码器与 ETC1 格式完全兼容。 当基色和偏移的总和溢出了 5 bit 的有效范围 [0, 31] 时，差分块中就会出现无效组合。 而这些 “无效” 块会使用一种新模式进行解码。 能够导致溢出的所有 R0 和 dR1 组合如表 5 示。\n   R0 dR1 R0, dR1 binary Encoded value     0 -4 00000 100 0000   0 -3 00000 101 0001   0 -2 00000 110 0010   0 -1 00000 111 0011   1 -4 00001 100 0100   1 -3 00001 101 0101   1 -2 00001 110 0110   29 3 11101 011 0111   2 -4 00010 100 1000   2 -3 00010 101 1001   30 2 11110 010 1010   30 3 11110 011 1011   3 -4 00011 100 1100   31 1 11111 001 1101   31 2 11111 010 1110   31 3 11111 011 1111     [表5]: 所有会导致溢出的 R0 和dR1 组合。\n 此类块中的有效载荷为 59 bits。 64 bits 中的 1 bit 用于 diff 位，8 bits 用于 R0 和 dR1 值，还剩 55 bits。 但是，可以使用 R0 和 dR1 的两个最低位来编码附加信息 (表 5 中的 Encoded value 列) 。\n绿通道中的溢出可用于编码另一种模式。 但载荷会更少，因为这个块在红色通道中一定不能有溢出。 否则会被视为前一种类型的块。 不过好在只占用了 1 bit。 R0 的两个最高位的不相等可以保证不会有溢出，这点可以在表 5 中观察到。在第二种模式中可以使用总共 58 bits。\n类似地，蓝通道溢出的第三种模式提供 57 bits 有效载荷。 表 6 中列出了所有块模式。\n    diff Overflow Overflow Overflow     Block mode diff R G B   Individual 0 - - -   59-bit mode (T-mode) 1 yes - -   58-bit mode (H-mode) 1 no yes -   57-bit mode (Planar mode) 1 no no yes   Differential 1 no no no     [表6]: ETC2 的块模式。\n 与独立模式和差分模式类似， T 形块和 H 形块都使用低 32 bits 存储索引表。但局部调色板使用的是不同的方式解码：$A(r_0, g_0, b_0)$ 和 $B(r_1,g_1,b_1)$ 以 RGB444 格式压缩在 T 块中， 其余 3 bits 则用于编码 d 值。A，B 的值将反量化为 RGB888。另外两个局部调色板的颜色用这个方法计算: $C0 = (A - (d, d, d))$，$C1 = (A + (d, d, d))$。因此局部调色板在色彩空间中呈现 T 形 (见图23) 。此模式适用于那些，大多数点位于一条线上，而有些纹素又是其他颜色的块。这里需要强调一点，距离 d 是间接存储的：3bits 字段用于存储查找表 (LUT) {3,6,11,16,23,32,41,64} 的索引，T 形块和 H 形块相同 。\n [图23]: T形块的原始块和调色板的颜色分布。(基于: ETC2 论文 (37) )\n H 模式与 T 模式非常相似，存储着颜色 A、B 以及 d 值的索引。但局部调色板中使用的是 c0、c1、c2、c3 而非 A、B、C0、C1 (见图 24) 。这些颜色在 RGB 空间中形成 H 形。此模式适用于那些，颜色位于两条线上的块。然而 H 形块的有效载荷要比 T 形块少 1 比特，但是又必须存储同样多的数据 (两个 RGB444 颜色和一个用于查询 d 值的索引) 。这里使用了 BC1 中的技巧 (译注：冗余编码) ，由于 H 形是对称的，因此 A、B可以互换，基于此就可以补足缺失 bit 的信息。\n [图24]: H形块的原始块和调色板的颜色分布。(基于: ETC2 论文 (37) )\n Planar 模式用于对平滑梯度编码。所有 57bits 用于存储 RGB676 格式的三种基色 C0、CH、CV (见图25) ，所有纹素的颜色使用线性滤波方程 3.1 计算，其中 X 和 Y 的范围为 [0, 3]。 $$ C(x, y) = \\frac{x(C_H-C_0)}{4} + \\frac{y(C_V-C_0)}{4} + C_0 \\tag{3.1} $$  [图25]: ETC2-Planar 块的基色坐标以及解压示例。\n 除了 RGB 版本，OpenGL 中还有一个\u0026quot;穿通 Alpha\u0026quot; 版本的ETC2： 一个 RGBA8881 纹理。其中没有独立块类型，因此仅仅通过是否溢出来区分 T、H 和 Planar 模式。Diff-bit 用于指定差分子模式。如果是 “1” ，差分块像之前一样解压，如果是 “0”，索引 “10” 保留给全透明颜色 (见表 7) 。 T、H 和Planar 块的解码过程保持不变。\n   N 0 1 2 3 4 5 6 7     Luminance 00 0 0 0 0 0 0 0 0   Luminance 01 8 17 29 42 60 80 106 183   Luminance 10 T T T T T T T T   Luminance 11 -8 -17 -29 -42 -60 -80 -106 -183     [表7]: ETC2 “穿通 Alpha” 的亮度码表。(T - 透明 (transparent) )\n EAC #  ETC2 无法维护许多类型纹理所必需的、完整的 alpha 通道。此外，ETC2 不支持对二分量图像进行高质量的压缩，因此不适用于法线贴图。对于这种情况，可以使用名为 EAC 的 64bits 块。EAC 以高精度编码单通道的 4x4 的块。OpenGL中，还定义了如下包含 EAC 作为子块的格式：\n COMPRESSED_RGBA8_ETC2_EAC /COMPRESSED_SRGB8_ALPHA8_ETC2_EAC (类似于BC3) —— 是一个 128 bits 块，一个 64 bits ETC2 块存储 RGB 通道，一个 64 bits EAC 块存储 alpha 通道。 COMPRESSED_R11_EAC / COMPRESSED_SIGNED_R11_EAC (类似BC4) —— 是一个存储红通道的 64 bits EAC 块。 COMPRESSED_RG11_EAC / COMPRESSED_SIGNED_RG11_EAC (类似BC5) —— 是一个 128 bits 块，由两个 64 bits EAC 块组成，用于存储红色和绿色通道。  简洁起见，这里将仅详细描述COMPRESSED_RGBA8_ETC2_EAC 块。 所有 ETC 和 EAC 选项在 OpenGL 4.4 Core Profile 规范 (42) 中有详细描述。\nEAC 压缩方案复用了 ETC 中的思路，但针对单分量图像：整个 4x4 切片仅存储一个基值，并且每纹素索引用于调制其亮度 ( $Luninance$ ) (见图 26) 。 和上文中一样，有一个预定义的亮度码本 (见表 8) 。 特定亮度集 (N) 的索引直接存储在压缩块中。唯一新增的就是亮度修饰符的值需乘以 Mul 值，Mul值也直接存储在压缩块中。纹素值使用公式 3.2 计算，其中 clamp255 将值限制在 [0, 255] 范围内。 $$ A = clamp255(base+Mul \\times Luninance) \\tag{3.2} $$ 基值以 8 bits 精度存储 (见图 26) 。 使用了 3 bits 索引，因此局部调色板中最多可以使用八个不同的值。\n [图26]: EAC 的块布局。\n    N 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15     Luminance 000 3 -3 -2 -2 -3 -3 -4 -3 -2 -2 -2 -2 -3 -1 -4 -3   Luminance 001 -6 -7 -5 -4 -6 -7 -7 -5 -6 -5 -4 -5 -4 -2 -6 -5   Luminance 010 -9 -10 -8 -6 -8 -9 -8 -8 -8 -8 -8 -7 -7 -3 -8 -7   Luminance 011 -15 -13 -13 -13 -12 -11 -11 -11 -10 -10 -10 -10 -10 -10 -9 -9   Luminance 100 2 2 1 1 2 2 3 2 1 1 1 1 2 0 3 2   Luminance 101 5 6 4 3 5 6 6 4 5 4 3 4 3 1 5 4   Luminance 110 8 9 7 5 7 8 7 7 7 7 7 6 6 2 7 6   Luminance 111 14 12 12 12 11 10 10 10 9 9 9 9 9 9 8 8     [表8]: EAC 的 Mod 值\n 例如，考虑一个压缩块，其中 base = 0b11011110，mul = 0b1010，N = 0b1101，特定纹素的索引为 0b0012。转换为十进制后，base = 222，mul = 10，N = 13。在此示例中 N 对应于亮度集 {-1, -2, -3, -10, 0, 1, 2, 9} (表 8 中的第 13 列) ，纹素索引 0012 从该集合中选取 mod 值，mod = -2。将这些值代入公式 3.2 后，$A=clamp255(222 + 10 × (-2))$ ，即， $A=202$。\nPVRTC 系列 #  PVRTC (PowerVR Texture Compression) 格式 (14) 是由 Imagination Technologies (43) (44) (45) (46) 持有专利，专为 PowerVR 图形核心系列设计的。 用于 Apple 移动设备，例如 iPhone 和 iPad。 不久前针对新的图形核心，引入了增强版的 PVRTC2。 OpenGL ES 中 IMG_texture_compression_pvrtc (47)、IMG_texture_compression_pvrtc2 (48) 和 EXT_pvrtc_sRGB (49) 扩展支持这两种格式。 对应的的 WebGL 草案扩展为 (50)。\n相较于本文中的其他技术，PVRTC 或许是最封闭的。除了 Simon Fenney (14) 最早的关于 PVRTC 论文 《使用低频信号调制的纹理压缩》(Texture Compression using Low-Frequency Signal Modulation) 以及Imagination Technologies 网上的几篇博客之外(51) (52) (53)，没有其他公开的技术信息了。即使是 OpenGL 和 WebGL 的扩展标准中也没有提供任何实现细节。尽管如此，crunch 纹理压缩库的开发者 R.Geldreich 为 PVRTC 压缩器的实现也作出了相当一部分努力 (54) (55)。\nPVRTC 压缩技术比较有趣，和前述中提到的技术有很大不同。严格来讲，PVRTC 并非基于块的编解码器。核心思想与小波压缩有一些共通之处，即整张图像被分成低频和高频信号。低频信号由两张低分辨率图像 A 和 B 呈现，在两个维度上都按比例缩小了 4 倍。高频信号是完整分辨率低精度的调制信号 M。要解码整张图像，首先应放大图像 A 和 B，然后使与调制信号 M 混合，其中调制信号 M 指定了每个纹素的混合权重 ( 见图 27) 。\n [图27] : PVRTC的核心思想 (源自: PVRTC 的论文 (14))\n 有别于其他压缩方案，PVRTC 利用了跨块边界的颜色的相似性。因此这种方案本身支持平滑梯度。同时没有块伪影。此外，它还利用了实际纹素坐标与其颜色值的相关性。类似 BC 和 ETC 的方案利用了块内颜色的相似性，但只关注于颜色集合，而非特定颜色的位置。 也就是说，图块内的所有纹素都可以随机重排，同时 BC 编解码器仍可以生成完全相同的局部调色板。 但 PVRTC 可能会丢失压缩纹理中的一些高频细节。\nImagination Technologies 已将对 PVRTC2 的支持添加到其最新的 PowerVR 图形核心系列 – PowerVR Series5XT 和 PowerVR Series6 (51) (52) (53)。 PVRTC 和 PVRTC2 两个版本都有 4bpp 和 2bpp 模式。\n随着 PVRTC2 的发布，产生了新的命名混乱。 在原始 PVRTC 格式引入时，PVRTC2 和 PVRTC4 缩写分别成为 2bpp 和 4bpp 模式的流行标签。 但由于缩写之一与新格式的名称相同。 因此建议使用以下别名：PVRTC 4bpp、PVRTC 2bpp、PVRTC2 4bpp、PVRTC2 2bpp (或 PVRTCII 2bpp/4bpp) 。\nPVRTC 4bpp #  从性能的角度来看，访问三个不同的图像来解包单个 texel 或 tile 看起来不是很妙。 因此，所有数据以 64 比特的块存储在一处。 每个块由图像 A 的一个像素、图像 B 的一个像素和相应的 4x4 调制系数区域组成 ( 见图 28) 。\n [图28]: PVRTC 4bpp 的块布局。\n 任意 A 和 B 颜色都能以 RGB 或 RGBA 格式存储。 两个颜色字段中的最高位决定使用哪种格式。 但是，色域 A 比色域 B 小一位。因此，色 A 可以用 RGB554 或 ARGB3443 编码，色 B 用 RGB555 或 ARGB3444 编码。\n通常来讲，必须读取四个相邻的 PVRTC 块才能对任意纹素进行解包 (见图 29) 。 因此需要恢复已经放大的图像 A 和 B 的相应区域。 4 个相邻 PVRTC 块的包含的信息就能够解码一个 5x5 块。 解码示例如图 30 所示。\n [图29]: 可以使用 4 个相邻 PVRTC 块解码的纹理区域。\n  [图30]: PVRTC 4bpp 解码示例。\n 放大过程使用双线性滤波。然后使用逐纹素索引确定图像 A 、B 的混合权重 (见表 9 ) 。Mode-bit (见图 28) 用于穿通 alpha 模式。此模式允许对 1 位 alpha 通道进行编码，而不损失 RGB 通道的精度。 当模式位为“1”时，索引“10”保留给全透明值。\n   Index (modulation data) Modulation value (Mode=0) Modulation value (Mode=1)     00 0/8 0/8   01 3/8 4/8   10 5/8 4/8 (+ «punch through alpha»)   11 8/8 8/8     [表9]: PVRTC 中使用的模式值\n 需要说明的一点是，尽管基本思想不同，但 BC1 方案可以被视作 PVRTC 的一个使用阶跃函数执行放大的特例。\n初看起来读取四个块可能对性能影响会很大。 但其实纹理缓存减少了负面影响，因为相邻区域需要更少次数的内存访问。 此外，双线性以及更复杂的过滤类型对于 3D 渲染几乎是不可或缺的。因此，每个纹理获取操作至少需要 2x2 源纹素。 当这些纹素位于相邻的块中时，在 BC/ETC 压缩的情况下也必须读取两个或四个块。 对于任何 PVRTC、BC 或 ETC 方案，最坏的情况都需要四个块。\n由于单块影响的面积大，因此压缩过程会复杂一些。 修改任意基色 (A 或 B) 会改变最近的 7x7 区域内的所有纹素 (见图 31) 。此功能使得动态纹理合成和创建纹理图集变得更加复杂。因此，纹理图集的各个元素必须有边界填充。\n [图31]: 一个 PVRTC 块影响的区域。\n PVRTC 2bpp #  PVRTC 有一种压缩比极高的模式，仅有 2bpp。它与 4bpp 模式相似，并且使用相同的块布局 ( 见图 32) 。不过图像 A 和 B 在水平维度上又缩小了一半。因此 ，32 位调制字段必须保存 8x4 纹素的调制信息。Mode-bit 指定了调制数据的编码。 如果是 $0$，则每纹素存储 1-bit 在调制字段中。 否则，将存储 2-bit 索引，但仅对以棋盘模式排列的一半纹素。随后通过平均相邻的两个或四个调制值来计算剩余纹素的调制值。\n [图32]: PVRTC 2bpp 块的布局。\n PVRTC 2bpp 解码的简化示例如图 33 所示。假设所有四个压缩块中的 Mode位均为0。\n [图33]: PVRTC 2bpp (Mode = 0) 解码示例。\n PVRTC2 4bpp #  PVRTC2 增强了压缩质量，并消除了 PVRTC 的一些不足之处。例如，PVRTC2 支持 NPOT 纹理 (Non Power Of Two) ，两个维度的分辨率都可以不为 2 的幂。此功能与压缩方案没有直接关系，但需要一定的硬件支持。 尤其是，硬件应该能够正确计算被请求的压缩块的地址。\n类似于之前的做法，可以通过引入新类型的块或解码模式以改善质量。在 PVRTC 中，基色 A 和 B 各自可以独立选择使用 RGB 或 ARGB 存储格式。 然而通常是两种颜色具有相同格式。因此，在 PVRTC2 中仅使用一个位 (Opacity) 来指定两种颜色的格式，第二个位 (Hard) 用于编码新模式 (见图 34) 。\n [图34]: PVRTC2 块的布局。\n “Hard”位和“Mode”位一起能够表示四种解码模式 (见表 10) 。\n   «Hard» bit «Mode» bit Decoding mode     0 0 标准双线性插值   0 1 穿通 alpha   1 0 无插值   1 1 局部调色板     [表10]: PVRTC2 4bpp 的块模式。\n \u0026ldquo;标准双线性插值\u0026rdquo; 和 \u0026ldquo;穿通Alpha\u0026rdquo; 的解码方式与上文提到的 PVRTC 相同，不过在 alpha 模式中会有一些变化。在 \u0026ldquo;穿通 alpha\u0026rdquo; 模式下透明的索引也会将颜色值设为 0。 这其实是预乘 alpha (参阅 BC2 块 (DXT2/DXT3)) ，方便进行混合和过滤。另一个变化与 alpha 值反量化过程有关。 现在，A 和 B 图像的 alpha 值以些微不同的方式转换为 8 比特格式，如代码 5 所示；AlphaA3、AlphaB3 – 是 3 bit 打包的 alpha 值，而 AlphaA8、AlphaB8 – 是未打包的 8 bit 值。如果仔细观察，会发现 AlphaA8 不会等于 “255”，AlphaB8 不会等于 “0”，不过倒也不是什么问题。\n [代码5]: PVRTC2 解压时 Alpha 转换至 8 位。\n 新的模式，将 \u0026ldquo;Hard \u0026ldquo;位设置为 \u0026ldquo;1\u0026rdquo;，简化了纹理图集的创建，并改善了某些对 PVRTC 块来说相对困难的情况下的压缩质量。在 \u0026ldquo;无插值 \u0026ldquo;模式下，图像A和B被放大，没有插值。相反，所有相应的像素都有相同的基础颜色。随后的解码过程与PVRTC中的解码过程相同。必须指出的是，\u0026rdquo; Hard \u0026quot; 标记会影响偏移量为 [2, 2] 的 4x4 纹素区域 (见图35) 。对于边界块，\u0026rdquo; Hard \u0026quot; 标志区域是环绕 ( wrap )，就和环绕的纹理映射一样。\n [图35]: Hard 标记影响的区域。\n 这种模式的解码例子见图 36。其类似于 S3TC 压缩。事实上，如果所有相邻的块都有标志 Hard=1 和 Mode=0，那么对应于一个 PVRTC 块的纹理解码将与 BC1的解码方案相同。因此，这种模式可用于对纹理图集中单个元素的边界进行编码。\n [图36]: PVRTC2解码示例, Hard = 1, Mode = 0 (无插值)。\n 在 \u0026ldquo;局部调色板 \u0026ldquo;模式下 (Hard=1，Mode=1) ，A和B不会混合。局部调色板由来自四个相邻的 PVRTC2 块的 A 、 B 对填充，共有8种颜色。但一个索引的大小只有2 比特，这意味着这 8 种颜色中只有 4 种可用于每个特定的纹素。图 37 显示了每个纹素可用的颜色集，其中描述了解码所需的四个 PVRTC2 块。P 块指定了灰色阴影区域纹素的解码模式。每个块中存储的 A 和 B 的颜色分别表示为 Pa, Pb, Qa, Qb, Ra, Rb, Sa, Sb。每一个纹素的颜色都可以在放大的 4x4 区域内描述。唯一的例外是最左上方的texel P* ：它的颜色是由 Pa 和 Pb 混合得到的。\n [图37]: 逐像素可访问的局部调色板模式。 (来源: 美国专利 8526726 (46))。\n ASTC 格式 #  ASTC (自适应可扩展纹理压缩) 是由 ARM 和 AMD 联合开发，并于2012年提出的(56)。格式规范 (57) 被 Khronos 联盟批准并在 OpenGL 中采用。在 OpenGL 和 OpenGL ES 中对应的扩展为KHR_texture_compression_astc_hdr (58)。从 Mali-T628 和 Mali-T678 开始，所有 ARM 图形核心都有 ASTC 硬件支持(59)。专利 (60)(61)(62)(63) 归 ARM 所有。尽管如此，仍需要指出，ASTC 是完全开放和免专利费的。\n以下每个用例都对压缩方案有自己的要求：\n 支持从 1 到 4 个分量的纹理。虽然单通道纹理也可以使用BC7、PVRTC2或ETC2来存储，但空通道上大量bit被浪费掉了。 在通道之间数据无相关性的情况下，拥有可以接受的质量。这对于法线图和 RGBA 图像来说非常重要。 支持 LDR 和 HDR。BC6H可用于HDR纹理压缩，但它不支持alpha通道。 跨平台。特别是：PVRTC 只在 iOS 平台上可用，BC6H/BC7 在移动设备中缺失，ETC 不被桌面级 GPU 所支持。对于跨平台应用程序的开发者来说，有诸多不便。 比特率/质量比的灵活性。根据纹理类型，不同程度的压缩伪影是可以接受的，因为不同图像的可压缩性是不同的。前文中提到的格式里，能提供的比特率/质量选项的不超过两个 (BC1/BC7或PVRTC 4bpp/2bpp) 。如果不能使用 5bpp 的压缩级别 (如果4bpp的质量略显不足) ，就必须使用8bpp的选项。带宽增加了一倍，但质量却没有明显改善。 支持 2D 和 3D 纹理。  新的压缩方案是在考虑到所有这些要求的情况下制定的。ASTC格式有一个固定大小的 128 位块。然而，对于 2D 纹理，编码的瓦片尺寸从4x4到12x12 纹素不等，3D 纹理则是从3x3x3到6x6x6。所有支持的瓦片尺寸和相应的比特率可以在表11中找到。“Increment”一栏显示，比特率可以在非常细致的级别中进行调整。在ASTC 规范中，瓦片尺寸也被称为块足迹 (block footprint)。\n   № 2D textures   3D textures       Tile size Bit rate Increment Tile size Bit rate Increment    1 4x4 8.00 bpp 125% 3x3x3 4.74 bpp 133%   2 5x4 6.40 bpp 125% 4x3x3 3.56 bpp 133%   3 5x5 5.12 bpp 120% 4x4x3 2.67 bpp 134%   4 6x5 4.27 bpp 120% 4x4x4 2.00 bpp 125%   5 6x6 3.56 bpp 114% 5x4x4 1.60 bpp 125%   6 8x5 3.20 bpp 120% 5x5x4 1.28 bpp 125%   7 8x6 2.67 bpp 105% 5x5x5 1.02 bpp 120%   8 10x5 2.56 bpp 120% 6x5x5 0.85 bpp 120%   9 10x6 2.13 bpp 107% 6x6x5 0.71 bpp 120%   10 8x8 2.00 bpp 125% 6x6x6 0.59 bpp -   11 10x8 1.60 bpp 125%      12 10x10 1.28 bpp 120%      13 12x10 1.07 bpp 120%      14 12x12 0.89 bpp -        [表 11]: ASTC 块大小和压缩比。\n ASTC是文章中描述的最为灵活的格式，因为它支持 LDR、HDR、2D 和 3D 纹理，最多有4个通道。甚至支持低于 1bpp 的比特率。\n概念上讲，ASTC 类似于 S3TC/BC7：一个压缩块中最多存储四个端点对和插值权重，只支持预定义的分区，特定的分区由分区ID指定，也存储在一个块中。在弱相关的情况下，该通道会存储一个独立的索引表。每个独立的编码被称为一个平面。\n或许 ASTC 最主要、最有趣的创新是用小数位编码整数值的技术，称为BISE。同时，BISE可以在硬件中有效实现。\n有界整数序列编码 (Bounded Integer Sequence Encoding (BISE)) #  有界整数序列编码，或称 BISE，解决了如下抽象问题：从大小为 $N$ 的字母表中给定等概率的符号序列， 找到一种编码，使得能够在常数时间复杂度内使用最少的硬件消耗提取第 $i$ 个符号，并允许相同硬件设计能够用于多种不同大小的字母表，同时具备存储效率(64)(65)。\n例如，考虑一个由 5 个整数组成的序列，其中每个整数可以是 0，1 或 2（译者注：5 位的 3 进制数）。使用标准二进制编码时，需要为每个值分配 2 位，总共 10 位。但不同序列的数量是 $3^5=243$，小于 $2^8=256$。因此，可以用 8 比特对整个序列进行编码，每个值的比特率为 1.6。换句话说，可以用8比特来表示5 位的 3 进制数。\n现在，考虑任意长度的序列，其中每个值都属于范围$[0, N-1]$，其中 $N=3*2^n$。每个值都可以用一个三进制位和 n 个比特来表示。假设 $N=12$，那么满足该条件的任何值都可以用以下形式表示: $X = t2^2 + b_{1}2^1 + b_{0}2^0$，其中 $t$ 是一个三进制位，$b_0$ 和 $b_1$ 是比特位。整个序列可以被划分为五组值，最后一组会在必要时填充 0 。二进制形式下，一个特定的组可以表示为一个比特串 $t_4B_4t_3B_3t_2B_2t_1B_1t_0B_0$，其中 $t_i$ 是一个三进制位的 2 比特表示，$B_i$ 是一个值的剩余比特位( 译注: 即上文中的 $b_0$ 和 $b_1$)。只要三进制位与比特信息保持这种相关性，就可以用比特串 $T_{[7]}B_4T_{[6:5]}B_3T_{[4]}B_2T_{[3:2]}B_1T_{[1:0]}B_0$ 保存这五组值。其中 $T_{[i:j]}$ 为 $T$ 的各个比特，这段数据要比原先短 2 比特。\n事实证明，这种编码能够保留尾部的零。例如，如果我们序列中的最后一组被填充了两个零 (所以$t_4B_4$和$t_3B_3$是零) ，那么 $T_{[7]}B_4$ 和 $T_{[6:5]}B_3$ 是零，它们不需要被存储。因此，任何长度的序列，假如其数值范围从 $0$ 到 $3*2^n-1$，都可以用接近于理论上的最小的比特率进行编码。同时，其中的任意值能以最小的硬件消耗容易的提取出来。\n同样的推理也可以应用于$N=5*2^n$的序列。这里，3 个五进制数 (基数为5的数字) 可以用 7 位来编码，因为 $5^3=125$ 小于 $2^7=128$ 。因此，使用三进制数和五进制数的BISE技术在存储方面都是是有效率的 (见图38) 。\n [图38]: ISE 与 二进制编码的存储效率。(来源: CGDC2013 的 ASTC intro (65))\n ASTC 压缩方案使用 BISE 对颜色端点和插值权重进行编码。而且它还为插值权重提供了硬件友好的二次方除数。一个三进制位编码为三个权重 ${0, ½, 1}$ 中的一个，一个五进制位编码为 ${0, ¼, ½, ¾, 1}$ 这五个中的一个。此外，BISE允许对端点的精度进行细致的改变。表12中描述了所有使用三进位或五进位的彩色端点编码的情况。\n   Range Number of used digits Number of used digits Number of used digits Bit size Bit size      Trits Quints Bits Effective Theoretical Minimum   0..5 1  1 ~ 2.60 2.58   0..9  1 1 ~ 3.33 3.32   0..11 1  2 ~ 3.60 3.58   0..19  1 2 ~ 4.33 4.32   0..23 1  3 ~ 4.60 4.58   0..39  1 3 ~ 5.33 5.32   0..47 1  4 ~ 5.60 5.58   0..79  1 4 ~ 6.33 6.32   0..95 1  5 ~ 6.60 6.58   0..159  1 5 ~ 7.33 7.32   0..191 1  6 ~ 7.60 7.58     [表12] : 用于颜色反量化的参数。\n BISE解码之后，解包的数值被反量化为标准范围[0, 255]。\n其他改进 #  ASTC 还改进了分区模式。BC6H 和 BC7 压缩方案也使用了预定义的分区集表 (见图13) ，但这种方法不适合 ASTC，因为它支持大量的瓦片尺寸，支持更多的区域，还增加了分区ID字段的大小 (10位，而BC7是6位) 。ASTC 的分区模式是用一个特殊的哈希函数生成的，它为每个纹素分配一个分区索引。这个函数将纹素在瓦片中的位置、分区ID、瓦片大小和分区数量作为输入，并输出一个分区索引。该函数很简单，可以用硬件实现。该函数也用于 3D 纹理。图 39 中描述了 8x8 瓦片的所有分区模式。\n [图39]: ASTC 8x8 块的分区集。(来源: ARM Mail Graphics blogs (66))\n ASTC 的一个更显著的特点是内插权重的编码方式。S3TC 系列方案使用每个顶点的索引来设置插值权重。根据块的类型，索引的大小可以是 2、3 或 4 比特。然而，对于 12x12 瓦片来说，即使每个像素使用 1bit 的索引，也无法存储在一个 128 位块。因此，ASTC 为权重和纹素提供独立的网格大小。例如，对于 12x12 的瓦片，只能存储 4x6 的权重网格。在解码阶段，权重网格被双线性地放大到瓦片大小。不过虽然看起来像，但是它和简单的瓦片缩放并不一样。例如，平滑的梯度通常可以用一个小的权重网格来表示，如 2x2。因此有更多的比特可用于端点。同时尖锐的边缘和颜色过渡可以用适合的分区模式进行编码。权重网格的大小是根据每个块来选择的。因此某些具有强烈垂直特征的瓦片，可以用 4x2 或 8x4 的权重网格进行编码。\n所有这些配置数据 (网格大小、分区数量、端点格式) 都必须存储在一个压缩块中。虽然不得不牺牲一些颜色数据位，因而可能降低图像质量，但这种方法带来了很好的灵活性，并且大大增强了压缩质量。ASTC 允许在每个块中进行不同的比特权衡，任意瓦片都可以在分区、端点和权重之间的分布选用最合适的比特分布进行编码。事实证明，即使在较低的比特率下，ASTC也能够提供比 PVRTC、BC1-BC5 和 ETC 更好的质量。PSNR (译注：峰值信噪比) 增益平均为 1.5dB 至 2dB，大多数观察者 (译注：推测此处数值为 ASTC 对比其他压缩格式获得的增益 ) 大约能察觉 0.25dB 的增益。BC6H的质量与之相当，而 BC7 平均比 ASTC 多出0.5dB。不过在 8bpp 时，ASTC 和 BC7 压缩图像的 PSNR 质量都在45dB左右，这种差异很难从视觉上发现 (56) 。\n此外，ASTC 是第一个支持 3D 纹理的标准压缩方案，它利用了所有三个维度的颜色相关性。nVidia 的 OpenGL(26)的 VTC 扩展也是针对3D纹理的，但它只是把一个3D瓦片分成2D片，使用BC1方案进行压缩。ASTC 则使用 3D 权重网格和分区，利用分区模式生成器来压缩整个3D瓦片。不过权重网格是用单线法而非三线插值法进行放大的 (67) 。整个 3D 瓦片的压缩比分片压缩的 PSNR 高出 2dB (68) 。\n另外，ASTC 的所有特征都是 \u0026ldquo;正交 \u0026ldquo;的，即任何特征都可以独立使用，例如可以用两个弱相关的HDR通道来压缩一个三维纹理。\nASTC 块 #  首先是一些全局解码参数，这些参数对任何特定的纹理都是一样的。因此，没有必要在压缩块中存储这些。\n  动态范围 (LDR/HDR)\n  纹理尺寸(2D/3D)\n  瓦片尺寸\n  输出色彩空间 (sRGB/RGB)\n  而每块指定的数据如下。\n  权重网格大小\n  权重范围 (用于BISE解码\n  权重值\n  分区的数量\n  分区模式 ID\n  颜色端点模式\n  颜色端点数据\n  平面的数量 (1或2)\n  平面到通道的分配\n  纹理可以被编码为单通道、双通道、三通道或四通道图像。但解码后的值总是以 RGBA 格式输出。在LDR sRGB 模式下，颜色值以 8 位整数返回，否则以 16 位浮点数返回。图40展示了 ASTC 块的布局。\n [图40]: ASTC 块的布局。\n 除了 \u0026ldquo;BlockMode \u0026ldquo;和 \u0026ldquo;Part \u0026ldquo;字段，所有字段的长度都是可变的。\n\u0026ldquo;Part\u0026rdquo; 字段指定了分区的数量 (减一) 。在双平面模式下，分区的数量必须是1、2或3。\u0026ldquo;BlockMode\u0026rdquo; 字段指定了平面数、权重范围和权重网格的大小。\u0026ldquo;ConfigData\u0026rdquo; 和 \u0026ldquo;MoreConfigData\u0026rdquo; 字段指定每个端点对的端点模式。\n如果是 2D 瓦片，\u0026ldquo;BlockMode\u0026rdquo; 由5个字段组成。A、B、R、D、H (表13) 。 特殊的 \u0026ldquo;void-exten\u0026rdquo; 模式有一个单独的编码，用于单色瓦片。void-exten 块还允许识别附近的单色区域。可以缩短获取相同的块的过程，并进一步减少内存带宽占用。\n [表13] : 2D 块的 BlockMode 字段布局。(源自: ASTC 技术手册 (57))\n A、B 字段分别指定权重网格的宽度 (N) 和高度 (M) 。D位 (双倍) 被设置为表示双平面模式。R字段 (范围) 和H位 (高精度) 指定重量范围 (见表14) 。注意，由于R字段的编码，为了避免产生歧义，位 $R_1$ 和 $R_2$ 不能同时为零， (见表13) 。\n [表14] : 权重编码的参数\n ConfigData 和 MoreConfigData 指定了端点对的编码，每个端点对都可以有独立的编码模式。共有16种编码模式：10 种 LDR 格式和 6 种 HDR 格式。然而，HDR 纹理可以使用其中任何一种。所有这些端点格式都是基于以下基本方法之一:\n 独立性。两个k位的值直接存储。 base + offset (类似于ETC的差分编码) 。第一个值为base, 用 (k+1) 位存储。第二个值为 offset, 用 (k-1) 位存储。 base + scale。两个RGB值由四个数值 (R、G、B、s) 表示。颜色一等于 (R，G，B) ，颜色二等于 (sR，sG，sB) 。  在 ASTC 规范 (57) 和 ASTC 原始论文 (56) 中有所有端点模式和 BISE 编码的详细描述。\n从概念上讲，ASTC块的解码是这样进行的。BlockMode 字段用于确定权重范围和权重网格的大小。权重数据从压缩块的尾部读取，并使用BISE进行解包。之后，权重被反量化为 [0, 64] 范围。如果权重网格的尺寸小于瓦片的尺寸，则使用双线性插值进行升格。\n之后，Part 字段用于指定分区的数值。分区模式 ID 从块中读出，然后针对每个纹素生成哈希作为分区索引。\n给定分区数量，还可以利用 ConfigData 和 MoreConfigData 字段计算标量的总值，该值会被用于端点编码 (端点可以有不同数量的通道，不同的端点存储模式下会使用不同数量的值) 。然而，这些标量值的范围在 BISE 解码时必须是已知的，因为该范围并没有被明确指出。在权重和分区数据解码阶段之后，就可以知道可用于彩色端点数据的比特数。颜色端点的值会使用适用于上述比特数的最大范围的值来存储。端点被解压缩和反量化。\n端点对会根据分区索引来选择。端点的颜色则使用插值权重来混合。\n简要描述上文讨论的所有纹理压缩格式 #   [表15] : 本文所讨论的所有纹理压缩格式的简述 (已经弃用的方案使用灰色背景)\n 对压缩格式的选择受目标硬件限制。例如，S3TC 系列只在 PC 上可用。根据特定的移动平台，可能支持 ETC 或 PVRTC (一些设备支持 BC1-BC5，但并不常见) 。只有一些最新的移动GPU支持ASTC格式。\n在 S3TC 系列中：\n BC7能够为RGB和RGBA纹理提供最好的质量，可以完全取代BC2和BC3 BC1 可用于较低质量的RGB压缩 BC4 和 BC5 用于单通道和双通道纹理 BC6H 用于 HDR 纹理  PVRTC 被 PVRTC2 所取代，后者不仅提高了质量，解决了其前身的一些问题。PVRTC2 也支持 RGB 和 RGBA 纹理。\nETC2 完全取代了 PACKMAN 和 ETC 格式，但只支持RGB纹理。另外，ETC2 和 EAC 块的某些组合提供与 BC1-BC5 格式相仿的功能。\nASTC格式支持任何类型的纹理，并提供多种比特率以供选择。\n结论 #  纹理压缩在现代计算机图形中占重要地位。现如今，许多智能手机的显示屏已经具有 FullHD 分辨率 (1920x1080) ，而桌面 GPU 的则面向的是 4K 和 8K 这样的超高清分辨率 (分别为 3840x2160 和 7680x4320) ，大大增加了内存带宽要求。预计纹理的分辨率也会增长，高压缩比变得越来越重要。\n由于不同纹理的可接受的压缩伪影水平不同，针对每种纹理，需要选择能够保证图像质量的前提下，可以减少内存带宽的合适的压缩比。在可选格式中，ASTC 是最好的一种。虽然桌面 GPU 尚不支持，但我们相信 ASTC 会因为它的灵活性和质量而取代所有其他格式。在任何给定的比特率下，ASTC 的质量都优于除了 BC7 外的所有其他格式。广泛采用 ASTC 也将简化跨平台应用开发。\n至于纹理压缩的未来，目前的策略可能朝着增加块和瓦片的大小的方向发展。也有可能使用可变比特率 (VBR) 方案，进一步提高压缩的灵活性。\n这项工作由 AMD 公司 (Advanced Micro Devices, Inc.) 支持，并获得了俄罗斯联邦政府 074-U01号财政拨款的部分支持。作者在此感谢 Vladimir Kibardin 帮助撰写文章的英文版本。\n译者在此感谢原作者 T. Paltashev 与 I. Perminov 在翻译过程中提供的帮助。特别感谢 Zhongliang Chen 在校对过程中给出的专业建议和帮助。\nReferences #    McDonald John. Eliminating Texture Waste: Borderless Ptex. 2013. GDC2013.\n  Inada T. and McCool M. D. Compressed lossless texture representation and caching. New York, NY, USA : ACM, 2006. Proceedings of the 21st ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware. pp. 111-120.\n  Strom Jacob and Akenine-Moller Tomas. PACKMAN: Texture Compression for Mobile Phones. . New York, NY, USA : ACM, 2004. ACM SIGGRAPH 2004 Sketches.\n  van Waveren, J.M.P. id Tech 5 Challenges: From Texture Virtualization to Massive Parallelization. Siggraph. Part of Beyond programmable shading course. 2009.\n  Olano M., et al., et al. Variable Bit Rate GPU Texture Decompression. 2011. Computer Graphics Forum, vol. 30, pp. 1299–1308.\n  Strom Jacob and Wennersten Per. Lossless Compression of Already Compressed Textures. Strom Jacob and Wennersten Per. s.l.: Eurographics Association. High Performance Graphics, 2011, pp. 177-182.\n  Vorobev Andrey. 3DGiTogi iyul 2001 goda — Vliyanie tekhnologii S3TC (FXT1) na kachestvo i skorost [3DGiTogi ]uly 2001 - impact of technology S3TC (FXT1) on quality and speed]. 2001. Available at: http://www.ixbt.com/video/0701i-video-s3tc1.html\n  WesleyandSmith Ian N., Liska Milos and Holub Petr. Implementation of DXT Compression for UltraGrid. Implementation of DXT Compression for UltraGrid. s.l. : CESNET, 2008.\n  Petr Holub, et al., et al. GPU-accelerated DXT and JPEG compression schemes for low-latency network transmissions of HD, 2K, and 4K video. Future Generation Computer Systems, vol. 29, № 8, 2013, pp. 1991-2006.\n  van Waveren, J.M.P. Real-Time DXT Compression. Id Software. 2006. Tech. rep.\n  FastDXT. Available at: http://www.evl.uic.edu/cavern/fastdxt/\n  Fast CPU DXT Compression. 2012. Available at: http://software.intel.com/en-us/vcsource/samples/dxt-compression\n  Ilya Perminov. Povyshenie effektivnosti obrabotki dinamicheski szhimaemykh tekstur [Improvement of Dynamic Texture Compression]. Nauchno-tekhnicheskiy vestnik informatsionnykh tekhnologiy, mekhaniki i optiki [Scientific and Technical Journal of Information Technologies, Mechanics and Optics], vol. 6 (88), 2013 г., стр. 164-165.\n  Fenney Simon. Texture compression using low-frequency signal modulation. Eurographics Association, 2003. Graphics Hardware. pp. 84-91.\n  Rover Camera Instrument Description. Available at: http://pdsimg.jpl.nasa.gov/data/mpfr-m-rvrcam-2-edr-v1.0/mprv_0001/document/rcinst.htm\n  Iourcha Konstantine I., Hong Zhou and Nayak Krishna S. System and method for fixed-rate block-based image compression with inferred pixel values. US Patent 5,956,431 US, 1999.\n  EXT_texture_compression_dxt1 extension specification. 2008. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_dxt1.txt\n  EXT_texture_compression_s3tc extension specification. 2013. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_s3tc.txt\n  EXT_texture_compression_rgtc extension specification. 2008. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_rgtc.txt\n  ARB_texture_compression_rgtc extension specification. 2009. Available at: http://www.opengl.org/registry/specs/ARB/texture_compression_rgtc.txt\n  EXT_texture_compression_latc extension specification. [Online] 2009. Available at: http://www.opengl.org/registry/specs/EXT/texture_compression_latc.txt\n  ARB_texture_compression_bptc extension specification. [Online] 2011. Available at: http://www.opengl.org/registry/specs/ARB/texture_compression_bptc.txt\n  Castano Ignacio. GPU DXT Decompression. 2009. Available at: http://www.ludicon.com/castano/blog/2009/03/gpu-dxt-decompression/\n  van Waveren, J.M.P. and Castano, Ignacio. Real-Time Normal Map DXT Compression. Real-Time Normal Map DXT Compression. 2008.\n  Brown Simon. DXT Compression Techniques. 2006. Available at: http://www.sjbrown.co.uk/2006/01/19/dxt-compression-techniques/\n  NV_texture_compression_vtc extension specification. 2004. Available at: http://www.opengl.org/registry/specs/NV/texture_compression_vtc.txt\n  Block Compression (Direct3D 10). Available at: http://msdn.microsoft.com/en-us/library/windows/desktop/bb694531\n  Blinn James F. Jim Blinn\u0026rsquo;s Corner: Compositing, Part 1: Theory. IEEE-CGA, Vol. 14, 1994, pp. 83-87.\n  3Dc™ White Paper. Available at: http://www.hardwaresecrets.com/datasheets/3Dc_White_Paper.pdf\n  Texture Block Compression in Direct3D 11. Available at: http://msdn.microsoft.com/en-us/library/windows/desktop/hh308955\n  The OpenGL Graphics System: A Specification Version 4.2 (Core Profile). The OpenGL Graphics System: A Specification Version 4.2 (Core Profile). 2012.\n  Sovremennaya terminologiya 3D grafiki [Modern terminology 3D graphics]. Available at: http://www.ixbt.com/video2/terms2k5.shtml#hdr\n  OES_compressed_ETC1_RGB8_texture extension specification. 2008. Available at: http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt\n  WEBGL_compressed_texture_etc1 Extension Draft Specification. 2013. Available at: http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\n  The OpenGL Graphics System: A Specification Version 4.3 (Core Profile). The OpenGL Graphics System: A Specification Version 4.3 (Core Profile). 2013.\n  Strom Jacob and Akenine-Moller Tomas. iPACKMAN: High-quality, Low-complexity Texture Compression for Mobile Phones. New York, NY, USA : ACM, 2005. Proceedings of the ACM SIGGRAPH/EUROGRAPHICS Conference on Graphics Hardware. pp. 63-70.\n  Strom Jacob and Pettersson Martin. ETC2: Texture Compression Using Invalid Combinations. Aire-la-Ville, Switzerland : Eurographics Association, 2007. Proceedings of the 22Nd ACM SIGGRAPH/EUROGRAPHICS Symposium on Graphics Hardware. pp. 49-54.\n  Strom Jacob and Akenine-Moller Tomas. Multi-mode alpha image processing. US Patent 7,693,337 US, 2010.\n  Multi-mode image processing. US Patent 7,734,105 US, 2010.\n  Multi-mode image processing. US Patent 7,751,630 US, 2010.\n  Pettersson Martin and Strom Jacob. Texture compression based on two hues with modified brightness. US Patent 8,144,981 US, 2012.\n  The OpenGL Graphics System: A Specification Version 4.4 (Core Profile). The OpenGL Graphics System: A Specification Version 4.4 (Core Profile). 2013.\n  Fenney Simon. Method and apparatus for compressing data and decompressing compressed data. US Patent 7,236,649 US, 2007.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 7,242,811 US, 2007.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 8,204,324 US, 2012.\n  Method and apparatus for compressing data and decompressing compressed data. US Patent 8,526,726 US, 2013.\n  IMG_texture_compression_pvrtc extension specification. 2012. Available at: http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt\n  IMG_texture_compression_pvrtc2 extension specification. 2012. Available at: http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc2.txt\n  EXT_pvrtc_sRGB extension specification. 2013. Available at: http://www.khronos.org/registry/gles/extensions/EXT/EXT_pvrtc_sRGB.txt\n  WEBGL_compressed_texture_pvrtc Extension Draft Specification. 2013. Available at: http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n  51.Voica Alexandru. PVRTC: the most efficient texture compression standard for the mobile graphics world. [Online] January 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/pvrtc-the-most-efficient-texture-compression-standard-for-the-mobile-graphics-world\n Taking texture compression to a new dimension with PVRTC2. January 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/pvrtc2-taking-texture-compression-to-a-new-dimension\n  Beets Kristof. Understanding PowerVR Series5XT: PVRTC, PVRTC2 and texture compression. June 2013. Available at: http://withimagination.imgtec.com/index.php/powervr/understanding-powervr-series5xt-pvrtc-pvrtc2-and-texture-compression-part-6\n  Geldreich Rich. PVRTC Compression - First Experiments. Available at: https://sites.google.com/site/richgel99/early-pvrtc-compression-experiments\n  PVRTC Compression - First Coded 4bpp. PVR Texture. Available at: https://sites.google.com/site/richgel99/pvrtc-compression2\n  Nystad, Jorn, et al., et al., Adaptive Scalable Texture Compression. Eurographics Association. High Performance Graphics, 2012, pp. 105-114.\n  Ellis Sean and Nystad Jorn. ASTC Specification. 2012.\n  KHR_texture_compression_astc_hdr extension specification. 2013. Available at: http://www.opengl.org/registry/specs/KHR/texture_compression_astc_hdr.txt\n  ARM Launches Second Generation of MALI-T600 Graphics Processors Driving Improved User Experience for Tablets, Smartphones and Smart-TVs. 2012. Available at: http://www.arm.com/about/newsroom/arm-launches-second-generation-of-mali-t600-graphics-processors-driving-improved-user-experience.php\n  Lassen Jorn and Nystad Anders. Method of and apparatus for encoding and decoding data. UK Patent Application 2491689 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491448 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491687 GB, 2012.\n  Method of and apparatus for encoding and decoding data. UK Patent Application 2491688 GB, 2012.\n  Nystad Jorn Lassen, Anders and Olson, Tomas. Flexible Texture Compression Using Bounded Integer Sequence Encoding. New York, NY, USA : ACM, 2011. SIGGRAPH Asia 2011 Sketches. pp. 32:1\u0026ndash;32:2.\n  Ellis Sean. ARM ASTC Texture Compression. CGDC (China Game Developers Conference), 2013.\n  Smith Stacy. ASTC does it. 2013. Available at: http://community.arm.com/groups/arm-mali-graphics/blog/2013/10/22/astc-does-it\n  Gustavson Stefan. Simplex noise demystified. 2005. Available at: http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n  Ellis Sean. More ASTC in ARM Mali GPUs – High Dynamic Range and 3D. 2013. Available at: http://malideveloper.arm.com/engage-with-mali/more-astc-in-arm-mali-gpus-high-dynamic-range-and-3d/\n  "}]